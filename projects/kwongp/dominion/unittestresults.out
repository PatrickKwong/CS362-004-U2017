Output and coverage for running unittests and cardtests:
unittest1.c:
Testing getCost function...
Checking the costs from getCost function in dominion.c against
the costs at http://wiki.dominionstrategy.com/index.php/List_of_cards
---------------------------------------------------------------------

Testing curse:
Cost from getCost function: 0 coins
Cost from dominionstrategy: 0 coins
Great! The cost from getCost function matched the cost from rules.

Testing estate:
Cost from getCost function: 2 coins
Cost from dominionstrategy: 2 coins
Great! The cost from getCost function matched the cost from rules.

Testing duchy:
Cost from getCost function: 5 coins
Cost from dominionstrategy: 5 coins
Great! The cost from getCost function matched the cost from rules.

Testing province:
Cost from getCost function: 8 coins
Cost from dominionstrategy: 8 coins
Great! The cost from getCost function matched the cost from rules.

Testing copper:
Cost from getCost function: 0 coins
Cost from dominionstrategy: 0 coins
Great! The cost from getCost function matched the cost from rules.

Testing silver:
Cost from getCost function: 3 coins
Cost from dominionstrategy: 3 coins
Great! The cost from getCost function matched the cost from rules.

Testing gold:
Cost from getCost function: 6 coins
Cost from dominionstrategy: 6 coins
Great! The cost from getCost function matched the cost from rules.

Testing adventurer:
Cost from getCost function: 6 coins
Cost from dominionstrategy: 6 coins
Great! The cost from getCost function matched the cost from rules.

Testing council_room:
Cost from getCost function: 5 coins
Cost from dominionstrategy: 5 coins
Great! The cost from getCost function matched the cost from rules.

Testing feast:
Cost from getCost function: 4 coins
Cost from dominionstrategy: 4 coins
Great! The cost from getCost function matched the cost from rules.

Testing gardens:
Cost from getCost function: 4 coins
Cost from dominionstrategy: 4 coins
Great! The cost from getCost function matched the cost from rules.

Testing mine:
Cost from getCost function: 5 coins
Cost from dominionstrategy: 5 coins
Great! The cost from getCost function matched the cost from rules.

Testing remodel:
Cost from getCost function: 4 coins
Cost from dominionstrategy: 4 coins
Great! The cost from getCost function matched the cost from rules.

Testing smithy:
Cost from getCost function: 4 coins
Cost from dominionstrategy: 4 coins
Great! The cost from getCost function matched the cost from rules.

Testing village:
Cost from getCost function: 3 coins
Cost from dominionstrategy: 3 coins
Great! The cost from getCost function matched the cost from rules.

Testing baron:
Cost from getCost function: 4 coins
Cost from dominionstrategy: 4 coins
Great! The cost from getCost function matched the cost from rules.

Testing great_hall:
Cost from getCost function: 3 coins
Cost from dominionstrategy: 3 coins
Great! The cost from getCost function matched the cost from rules.

Testing minion:
Cost from getCost function: 5 coins
Cost from dominionstrategy: 5 coins
Great! The cost from getCost function matched the cost from rules.

Testing steward:
Cost from getCost function: 3 coins
Cost from dominionstrategy: 3 coins
Great! The cost from getCost function matched the cost from rules.

Testing tribute:
Cost from getCost function: 5 coins
Cost from dominionstrategy: 5 coins
Great! The cost from getCost function matched the cost from rules.

Testing ambassador:
Cost from getCost function: 3 coins
Cost from dominionstrategy: 3 coins
Great! The cost from getCost function matched the cost from rules.

Testing cutpurse:
Cost from getCost function: 4 coins
Cost from dominionstrategy: 4 coins
Great! The cost from getCost function matched the cost from rules.

Testing embargo:
Cost from getCost function: 2 coins
Cost from dominionstrategy: 2 coins
Great! The cost from getCost function matched the cost from rules.

Testing outpost:
Cost from getCost function: 5 coins
Cost from dominionstrategy: 5 coins
Great! The cost from getCost function matched the cost from rules.

Testing salvager:
Cost from getCost function: 4 coins
Cost from dominionstrategy: 4 coins
Great! The cost from getCost function matched the cost from rules.

Testing sea_hag:
Cost from getCost function: 4 coins
Cost from dominionstrategy: 4 coins
Great! The cost from getCost function matched the cost from rules.

Testing treasure_map:
Cost from getCost function: 4 coins
Cost from dominionstrategy: 4 coins
Great! The cost from getCost function matched the cost from rules.

-----------------------------------------
Final Testing results of getCost function
-----------------------------------------
All tests passed for the getCost function!

File 'unittest1.c'
Lines executed:87.23% of 235
Branches executed:100.00% of 58
Taken at least once:50.00% of 58
Calls executed:83.24% of 173
Creating 'unittest1.c.gcov'

        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* -----------------------------------------------------------------------
        -:    2: * CS362-004 Summer 2017 Assignment 3
        -:    3: * unittest1.c
        -:    4: * 
        -:    5: * Patrick Kwong
        -:    6: * kwongp@oregonstate.edu
        -:    7: *
        -:    8: * Unit test for dominion function: getCost
        -:    9: * getCost returns the value of the card
        -:   10: * I checked the value from getCost against dominionstrategy.com
        -:   11: * -----------------------------------------------------------------------
        -:   12: * Include the following lines in the makefile:
        -:   13: *
        -:   14: * unittest1: unittest1.c dominion.o rngs.o
        -:   15: *      gcc -o unittest1 -g  unittest1.c dominion.o rngs.o $(CFLAGS)
        -:   16: */
        -:   17:
        -:   18:#include "dominion.h"
        -:   19:#include "dominion_helpers.h"
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:
        -:   23:// testResult
        -:   24:// checks if the provided testCost from getCost against the provide correct
        -:   25:// returns 1 if getCost's cost doesn't make cost from rules
        -:   26:// return 0 if getCost's cost does make cost from rules
function testResult called 27 returned 100% blocks executed 67%
       27:   27:int testResult(int testCost, int correctCost)
        -:   28:{
       27:   29:    if(testCost != correctCost)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   30:    {
    #####:   31:        printf("BUG!!! The cost from getCost function did not match the cost from rules.\n\n");
call    0 never executed
    #####:   32:        return 1;
        -:   33:    }
        -:   34:    else
       27:   35:        printf("Great! The cost from getCost function matched the cost from rules.\n\n");
call    0 returned 100%
       27:   36:        return 0;
        -:   37:}
        -:   38:
function main called 1 returned 100% blocks executed 88%
        1:   39:int main() 
        -:   40:{
        -:   41:    int testCost, correctCost;
        1:   42:    int bugCount = 0;
        -:   43:
        1:   44:    printf("Testing getCost function...\n");
call    0 returned 100%
        1:   45:    printf("Checking the costs from getCost function in dominion.c against\n");
call    0 returned 100%
        1:   46:    printf("the costs at http://wiki.dominionstrategy.com/index.php/List_of_cards\n");
call    0 returned 100%
        1:   47:    printf("---------------------------------------------------------------------\n\n");
call    0 returned 100%
        -:   48:
        -:   49:    // curse card
        1:   50:    testCost = getCost(curse);
call    0 returned 100%
        1:   51:    correctCost = 0;
        1:   52:    printf("Testing curse:\n");
call    0 returned 100%
        1:   53:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   54:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:   55:    else
        -:   56:    {    
        1:   57:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:   58:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:   59:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:   60:    }
        -:   61:
        -:   62:    // estate card
        1:   63:    testCost = getCost(estate);
call    0 returned 100%
        1:   64:    correctCost = 2;
        1:   65:    printf("Testing estate:\n");
call    0 returned 100%
        1:   66:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   67:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:   68:    else
        -:   69:    {  
        1:   70:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:   71:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:   72:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:   73:    }
        -:   74:
        -:   75:    // duchy card
        1:   76:    testCost = getCost(duchy);
call    0 returned 100%
        1:   77:    correctCost = 5;
        1:   78:    printf("Testing duchy:\n");
call    0 returned 100%
        1:   79:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   80:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:   81:    else
        -:   82:    {  
        1:   83:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:   84:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:   85:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:   86:    }
        -:   87:
        -:   88:    // province card
        1:   89:    testCost = getCost(province);
call    0 returned 100%
        1:   90:    correctCost = 8;
        1:   91:    printf("Testing province:\n");
call    0 returned 100%
        1:   92:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   93:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:   94:    else
        -:   95:    {  
        1:   96:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:   97:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:   98:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:   99:    }
        -:  100:
        -:  101:    // copper card
        1:  102:    testCost = getCost(copper);
call    0 returned 100%
        1:  103:    correctCost = 0;
        1:  104:    printf("Testing copper:\n");
call    0 returned 100%
        1:  105:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  106:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  107:    else
        -:  108:    {  
        1:  109:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  110:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  111:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  112:    }
        -:  113:
        -:  114:    // silver card
        1:  115:    testCost = getCost(silver);
call    0 returned 100%
        1:  116:    correctCost = 3;
        1:  117:    printf("Testing silver:\n");
call    0 returned 100%
        1:  118:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  119:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  120:    else
        -:  121:    {  
        1:  122:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  123:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  124:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  125:    }
        -:  126:
        -:  127:    // gold card
        1:  128:    testCost = getCost(gold);
call    0 returned 100%
        1:  129:    correctCost = 6;
        1:  130:    printf("Testing gold:\n");
call    0 returned 100%
        1:  131:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  132:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  133:    else
        -:  134:    {  
        1:  135:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  136:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  137:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  138:    }
        -:  139:
        -:  140:    // adventurer card
        1:  141:    testCost = getCost(adventurer);
call    0 returned 100%
        1:  142:    correctCost = 6;
        1:  143:    printf("Testing adventurer:\n");
call    0 returned 100%
        1:  144:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  145:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  146:    else
        -:  147:    {  
        1:  148:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  149:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  150:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  151:    }
        -:  152:
        -:  153:    // council_room card
        1:  154:    testCost = getCost(council_room);
call    0 returned 100%
        1:  155:    correctCost = 5;
        1:  156:    printf("Testing council_room:\n");
call    0 returned 100%
        1:  157:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  158:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  159:    else
        -:  160:    {  
        1:  161:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  162:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  163:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  164:    }
        -:  165:
        -:  166:    // feast card
        1:  167:    testCost = getCost(feast);
call    0 returned 100%
        1:  168:    correctCost = 4;
        1:  169:    printf("Testing feast:\n");
call    0 returned 100%
        1:  170:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  171:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  172:    else
        -:  173:    {  
        1:  174:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  175:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  176:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  177:    }
        -:  178:
        -:  179:    // gardens card
        1:  180:    testCost = getCost(gardens);
call    0 returned 100%
        1:  181:    correctCost = 4;
        1:  182:    printf("Testing gardens:\n");
call    0 returned 100%
        1:  183:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  184:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  185:    else
        -:  186:    {  
        1:  187:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  188:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  189:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  190:    }
        -:  191:
        -:  192:    // mine card
        1:  193:    testCost = getCost(mine);
call    0 returned 100%
        1:  194:    correctCost = 5;
        1:  195:    printf("Testing mine:\n");
call    0 returned 100%
        1:  196:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  197:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  198:    else
        -:  199:    {  
        1:  200:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  201:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  202:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  203:    }
        -:  204:
        -:  205:    // remodel card
        1:  206:    testCost = getCost(remodel);
call    0 returned 100%
        1:  207:    correctCost = 4;
        1:  208:    printf("Testing remodel:\n");
call    0 returned 100%
        1:  209:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  210:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  211:    else
        -:  212:    {  
        1:  213:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  214:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  215:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  216:    }
        -:  217:
        -:  218:    // smithy card
        1:  219:    testCost = getCost(smithy);
call    0 returned 100%
        1:  220:    correctCost = 4;
        1:  221:    printf("Testing smithy:\n");
call    0 returned 100%
        1:  222:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  223:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  224:    else
        -:  225:    {  
        1:  226:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  227:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  228:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  229:    }
        -:  230:
        -:  231:    // village card
        1:  232:    testCost = getCost(village);
call    0 returned 100%
        1:  233:    correctCost = 3;
        1:  234:    printf("Testing village:\n");
call    0 returned 100%
        1:  235:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  236:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  237:    else
        -:  238:    {  
        1:  239:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  240:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  241:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  242:    }
        -:  243:
        -:  244:    // baron card
        1:  245:    testCost = getCost(baron);
call    0 returned 100%
        1:  246:    correctCost = 4;
        1:  247:    printf("Testing baron:\n");
call    0 returned 100%
        1:  248:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  249:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  250:    else
        -:  251:    {  
        1:  252:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  253:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  254:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  255:    }
        -:  256:
        -:  257:    // great_hall card
        1:  258:    testCost = getCost(great_hall);
call    0 returned 100%
        1:  259:    correctCost = 3;
        1:  260:    printf("Testing great_hall:\n");
call    0 returned 100%
        1:  261:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  262:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  263:    else
        -:  264:    {  
        1:  265:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  266:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  267:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  268:    }
        -:  269:
        -:  270:    // minion card
        1:  271:    testCost = getCost(minion);
call    0 returned 100%
        1:  272:    correctCost = 5;
        1:  273:    printf("Testing minion:\n");
call    0 returned 100%
        1:  274:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  275:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  276:    else
        -:  277:    {  
        1:  278:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  279:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  280:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  281:    }
        -:  282:
        -:  283:    // steward card
        1:  284:    testCost = getCost(steward);
call    0 returned 100%
        1:  285:    correctCost = 3;
        1:  286:    printf("Testing steward:\n");
call    0 returned 100%
        1:  287:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  288:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  289:    else
        -:  290:    {  
        1:  291:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  292:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  293:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  294:    }
        -:  295:
        -:  296:    // tribute card
        1:  297:    testCost = getCost(tribute);
call    0 returned 100%
        1:  298:    correctCost = 5;
        1:  299:    printf("Testing tribute:\n");
call    0 returned 100%
        1:  300:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  301:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  302:    else
        -:  303:    {  
        1:  304:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  305:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  306:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  307:    }
        -:  308:
        -:  309:    // ambassador card
        1:  310:    testCost = getCost(ambassador);
call    0 returned 100%
        1:  311:    correctCost = 3;
        1:  312:    printf("Testing ambassador:\n");
call    0 returned 100%
        1:  313:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  314:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  315:    else
        -:  316:    {  
        1:  317:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  318:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  319:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  320:    }
        -:  321:
        -:  322:    // cutpurse card
        1:  323:    testCost = getCost(cutpurse);
call    0 returned 100%
        1:  324:    correctCost = 4;
        1:  325:    printf("Testing cutpurse:\n");
call    0 returned 100%
        1:  326:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  327:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  328:    else
        -:  329:    {  
        1:  330:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  331:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  332:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  333:    }
        -:  334:
        -:  335:    // embargo card
        1:  336:    testCost = getCost(embargo);
call    0 returned 100%
        1:  337:    correctCost = 2;
        1:  338:    printf("Testing embargo:\n");
call    0 returned 100%
        1:  339:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  340:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  341:    else
        -:  342:    {  
        1:  343:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  344:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  345:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  346:    }
        -:  347:
        -:  348:    // outpost card
        1:  349:    testCost = getCost(outpost);
call    0 returned 100%
        1:  350:    correctCost = 5;
        1:  351:    printf("Testing outpost:\n");
call    0 returned 100%
        1:  352:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  353:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  354:    else
        -:  355:    {  
        1:  356:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  357:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  358:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  359:    }
        -:  360:
        -:  361:    // salvager card
        1:  362:    testCost = getCost(salvager);
call    0 returned 100%
        1:  363:    correctCost = 4;
        1:  364:    printf("Testing salvager:\n");
call    0 returned 100%
        1:  365:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  366:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  367:    else
        -:  368:    {  
        1:  369:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  370:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  371:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  372:    }
        -:  373:
        -:  374:    // sea_hag card
        1:  375:    testCost = getCost(sea_hag);
call    0 returned 100%
        1:  376:    correctCost = 4;
        1:  377:    printf("Testing sea_hag:\n");
call    0 returned 100%
        1:  378:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  379:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  380:    else
        -:  381:    {  
        1:  382:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  383:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  384:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  385:    }
        -:  386:
        -:  387:    // treasure_map card
        1:  388:    testCost = getCost(treasure_map);
call    0 returned 100%
        1:  389:    correctCost = 4;
        1:  390:    printf("Testing treasure_map:\n");
call    0 returned 100%
        1:  391:    if(testCost < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  392:        printf("getCost failed to provide cost for this card.\n");
call    0 never executed
        -:  393:    else
        -:  394:    {  
        1:  395:        printf("Cost from getCost function: %d coins\n",testCost);
call    0 returned 100%
        1:  396:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
call    0 returned 100%
        1:  397:        bugCount += testResult(testCost, correctCost);
call    0 returned 100%
        -:  398:    }
        -:  399:
        -:  400:    // market card - why isn't this base card in the dominion.c?
        -:  401:    /*
        -:  402:    testCost = getCost(market);
        -:  403:    correctCost = 5;
        -:  404:    printf("Testing market:\n");
        -:  405:    if(testCost < 0)
        -:  406:        printf("getCost failed to provide cost for this card.\n");
        -:  407:    else
        -:  408:    {
        -:  409:        printf("Cost from getCost function: %d coins\n",testCost);
        -:  410:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
        -:  411:        bugCount += testResult(testCost, correctCost);        
        -:  412:    }
        -:  413:
        -:  414:    // militia card - why isn't this base card in the dominion.c?
        -:  415:    testCost = getCost(militia);
        -:  416:    correctCost = 2;
        -:  417:    printf("Testing militia:\n");
        -:  418:    if(testCost < 0)
        -:  419:        printf("getCost failed to provide cost for this card.\n");
        -:  420:    else
        -:  421:    {
        -:  422:        printf("Cost from getCost function: %d coins\n",testCost);
        -:  423:        printf("Cost from dominionstrategy: %d coins\n",correctCost);
        -:  424:        bugCount += testResult(testCost, correctCost);        
        -:  425:    }
        -:  426:    */
        -:  427:
        -:  428:
        -:  429:    // output the test results overall
        1:  430:    printf("-----------------------------------------\n");
call    0 returned 100%
        1:  431:    printf("Final Testing results of getCost function\n");
call    0 returned 100%
        1:  432:    printf("-----------------------------------------\n");
call    0 returned 100%
        1:  433:    if(bugCount == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  434:        printf("All tests passed for the getCost function!\n\n");
call    0 returned 100%
        -:  435:    else
    #####:  436:        printf("getCost failed to get correct cost for %d cards(s), check above for which ones.\n\n", bugCount);
call    0 never executed
        -:  437:    
        1:  438:    return 0;
        -:  439:}
File 'dominion.c'
Lines executed:5.15% of 563
Branches executed:6.71% of 417
Taken at least once:6.47% of 417
Calls executed:0.00% of 100
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 0 returned 0% blocks executed 0%
    #####:    8:int compare(const void* a, const void* b) {
    #####:    9:  if (*(int*)a > *(int*)b)
branch  0 never executed
branch  1 never executed
    #####:   10:    return 1;
    #####:   11:  if (*(int*)a < *(int*)b)
branch  0 never executed
branch  1 never executed
    #####:   12:    return -1;
    #####:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 0 returned 0% blocks executed 0%
    #####:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
    #####:   44:  SelectStream(1);
call    0 never executed
    #####:   45:  PutSeed((long)randomSeed);
call    0 never executed
        -:   46:  
        -:   47:  //check number of players
    #####:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
    #####:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
    #####:   57:  for (i = 0; i < 10; i++)
branch  0 never executed
branch  1 never executed
        -:   58:    {
    #####:   59:      for (j = 0; j < 10; j++)
branch  0 never executed
branch  1 never executed
        -:   60:        {
    #####:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
    #####:   73:  if (numPlayers == 2)
branch  0 never executed
branch  1 never executed
        -:   74:    {
    #####:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
    #####:   77:  else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
    #####:   87:  if (numPlayers == 2)
branch  0 never executed
branch  1 never executed
        -:   88:    {
    #####:   89:      state->supplyCount[estate] = 8;
    #####:   90:      state->supplyCount[duchy] = 8;
    #####:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
    #####:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
    #####:  102:  state->supplyCount[silver] = 40;
    #####:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    #####:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 never executed
branch  1 never executed
        -:  107:    {
    #####:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 never executed
branch  1 never executed
        -:  109:	{
    #####:  110:	  if (kingdomCards[j] == i)
branch  0 never executed
branch  1 never executed
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    #####:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  114:		{
    #####:  115:		  if (numPlayers == 2){ 
branch  0 never executed
branch  1 never executed
    #####:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
    #####:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    #####:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    #####:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    #####:  138:  for (i = 0; i < numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  139:    {
    #####:  140:      state->deckCount[i] = 0;
    #####:  141:      for (j = 0; j < 3; j++)
branch  0 never executed
branch  1 never executed
        -:  142:	{
    #####:  143:	  state->deck[i][j] = estate;
    #####:  144:	  state->deckCount[i]++;
        -:  145:	}
    #####:  146:      for (j = 3; j < 10; j++)
branch  0 never executed
branch  1 never executed
        -:  147:	{
    #####:  148:	  state->deck[i][j] = copper;
    #####:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    #####:  154:  for (i = 0; i < numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  155:    {
    #####:  156:      if ( shuffle(i, state) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
    #####:  163:  for (i = 0; i < numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  164:    {  
        -:  165:      //initialize hand size to zero
    #####:  166:      state->handCount[i] = 0;
    #####:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    #####:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 never executed
branch  1 never executed
        -:  177:    {
    #####:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
    #####:  182:  state->outpostPlayed = 0;
    #####:  183:  state->phase = 0;
    #####:  184:  state->numActions = 1;
    #####:  185:  state->numBuys = 1;
    #####:  186:  state->playedCardCount = 0;
    #####:  187:  state->whoseTurn = 0;
    #####:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    #####:  192:  for (it = 0; it < 5; it++){
branch  0 never executed
branch  1 never executed
    #####:  193:    drawCard(state->whoseTurn, state);
call    0 never executed
        -:  194:  }
        -:  195:
    #####:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 never executed
        -:  197:
    #####:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 0 returned 0% blocks executed 0%
    #####:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
    #####:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
    #####:  209:  if (state->deckCount[player] < 1)
branch  0 never executed
branch  1 never executed
    #####:  210:    return -1;
    #####:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 never executed
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    #####:  214:  while (state->deckCount[player] > 0) {
branch  0 never executed
branch  1 never executed
    #####:  215:    card = floor(Random() * state->deckCount[player]);
call    0 never executed
    #####:  216:    newDeck[newDeckPos] = state->deck[player][card];
    #####:  217:    newDeckPos++;
    #####:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 never executed
branch  1 never executed
    #####:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
    #####:  221:    state->deckCount[player]--;
        -:  222:  }
    #####:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 never executed
branch  1 never executed
    #####:  224:    state->deck[player][i] = newDeck[i];
    #####:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
    #####:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  320:int supplyCount(int card, struct gameState *state) {
    #####:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 0 returned 0% blocks executed 0%
    #####:  346:int whoseTurn(struct gameState *state) {
    #####:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 0 returned 0% blocks executed 0%
    #####:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
    #####:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 never executed
branch  1 never executed
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
    #####:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
    #####:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
    #####:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    #####:  576:    state->deckCount[player]--;
    #####:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
    #####:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 27 returned 100% blocks executed 97%
       27:  583:int getCost(int cardNumber)
        -:  584:{
       27:  585:  switch( cardNumber ) 
branch  0 taken 4%
branch  1 taken 4%
branch  2 taken 4%
branch  3 taken 4%
branch  4 taken 4%
branch  5 taken 4%
branch  6 taken 4%
branch  7 taken 4%
branch  8 taken 4%
branch  9 taken 4%
branch 10 taken 4%
branch 11 taken 4%
branch 12 taken 4%
branch 13 taken 4%
branch 14 taken 4%
branch 15 taken 4%
branch 16 taken 4%
branch 17 taken 4%
branch 18 taken 4%
branch 19 taken 4%
branch 20 taken 4%
branch 21 taken 4%
branch 22 taken 4%
branch 23 taken 4%
branch 24 taken 4%
branch 25 taken 4%
branch 26 taken 4%
branch 27 taken 0%
        -:  586:    {
        -:  587:    case curse:
        1:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        1:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        1:  608:      return 4;
        -:  609:    case mine:
        1:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        1:  614:      return 4;
        -:  615:    case village:
        1:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        1:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        1:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        1:  630:      return 4;
        -:  631:    case embargo: 
        1:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        1:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:// Assignment 2 - refactor card #1: Adventurer
function adventurer_func called 0 returned 0% blocks executed 0%
    #####:  647:int adventurer_func(struct gameState *state)
        -:  648:{
        -:  649:	int cardDrawn;
    #####:  650:	int currentPlayer = whoseTurn(state);	
call    0 never executed
    #####:  651:	int drawntreasure = 0;
        -:  652:	int temphand[MAX_HAND];// moved above the if statement
    #####:  653:	int z = 0;// this is the counter for the temp hand
        -:  654:    
    #####:  655:	while(drawntreasure <= 2) // BUG added!! - Changed to < to <= that what it could end up drawing extra treasure.
branch  0 never executed
branch  1 never executed
        -:  656:	{
        -:  657:		//if the deck is empty we need to shuffle discard and add to deck
    #####:  658:		if (state->deckCount[currentPlayer] <1)
branch  0 never executed
branch  1 never executed
    #####:  659:			shuffle(currentPlayer, state);
call    0 never executed
        -:  660:		
    #####:  661:		drawCard(currentPlayer, state);
call    0 never executed
        -:  662:		
        -:  663:			//top card of hand is most recently drawn card.
    #####:  664:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  665:	
    #####:  666:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  667:				drawntreasure++;
        -:  668:			else
        -:  669:			{
    #####:  670:				temphand[z] = cardDrawn;
        -:  671:				
        -:  672:				//this should just remove the top card (the most recently drawn one).
    #####:  673:				state->handCount[currentPlayer]--; 
    #####:  674:				z++;
        -:  675:			}
        -:  676:		}
        -:  677:      
    #####:  678:		while(z - 1 >= 0)
branch  0 never executed
branch  1 never executed
        -:  679:		{
        -:  680:			// discard all cards in play that have been drawn
    #####:  681:			state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; 
    #####:  682:			z = z - 1;
        -:  683:		}
        -:  684:		
    #####:  685:		return 0;
        -:  686:}
        -:  687:
        -:  688:// Assignment 2 - refactor card #2: Council Room
function council_room_func called 0 returned 0% blocks executed 0%
    #####:  689:int council_room_func(int handPos, struct gameState *state)
        -:  690:{
        -:  691:	int i;
    #####:  692:	int currentPlayer = whoseTurn(state);	
call    0 never executed
        -:  693:	
        -:  694:	//+4 Cards
    #####:  695:	for (i = 1; i < 4; i++) // BUG added!!! = changed i=0 to i=1, which will result in 1 less card drawn.
branch  0 never executed
branch  1 never executed
    #####:  696:		drawCard(currentPlayer, state);
call    0 never executed
        -:  697:
        -:  698:	//+1 Buy
    #####:  699:	state->numBuys++;
        -:  700:	
        -:  701:	//Each other player draws a card
    #####:  702:	for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
    #####:  703:		if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
    #####:  704:			drawCard(i, state);
call    0 never executed
        -:  705:
        -:  706:	//put played card in played card pile
    #####:  707:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  708:
    #####:  709:	return 0;
        -:  710:}
        -:  711:
        -:  712:
        -:  713:// Assignment 2 - refactor card #3: Remodel
function remodel_func called 0 returned 0% blocks executed 0%
    #####:  714:int remodel_func(int choice1, int choice2, int handPos, struct gameState *state)
        -:  715:{
        -:  716:	int i;
        -:  717:	int j;
    #####:  718:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  719:    
    #####:  720:	j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  721:
    #####:  722:	if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  723:		return -1;
        -:  724:
    #####:  725:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  726:
        -:  727:	//discard card from hand
    #####:  728:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  729:
        -:  730:	//discard trashed card
    #####:  731:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  732:	{
    #####:  733:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  734:	    {
    #####:  735:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  736:			break;
        -:  737:	    }
        -:  738:	}
        -:  739:	
    #####:  740:	return 0;
        -:  741:}
        -:  742:
        -:  743:// Assignment 2 - refactor card #4: Smithy
function smithy_func called 0 returned 0% blocks executed 0%
    #####:  744:int smithy_func(int handPos, struct gameState *state)
        -:  745:{
        -:  746:	int i;
    #####:  747:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  748:	
        -:  749:	//+3 Cards
    #####:  750:	for (i = 0; i <= 3; i++) // BUG added!!! = changed < to <=, which will result in 1 more card drawn.
branch  0 never executed
branch  1 never executed
    #####:  751:		drawCard(currentPlayer, state);
call    0 never executed
        -:  752:
        -:  753:	//discard card from hand
    #####:  754:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  755:	
    #####:  756:	return 0;
        -:  757:}
        -:  758:
        -:  759:// Assignment 2 - refactor card #5: Village
function village_func called 0 returned 0% blocks executed 0%
    #####:  760:int village_func(int handPos, struct gameState *state)
        -:  761:{
    #####:  762:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  763:	
        -:  764:	//+1 Card
    #####:  765:	drawCard(currentPlayer, state);
call    0 never executed
        -:  766:			
        -:  767:	//+2 Actions
    #####:  768:	state->numActions = state->numActions + 22; // BUG added!!! = changed 2 to 22, which will result in +22 actions instead of just 2.
        -:  769:			
        -:  770:	//discard played card from hand
    #####:  771:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  772:
    #####:  773:	return 0;
        -:  774:}
        -:  775:
        -:  776:// cardEffect - for assignment 2 - I refactored 5 of these cards (adventurer, 
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  777:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  778:{
        -:  779:  int i;
        -:  780:  int j;
        -:  781:  int k;
        -:  782:  int x;
        -:  783:  int index;
    #####:  784:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  785:  int nextPlayer = currentPlayer + 1;
        -:  786:
    #####:  787:  int tributeRevealedCards[2] = {-1, -1};
        -:  788:  int temphand[MAX_HAND];// moved above the if statement
        -:  789:
    #####:  790:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  791:    nextPlayer = 0;
        -:  792:  }
        -:  793:  
        -:  794:  /* these variables are no longer needed after refactoring
        -:  795:  
        -:  796:    int drawntreasure=0;
        -:  797:	int cardDrawn;
        -:  798:	int z = 0;// this is the counter for the temp hand
        -:  799:	*/
        -:  800:	
        -:  801:  //uses switch to select card and perform actions
    #####:  802:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  803:    {
        -:  804:    case adventurer:
        -:  805:	
    #####:  806:		adventurer_func(state);
call    0 never executed
        -:  807:		
        -:  808:		/* commented out code that is no longer needed due to refactoring
        -:  809:		while(drawntreasure<2)
        -:  810:		{
        -:  811:			//if the deck is empty we need to shuffle discard and add to deck
        -:  812:			if (state->deckCount[currentPlayer] <1)
        -:  813:				shuffle(currentPlayer, state);
        -:  814:		
        -:  815:			drawCard(currentPlayer, state);
        -:  816:		
        -:  817:			//top card of hand is most recently drawn card.
        -:  818:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  819:	
        -:  820:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:  821:				drawntreasure++;
        -:  822:			else
        -:  823:			{
        -:  824:				temphand[z]=cardDrawn;
        -:  825:				
        -:  826:				//this should just remove the top card (the most recently drawn one).
        -:  827:				state->handCount[currentPlayer]--; 
        -:  828:				z++;
        -:  829:			}
        -:  830:		}
        -:  831:      
        -:  832:		while(z-1>=0)
        -:  833:		{
        -:  834:			// discard all cards in play that have been drawn
        -:  835:			state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; 
        -:  836:			z=z-1;
        -:  837:		}
        -:  838:		return 0;
        -:  839:		*/
        -:  840:	
        -:  841:    case council_room:
        -:  842:		
    #####:  843:		council_room_func(handPos, state);
call    0 never executed
        -:  844:		
        -:  845:		/* commented out code that is no longer needed due to refactoring
        -:  846:		
        -:  847:		//+4 Cards
        -:  848:		  for (i = 0; i < 4; i++)
        -:  849:		{
        -:  850:		  drawCard(currentPlayer, state);
        -:  851:		}
        -:  852:				
        -:  853:		  //+1 Buy
        -:  854:		  state->numBuys++;
        -:  855:				
        -:  856:		  //Each other player draws a card
        -:  857:		  for (i = 0; i < state->numPlayers; i++)
        -:  858:		{
        -:  859:		  if ( i != currentPlayer )
        -:  860:			{
        -:  861:			  drawCard(i, state);
        -:  862:			}
        -:  863:		}
        -:  864:				
        -:  865:		  //put played card in played card pile
        -:  866:		  discardCard(handPos, currentPlayer, state, 0);
        -:  867:				
        -:  868:		  return 0;
        -:  869:		*/
        -:  870:		
        -:  871:    case feast:
        -:  872:      //gain card with cost up to 5
        -:  873:      //Backup hand
    #####:  874:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  875:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  876:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  877:      }
        -:  878:      //Backup hand
        -:  879:
        -:  880:      //Update Coins for Buy
    #####:  881:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  882:      x = 1;//Condition to loop on
    #####:  883:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  884:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  885:	  if (DEBUG)
        -:  886:	    printf("None of that card left, sorry!\n");
        -:  887:
        -:  888:	  if (DEBUG){
        -:  889:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  890:	  }
        -:  891:	}
    #####:  892:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  893:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  894:
        -:  895:	  if (DEBUG){
        -:  896:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  897:	  }
        -:  898:	}
        -:  899:	else{
        -:  900:
        -:  901:	  if (DEBUG){
        -:  902:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  903:	  }
        -:  904:
    #####:  905:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  906:	  x = 0;//No more buying cards
        -:  907:
        -:  908:	  if (DEBUG){
        -:  909:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  910:	  }
        -:  911:
        -:  912:	}
        -:  913:      }     
        -:  914:
        -:  915:      //Reset Hand
    #####:  916:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  917:	state->hand[currentPlayer][i] = temphand[i];
    #####:  918:	temphand[i] = -1;
        -:  919:      }
        -:  920:      //Reset Hand
        -:  921:      			
    #####:  922:      return 0;
        -:  923:			
        -:  924:    case gardens:
    #####:  925:      return -1;
        -:  926:			
        -:  927:    case mine:
    #####:  928:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  929:
    #####:  930:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  931:	{
    #####:  932:	  return -1;
        -:  933:	}
        -:  934:		
    #####:  935:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  936:	{
    #####:  937:	  return -1;
        -:  938:	}
        -:  939:
    #####:  940:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  941:	{
    #####:  942:	  return -1;
        -:  943:	}
        -:  944:
    #####:  945:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  946:
        -:  947:      //discard card from hand
    #####:  948:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  949:
        -:  950:      //discard trashed card
    #####:  951:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  952:	{
    #####:  953:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  954:	    {
    #####:  955:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  956:	      break;
        -:  957:	    }
        -:  958:	}
        -:  959:			
    #####:  960:      return 0;
        -:  961:			
        -:  962:    case remodel:
        -:  963:	
    #####:  964:		remodel_func(choice1, choice2, handPos, state);
call    0 never executed
        -:  965:		
        -:  966:		/* commented out code that is no longer needed due to refactoring
        -:  967:			
        -:  968:		  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  969:
        -:  970:		  if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  971:		{
        -:  972:		  return -1;
        -:  973:		}
        -:  974:
        -:  975:		  gainCard(choice2, state, 0, currentPlayer);
        -:  976:
        -:  977:		  //discard card from hand
        -:  978:		  discardCard(handPos, currentPlayer, state, 0);
        -:  979:
        -:  980:		  //discard trashed card
        -:  981:		  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  982:		{
        -:  983:		  if (state->hand[currentPlayer][i] == j)
        -:  984:			{
        -:  985:			  discardCard(i, currentPlayer, state, 0);			
        -:  986:			  break;
        -:  987:			}
        -:  988:		}
        -:  989:
        -:  990:		  return 0;
        -:  991:		*/
        -:  992:		
        -:  993:    case smithy:
        -:  994:	
    #####:  995:		smithy_func(handPos, state);
call    0 never executed
        -:  996:		
        -:  997:		/* commented out code that is no longer needed due to refactoring
        -:  998:			
        -:  999:		  //+3 Cards
        -: 1000:		  for (i = 0; i < 3; i++)
        -: 1001:		{
        -: 1002:		  drawCard(currentPlayer, state);
        -: 1003:		}
        -: 1004:				
        -: 1005:		  //discard card from hand
        -: 1006:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1007:		  return 0;
        -: 1008:		*/
        -: 1009:			
        -: 1010:    case village:
        -: 1011:	
    #####: 1012:		village_func(handPos, state);
call    0 never executed
        -: 1013:		
        -: 1014:		/* commented out code that is no longer needed due to refactoring
        -: 1015:			
        -: 1016:		  //+1 Card
        -: 1017:		  drawCard(currentPlayer, state);
        -: 1018:				
        -: 1019:		  //+2 Actions
        -: 1020:		  state->numActions = state->numActions + 2;
        -: 1021:				
        -: 1022:		  //discard played card from hand
        -: 1023:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1024:		  return 0;
        -: 1025:		*/
        -: 1026:		
        -: 1027:    case baron:
    #####: 1028:      state->numBuys++;//Increase buys by 1!
    #####: 1029:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####: 1030:	int p = 0;//Iterator for hand!
    #####: 1031:	int card_not_discarded = 1;//Flag for discard set!
    #####: 1032:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####: 1033:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####: 1034:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####: 1035:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1036:	    state->discardCount[currentPlayer]++;
    #####: 1037:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####: 1038:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -: 1039:	    }
    #####: 1040:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1041:	    state->handCount[currentPlayer]--;
    #####: 1042:	    card_not_discarded = 0;//Exit the loop
        -: 1043:	  }
    #####: 1044:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -: 1045:	    if(DEBUG) {
        -: 1046:	      printf("No estate cards in your hand, invalid choice\n");
        -: 1047:	      printf("Must gain an estate if there are any\n");
        -: 1048:	    }
    #####: 1049:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1050:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####: 1051:	      state->supplyCount[estate]--;//Decrement estates
    #####: 1052:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1053:		isGameOver(state);
call    0 never executed
        -: 1054:	      }
        -: 1055:	    }
    #####: 1056:	    card_not_discarded = 0;//Exit the loop
        -: 1057:	  }
        -: 1058:			    
        -: 1059:	  else{
    #####: 1060:	    p++;//Next card
        -: 1061:	  }
        -: 1062:	}
        -: 1063:      }
        -: 1064:			    
        -: 1065:      else{
    #####: 1066:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1067:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####: 1068:	  state->supplyCount[estate]--;//Decrement Estates
    #####: 1069:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1070:	    isGameOver(state);
call    0 never executed
        -: 1071:	  }
        -: 1072:	}
        -: 1073:      }
        -: 1074:	    
        -: 1075:      
    #####: 1076:      return 0;
        -: 1077:		
        -: 1078:    case great_hall:
        -: 1079:      //+1 Card
    #####: 1080:      drawCard(currentPlayer, state);
call    0 never executed
        -: 1081:			
        -: 1082:      //+1 Actions
    #####: 1083:      state->numActions++;
        -: 1084:			
        -: 1085:      //discard card from hand
    #####: 1086:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1087:      return 0;
        -: 1088:		
        -: 1089:    case minion:
        -: 1090:      //+1 action
    #####: 1091:      state->numActions++;
        -: 1092:			
        -: 1093:      //discard card from hand
    #####: 1094:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1095:			
    #####: 1096:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -: 1097:	{
    #####: 1098:	  state->coins = state->coins + 2;
        -: 1099:	}
        -: 1100:			
    #####: 1101:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -: 1102:	{
        -: 1103:	  //discard hand
    #####: 1104:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1105:	    {
    #####: 1106:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1107:	    }
        -: 1108:				
        -: 1109:	  //draw 4
    #####: 1110:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1111:	    {
    #####: 1112:	      drawCard(currentPlayer, state);
call    0 never executed
        -: 1113:	    }
        -: 1114:				
        -: 1115:	  //other players discard hand and redraw if hand size > 4
    #####: 1116:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1117:	    {
    #####: 1118:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1119:		{
    #####: 1120:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1121:		    {
        -: 1122:		      //discard hand
    #####: 1123:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1124:			{
    #####: 1125:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1126:			}
        -: 1127:							
        -: 1128:		      //draw 4
    #####: 1129:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1130:			{
    #####: 1131:			  drawCard(i, state);
call    0 never executed
        -: 1132:			}
        -: 1133:		    }
        -: 1134:		}
        -: 1135:	    }
        -: 1136:				
        -: 1137:	}
    #####: 1138:      return 0;
        -: 1139:		
        -: 1140:    case steward:
    #####: 1141:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1142:	{
        -: 1143:	  //+2 cards
    #####: 1144:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1145:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1146:	}
    #####: 1147:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1148:	{
        -: 1149:	  //+2 coins
    #####: 1150:	  state->coins = state->coins + 2;
        -: 1151:	}
        -: 1152:      else
        -: 1153:	{
        -: 1154:	  //trash 2 cards in hand
    #####: 1155:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1156:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1157:	}
        -: 1158:			
        -: 1159:      //discard card from hand
    #####: 1160:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1161:      return 0;
        -: 1162:		
        -: 1163:    case tribute:
    #####: 1164:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1165:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1166:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1167:	  state->deckCount[nextPlayer]--;
        -: 1168:	}
    #####: 1169:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1170:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1171:	  state->discardCount[nextPlayer]--;
        -: 1172:	}
        -: 1173:	else{
        -: 1174:	  //No Card to Reveal
        -: 1175:	  if (DEBUG){
        -: 1176:	    printf("No cards to reveal\n");
        -: 1177:	  }
        -: 1178:	}
        -: 1179:      }
        -: 1180:	    
        -: 1181:      else{
    #####: 1182:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1183:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1184:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1185:	    state->deckCount[nextPlayer]++;
    #####: 1186:	    state->discard[nextPlayer][i] = -1;
    #####: 1187:	    state->discardCount[nextPlayer]--;
        -: 1188:	  }
        -: 1189:			    
    #####: 1190:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1191:	} 
    #####: 1192:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1193:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1194:	state->deckCount[nextPlayer]--;
    #####: 1195:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1196:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1197:	state->deckCount[nextPlayer]--;
        -: 1198:      }    
        -: 1199:		       
    #####: 1200:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1201:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1202:	state->playedCardCount++;
    #####: 1203:	tributeRevealedCards[1] = -1;
        -: 1204:      }
        -: 1205:
    #####: 1206:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1207:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1208:	  state->coins += 2;
        -: 1209:	}
        -: 1210:		    
    #####: 1211:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1212:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1213:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1214:	}
        -: 1215:	else{//Action Card
    #####: 1216:	  state->numActions = state->numActions + 2;
        -: 1217:	}
        -: 1218:      }
        -: 1219:	    
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case ambassador:
    #####: 1223:      j = 0;		//used to check if player has enough cards to discard
        -: 1224:
    #####: 1225:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1226:	{
    #####: 1227:	  return -1;				
        -: 1228:	}
        -: 1229:
    #####: 1230:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1231:	{
    #####: 1232:	  return -1;
        -: 1233:	}
        -: 1234:
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1238:	    {
    #####: 1239:	      j++;
        -: 1240:	    }
        -: 1241:	}
    #####: 1242:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1243:	{
    #####: 1244:	  return -1;				
        -: 1245:	}
        -: 1246:
        -: 1247:      if (DEBUG) 
        -: 1248:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1249:
        -: 1250:      //increase supply count for choosen card by amount being discarded
    #####: 1251:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1252:			
        -: 1253:      //each other player gains a copy of revealed card
    #####: 1254:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:	{
    #####: 1256:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1257:	    {
    #####: 1258:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1259:	    }
        -: 1260:	}
        -: 1261:
        -: 1262:      //discard played card from hand
    #####: 1263:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1264:
        -: 1265:      //trash copies of cards returned to supply
    #####: 1266:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1267:	{
    #####: 1268:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1269:	    {
    #####: 1270:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1271:		{
    #####: 1272:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1273:		  break;
        -: 1274:		}
        -: 1275:	    }
        -: 1276:	}			
        -: 1277:
    #####: 1278:      return 0;
        -: 1279:		
        -: 1280:    case cutpurse:
        -: 1281:
    #####: 1282:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1283:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1284:	{
    #####: 1285:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1286:	    {
    #####: 1287:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1288:		{
    #####: 1289:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1290:		    {
    #####: 1291:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1292:		      break;
        -: 1293:		    }
    #####: 1294:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1295:		    {
    #####: 1296:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1297:			{
        -: 1298:			  if (DEBUG)
        -: 1299:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1300:			}	
    #####: 1301:		      break;
        -: 1302:		    }		
        -: 1303:		}
        -: 1304:					
        -: 1305:	    }
        -: 1306:				
        -: 1307:	}				
        -: 1308:
        -: 1309:      //discard played card from hand
    #####: 1310:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1311:
    #####: 1312:      return 0;
        -: 1313:
        -: 1314:		
        -: 1315:    case embargo: 
        -: 1316:      //+2 Coins
    #####: 1317:      state->coins = state->coins + 2;
        -: 1318:			
        -: 1319:      //see if selected pile is in play
    #####: 1320:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1321:	{
    #####: 1322:	  return -1;
        -: 1323:	}
        -: 1324:			
        -: 1325:      //add embargo token to selected supply pile
    #####: 1326:      state->embargoTokens[choice1]++;
        -: 1327:			
        -: 1328:      //trash card
    #####: 1329:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1330:      return 0;
        -: 1331:		
        -: 1332:    case outpost:
        -: 1333:      //set outpost flag
    #####: 1334:      state->outpostPlayed++;
        -: 1335:			
        -: 1336:      //discard card
    #####: 1337:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1338:      return 0;
        -: 1339:		
        -: 1340:    case salvager:
        -: 1341:      //+1 buy
    #####: 1342:      state->numBuys++;
        -: 1343:			
    #####: 1344:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1345:	{
        -: 1346:	  //gain coins equal to trashed card
    #####: 1347:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1348:	  //trash card
    #####: 1349:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1350:	}
        -: 1351:			
        -: 1352:      //discard card
    #####: 1353:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1354:      return 0;
        -: 1355:		
        -: 1356:    case sea_hag:
    #####: 1357:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1358:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1359:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1360:	  state->discardCount[i]++;
    #####: 1361:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1362:	}
        -: 1363:      }
    #####: 1364:      return 0;
        -: 1365:		
        -: 1366:    case treasure_map:
        -: 1367:      //search hand for another treasure_map
    #####: 1368:      index = -1;
    #####: 1369:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1370:	{
    #####: 1371:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1372:	    {
    #####: 1373:	      index = i;
    #####: 1374:	      break;
        -: 1375:	    }
        -: 1376:	}
    #####: 1377:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1378:	{
        -: 1379:	  //trash both treasure cards
    #####: 1380:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1381:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1382:
        -: 1383:	  //gain 4 Gold cards
    #####: 1384:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1385:	    {
    #####: 1386:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1387:	    }
        -: 1388:				
        -: 1389:	  //return success
    #####: 1390:	  return 1;
        -: 1391:	}
        -: 1392:			
        -: 1393:      //no second treasure_map found in hand
    #####: 1394:      return -1;
        -: 1395:    }
        -: 1396:	
    #####: 1397:  return -1;
        -: 1398:}
        -: 1399:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1400:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1401:{
        -: 1402:	
        -: 1403:  //if card is not trashed, added to Played pile 
    #####: 1404:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1405:    {
        -: 1406:      //add card to played pile
    #####: 1407:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1408:      state->playedCardCount++;
        -: 1409:    }
        -: 1410:	
        -: 1411:  //set played card to -1
    #####: 1412:  state->hand[currentPlayer][handPos] = -1;
        -: 1413:	
        -: 1414:  //remove card from player's hand
    #####: 1415:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1416:    {
        -: 1417:      //reduce number of cards in hand
    #####: 1418:      state->handCount[currentPlayer]--;
        -: 1419:    }
    #####: 1420:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1421:    {
        -: 1422:      //reduce number of cards in hand
    #####: 1423:      state->handCount[currentPlayer]--;
        -: 1424:    }
        -: 1425:  else 	
        -: 1426:    {
        -: 1427:      //replace discarded card with last card in hand
    #####: 1428:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1429:      //set last card to -1
    #####: 1430:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1431:      //reduce number of cards in hand
    #####: 1432:      state->handCount[currentPlayer]--;
        -: 1433:    }
        -: 1434:	
    #####: 1435:  return 0;
        -: 1436:}
        -: 1437:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1438:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1439:{
        -: 1440:  //Note: supplyPos is enum of choosen card
        -: 1441:	
        -: 1442:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1443:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1444:    {
    #####: 1445:      return -1;
        -: 1446:    }
        -: 1447:	
        -: 1448:  //added card for [whoseTurn] current player:
        -: 1449:  // toFlag = 0 : add to discard
        -: 1450:  // toFlag = 1 : add to deck
        -: 1451:  // toFlag = 2 : add to hand
        -: 1452:
    #####: 1453:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1454:    {
    #####: 1455:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1456:      state->deckCount[player]++;
        -: 1457:    }
    #####: 1458:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1459:    {
    #####: 1460:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1461:      state->handCount[player]++;
        -: 1462:    }
        -: 1463:  else
        -: 1464:    {
    #####: 1465:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1466:      state->discardCount[player]++;
        -: 1467:    }
        -: 1468:	
        -: 1469:  //decrease number in supply pile
    #####: 1470:  state->supplyCount[supplyPos]--;
        -: 1471:	 
    #####: 1472:  return 0;
        -: 1473:}
        -: 1474:
function updateCoins called 0 returned 0% blocks executed 0%
    #####: 1475:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1476:{
        -: 1477:  int i;
        -: 1478:	
        -: 1479:  //reset coin count
    #####: 1480:  state->coins = 0;
        -: 1481:
        -: 1482:  //add coins for each Treasure card in player's hand
    #####: 1483:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -: 1484:    {
    #####: 1485:      if (state->hand[player][i] == copper)
branch  0 never executed
branch  1 never executed
        -: 1486:	{
    #####: 1487:	  state->coins += 1;
        -: 1488:	}
    #####: 1489:      else if (state->hand[player][i] == silver)
branch  0 never executed
branch  1 never executed
        -: 1490:	{
    #####: 1491:	  state->coins += 2;
        -: 1492:	}
    #####: 1493:      else if (state->hand[player][i] == gold)
branch  0 never executed
branch  1 never executed
        -: 1494:	{
    #####: 1495:	  state->coins += 3;
        -: 1496:	}	
        -: 1497:    }	
        -: 1498:
        -: 1499:  //add bonus
    #####: 1500:  state->coins += bonus;
        -: 1501:
    #####: 1502:  return 0;
        -: 1503:}
        -: 1504:
        -: 1505:
        -: 1506://end of dominion.c
        -: 1507:
unittest2.c:
Testing isGameOver function...
Checking the isGameOver function correct tells us if game is over
---------------------------------------------------------------------

Test: Checking isGameOver if all supply piles are not empty.
Great! isGameOver function returned that game is not over.

Test: Checking isGameOver if there are no more provinces.
Great! isGameOver function returned that game is over.

Test: Checking isGameOver if there are 1 empty supply pile (silver) test with 2 players.
Great! isGameOver function returned that game is not over.

Test: Checking isGameOver if there are 2 empty supply piles (gold, curse) test with 2 players.
Great! isGameOver function returned that game is not over.

Test: Checking isGameOver if there are 2 empty supply piles (great_hall, province) test with 2 players.
Great! isGameOver function returned that game is over.

Test: Checking isGameOver if there are 3 empty supply piles (copper, remodel, smithy) test with 2 players.
Great! isGameOver function returned that game is over.

Test: Checking isGameOver if there are 3 empty treasure supply piles test with 2 players.
Great! isGameOver function returned that game is over.

Test: Checking isGameOver if there are 3 empty supply piles test with 2 players.
Great! isGameOver function returned that game is over.

Test: Checking isGameOver if there are 3 empty supply piles (gardens, copper, province) test with 2 players.
Great! isGameOver function returned that game is over.

Test: Checking isGameOver if there are 4 empty kingdom supply piles test with 5 players.
BUG!!! isGameOver function returned that game is over.

Test: Checking isGameOver if there are 3 empty supply piles (gardens, copper, province) test with 2 players.
Great! isGameOver function returned that game is not over.

--------------------------------------------
Final Testing results of isGameOver function
-------------------------------------------
isGameOver failed to say if game was over for 1 condition(s), check above for which ones.

File 'unittest2.c'
Lines executed:84.93% of 146
Branches executed:100.00% of 24
Taken at least once:50.00% of 24
Calls executed:83.78% of 74
Creating 'unittest2.c.gcov'

        -:    0:Source:unittest2.c
        -:    0:Graph:unittest2.gcno
        -:    0:Data:unittest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* -----------------------------------------------------------------------
        -:    2: * CS362-004 Summer 2017 Assignment 3
        -:    3: * unittest2.c
        -:    4: * 
        -:    5: * Unit test for dominion function: isGameOver
        -:    6: * isGameOver checks the number of provinces or if three supply piles are 
        -:    7: * empty to determine if the game is over.
        -:    8: * it returns 1 if game is over or a 0 if game is not over
        -:    9: * http://wiki.dominionstrategy.com/index.php/Endgame
        -:   10: * game over when any of following are true:
        -:   11: * - province pile is empty
        -:   12: * - three of the supply piles run out (for 2 to 4 players, 4 piles if there are 5+ players) 
        -:   13: *    (kingdom cards, treasures cards, victory cards, curse cards all count are all supply)
        -:   14: * Used some of the provided testUpdateCoins.c
        -:   15: * -----------------------------------------------------------------------
        -:   16: * Include the following lines in the makefile:
        -:   17: *
        -:   18: * unittest2: unittest2.c dominion.o rngs.o
        -:   19: *      gcc -o unittest2 -g  unittest2.c dominion.o rngs.o $(CFLAGS)
        -:   20: */
        -:   21:
        -:   22:#include "dominion.h"
        -:   23:#include "dominion_helpers.h"
        -:   24:#include "rngs.h"
        -:   25:#include <string.h>
        -:   26:#include <assert.h>
        -:   27:#include <stdio.h>
        -:   28:#include <stdlib.h>
        -:   29:#include <time.h>
        -:   30:#include <math.h>
        -:   31:
function main called 1 returned 100% blocks executed 78%
        1:   32:int main() 
        -:   33:{
        -:   34:    int gameStatus, seed;
        1:   35:    int bugCount = 0;
        1:   36:    int numPlayer = 2;
        1:   37:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   38:               , remodel, smithy, village, baron, great_hall};
        -:   39:    struct gameState G;
        -:   40:
        1:   41:    printf("Testing isGameOver function...\n");
call    0 returned 100%
        1:   42:    printf("Checking the isGameOver function correct tells us if game is over\n");
call    0 returned 100%
        1:   43:    printf("---------------------------------------------------------------------\n\n");
call    0 returned 100%
        -:   44:
        -:   45:    // no empty test - game should not be over
        1:   46:    seed = (rand() % 100); // random seed
call    0 returned 100%
        1:   47:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   48:    initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        1:   49:    printf("Test: Checking isGameOver if all supply piles are not empty.\n");
call    0 returned 100%
        -:   50:
        1:   51:    gameStatus = isGameOver(&G);
call    0 returned 100%
        1:   52:    if(gameStatus == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   53:        printf("Great! isGameOver function returned that game is not over.\n\n");
call    0 returned 100%
        -:   54:    else{
    #####:   55:        printf("BUG!!! isGameOver function returned that game is over.\n\n");
call    0 never executed
    #####:   56:        bugCount++;
        -:   57:    }
        -:   58:    
        -:   59:    // no provinces test - game should be over
        1:   60:    seed = (rand() % 100); // random seed
call    0 returned 100%
        1:   61:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   62:    initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        1:   63:    printf("Test: Checking isGameOver if there are no more provinces.\n");
call    0 returned 100%
        1:   64:    G.supplyCount[province] = 0; // setting # of province in pile to 0
        -:   65:
        1:   66:    gameStatus = isGameOver(&G);
call    0 returned 100%
        1:   67:    if(gameStatus == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   68:        printf("Great! isGameOver function returned that game is over.\n\n");
call    0 returned 100%
        -:   69:    else{
    #####:   70:        printf("BUG!!! isGameOver function returned that game is not over.\n\n");
call    0 never executed
    #####:   71:        bugCount++;
        -:   72:    }
        -:   73:
        -:   74:    // 1 empty supply piles (not province) test with 2 players - game should not be over
        1:   75:    numPlayer = 2;
        1:   76:    seed = (rand() % 100); // random seed
call    0 returned 100%
        1:   77:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   78:    initializeGame(numPlayer, k, seed, &G); // initialize a new game    
call    0 returned 100%
        1:   79:    printf("Test: Checking isGameOver if there are 1 empty supply pile (silver) test with 2 players.\n");
call    0 returned 100%
        1:   80:    G.supplyCount[silver] = 0; // setting # of silver in pile to 0
        -:   81:
        1:   82:    gameStatus = isGameOver(&G);
call    0 returned 100%
        1:   83:    if(gameStatus == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   84:        printf("Great! isGameOver function returned that game is not over.\n\n");
call    0 returned 100%
        -:   85:    else{
    #####:   86:        printf("BUG!!! isGameOver function returned that game is over.\n\n");
call    0 never executed
    #####:   87:        bugCount++;
        -:   88:    }
        -:   89:
        -:   90:    // 2 empty supply piles (not province) test with 2 players - game should not be over
        1:   91:    numPlayer = 2;
        1:   92:    seed = (rand() % 100); // random seed
call    0 returned 100%
        1:   93:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   94:    initializeGame(numPlayer, k, seed, &G); // initialize a new game    
call    0 returned 100%
        1:   95:    printf("Test: Checking isGameOver if there are 2 empty supply piles (gold, curse) test with 2 players.\n");
call    0 returned 100%
        1:   96:    G.supplyCount[gold] = 0; // setting # of gold in pile to 0
        1:   97:    G.supplyCount[curse] = 0; // setting # of curse in pile to 0
        -:   98:
        1:   99:    gameStatus = isGameOver(&G);
call    0 returned 100%
        1:  100:    if(gameStatus == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  101:        printf("Great! isGameOver function returned that game is not over.\n\n");
call    0 returned 100%
        -:  102:    else{
    #####:  103:        printf("BUG!!! isGameOver function returned that game is over.\n\n");
call    0 never executed
    #####:  104:        bugCount++;
        -:  105:    }
        -:  106:
        -:  107:    // 2 empty supply piles (1 is province) test with 2 players - game should not be over
        1:  108:    numPlayer = 2;
        1:  109:    seed = (rand() % 100); // random seed
call    0 returned 100%
        1:  110:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:  111:    initializeGame(numPlayer, k, seed, &G); // initialize a new game    
call    0 returned 100%
        1:  112:    printf("Test: Checking isGameOver if there are 2 empty supply piles (great_hall, province) test with 2 players.\n");
call    0 returned 100%
        1:  113:    G.supplyCount[great_hall] = 0; // setting # of great_hall in pile to 0
        1:  114:    G.supplyCount[province] = 0; // setting # of province in pile to 0
        -:  115:
        1:  116:    gameStatus = isGameOver(&G);
call    0 returned 100%
        1:  117:    if(gameStatus == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  118:        printf("Great! isGameOver function returned that game is over.\n\n");
call    0 returned 100%
        -:  119:    else{
    #####:  120:        printf("BUG!!! isGameOver function returned that game is not over.\n\n");
call    0 never executed
    #####:  121:        bugCount++;
        -:  122:    }
        -:  123:
        -:  124:    // 1 empty treasure supply pile and 2 empty kingdom supply piles test with 2 players - game should be over
        1:  125:    numPlayer = 2;
        1:  126:    seed = (rand() % 100); // random seed
call    0 returned 100%
        1:  127:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:  128:    initializeGame(numPlayer, k, seed, &G); // initialize a new game    
call    0 returned 100%
        1:  129:    printf("Test: Checking isGameOver if there are 3 empty supply piles (copper, remodel, smithy) test with 2 players.\n");
call    0 returned 100%
        1:  130:    G.supplyCount[copper] = 0; // setting # of copper in pile to 0
        1:  131:    G.supplyCount[remodel] = 0; // setting # of remodel in pile to 0
        1:  132:    G.supplyCount[smithy] = 0; // setting # of smithy in pile to 0
        -:  133:
        1:  134:    gameStatus = isGameOver(&G);
call    0 returned 100%
        1:  135:    if(gameStatus == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  136:        printf("Great! isGameOver function returned that game is over.\n\n");
call    0 returned 100%
        -:  137:    else{
    #####:  138:        printf("BUG!!! isGameOver function returned that game is not over.\n\n");
call    0 never executed
    #####:  139:        bugCount++;
        -:  140:    }
        -:  141:
        -:  142:    // 3 empty treasure supply piles test with 2 players - game should be over
        1:  143:    numPlayer = 2;
        1:  144:    seed = (rand() % 100); // random seed
call    0 returned 100%
        1:  145:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:  146:    initializeGame(numPlayer, k, seed, &G); // initialize a new game    
call    0 returned 100%
        1:  147:    printf("Test: Checking isGameOver if there are 3 empty treasure supply piles test with 2 players.\n");
call    0 returned 100%
        1:  148:    G.supplyCount[copper] = 0; // setting # of copper in pile to 0
        1:  149:    G.supplyCount[silver] = 0; // setting # of silver in pile to 0
        1:  150:    G.supplyCount[gold] = 0; // setting # of gold in pile to 0
        -:  151:
        1:  152:    gameStatus = isGameOver(&G);
call    0 returned 100%
        1:  153:    if(gameStatus == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  154:        printf("Great! isGameOver function returned that game is over.\n\n");
call    0 returned 100%
        -:  155:    else{
    #####:  156:        printf("BUG!!! isGameOver function returned that game is not over.\n\n");
call    0 never executed
    #####:  157:        bugCount++;
        -:  158:    }
        -:  159:
        -:  160:    // 3 empty kingdom supply piles test with 2 players - game should be over
        1:  161:    numPlayer = 2;
        1:  162:    seed = (rand() % 100); // random seed
call    0 returned 100%
        1:  163:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:  164:    initializeGame(numPlayer, k, seed, &G); // initialize a new game    
call    0 returned 100%
        1:  165:    printf("Test: Checking isGameOver if there are 3 empty supply piles test with 2 players.\n");
call    0 returned 100%
        1:  166:    G.supplyCount[adventurer] = 0; // setting # of adventurer in pile to 0
        1:  167:    G.supplyCount[council_room] = 0; // setting # of council_room in pile to 0
        1:  168:    G.supplyCount[feast] = 0; // setting # of feast in pile to 0
        -:  169:
        1:  170:    gameStatus = isGameOver(&G);
call    0 returned 100%
        1:  171:    if(gameStatus == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  172:        printf("Great! isGameOver function returned that game is over.\n\n");
call    0 returned 100%
        -:  173:    else{
    #####:  174:        printf("BUG!!! isGameOver function returned that game is not over.\n\n");
call    0 never executed
    #####:  175:        bugCount++;
        -:  176:    }
        -:  177:
        -:  178:    // 3 empty supply piles (1 is province) test with 2 players - game should not be over
        1:  179:    numPlayer = 2;
        1:  180:    seed = (rand() % 100); // random seed
call    0 returned 100%
        1:  181:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:  182:    initializeGame(numPlayer, k, seed, &G); // initialize a new game    
call    0 returned 100%
        1:  183:    printf("Test: Checking isGameOver if there are 3 empty supply piles (gardens, copper, province) test with 2 players.\n");
call    0 returned 100%
        1:  184:    G.supplyCount[gardens] = 0; // setting # of great_hall in pile to 0
        1:  185:    G.supplyCount[copper] = 0; // setting # of great_hall in pile to 0 
        1:  186:    G.supplyCount[province] = 0; // setting # of province in pile to 0
        -:  187:
        1:  188:    gameStatus = isGameOver(&G);
call    0 returned 100%
        1:  189:    if(gameStatus == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  190:        printf("Great! isGameOver function returned that game is over.\n\n");
call    0 returned 100%
        -:  191:    else{
    #####:  192:        printf("BUG!!! isGameOver function returned that game is not over.\n\n");
call    0 never executed
    #####:  193:        bugCount++;
        -:  194:    }
        -:  195:
        -:  196:    // 4 empty kingdom supply piles test with 5 players - game should not be over
        1:  197:    numPlayer = 5;
        1:  198:    seed = (rand() % 100); // random seed
call    0 returned 100%
        1:  199:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:  200:    initializeGame(numPlayer, k, seed, &G); // initialize a new game   
call    0 returned 100%
        1:  201:    printf("Test: Checking isGameOver if there are 4 empty kingdom supply piles test with 5 players.\n");
call    0 returned 100%
        1:  202:    G.supplyCount[gardens] = 0; // setting # of adventurer in pile to 0
        1:  203:    G.supplyCount[mine] = 0; // setting # of council_room in pile to 0
        1:  204:    G.supplyCount[remodel] = 0; // setting # of feast in pile to 0
        -:  205:
        1:  206:    gameStatus = isGameOver(&G);
call    0 returned 100%
        1:  207:    if(gameStatus == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  208:        printf("Great! isGameOver function returned that game is not over.\n\n");
call    0 never executed
        -:  209:    else{
        1:  210:        printf("BUG!!! isGameOver function returned that game is over.\n\n");
call    0 returned 100%
        1:  211:        bugCount++;
        -:  212:    }
        -:  213:
        -:  214:    // testing 3 empty kingdom cards piles that weren't part of 10 that we're using
        1:  215:    numPlayer = 2;
        1:  216:    seed = (rand() % 100); // random seed
call    0 returned 100%
        1:  217:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:  218:    initializeGame(numPlayer, k, seed, &G); // initialize a new game    
call    0 returned 100%
        1:  219:    printf("Test: Checking isGameOver if there are 3 empty supply piles (gardens, copper, province) test with 2 players.\n");
call    0 returned 100%
        1:  220:    G.supplyCount[minion] = 0; // setting # of minion in pile to 0
        1:  221:    G.supplyCount[sea_hag] = 0; // setting # of sea_hag in pile to 0 
        1:  222:    G.supplyCount[cutpurse] = 0; // setting # of cutpurse in pile to 0
        -:  223:
        1:  224:    gameStatus = isGameOver(&G);
call    0 returned 100%
        1:  225:    if(gameStatus == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  226:        printf("Great! isGameOver function returned that game is not over.\n\n");
call    0 returned 100%
        -:  227:    else{
    #####:  228:        printf("BUG!!! isGameOver function returned that game is over.\n\n");
call    0 never executed
    #####:  229:        bugCount++;
        -:  230:    }
        -:  231:
        -:  232:
        -:  233:    // output the test results overall
        1:  234:    printf("--------------------------------------------\n");
call    0 returned 100%
        1:  235:    printf("Final Testing results of isGameOver function\n");
call    0 returned 100%
        1:  236:    printf("-------------------------------------------\n");
call    0 returned 100%
        1:  237:    if(bugCount == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  238:        printf("All tests passed for the isGameOver function!\n\n");
call    0 never executed
        -:  239:    else
        1:  240:        printf("isGameOver failed to say if game was over for %d condition(s), check above for which ones.\n\n", bugCount);
call    0 returned 100%
        -:  241:    
        1:  242:    return 0;
        -:  243:}
File 'dominion.c'
Lines executed:22.91% of 563
Branches executed:24.46% of 417
Taken at least once:21.58% of 417
Calls executed:7.00% of 100
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:2
        -:    0:Programs:2
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 300 returned 100% blocks executed 83%
      300:    8:int compare(const void* a, const void* b) {
      300:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:    return 1;
      300:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
       80:   12:    return -1;
      220:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 11 returned 100% blocks executed 89%
       11:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
       11:   44:  SelectStream(1);
call    0 returned 100%
       11:   45:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:  
        -:   47:  //check number of players
       11:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:    {
        1:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
       10:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
      110:   57:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:    {
     1100:   59:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:        {
     1000:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
       10:   73:  if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   74:    {
       10:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
    #####:   77:  else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
       10:   87:  if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:    {
       10:   89:      state->supplyCount[estate] = 8;
       10:   90:      state->supplyCount[duchy] = 8;
       10:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
       10:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
       10:  102:  state->supplyCount[silver] = 40;
       10:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
      210:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:    {
     1650:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:	{
     1550:  110:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
      100:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
        -:  114:		{
       40:  115:		  if (numPlayers == 2){ 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       20:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
       80:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
      100:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
     1450:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
       30:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:    {
       20:  140:      state->deckCount[i] = 0;
       80:  141:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:	{
       60:  143:	  state->deck[i][j] = estate;
       60:  144:	  state->deckCount[i]++;
        -:  145:	}
      160:  146:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:	{
      140:  148:	  state->deck[i][j] = copper;
      140:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
       30:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:    {
       20:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
       30:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
       20:  166:      state->handCount[i] = 0;
       20:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
      280:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:    {
      270:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
       10:  182:  state->outpostPlayed = 0;
       10:  183:  state->phase = 0;
       10:  184:  state->numActions = 1;
       10:  185:  state->numBuys = 1;
       10:  186:  state->playedCardCount = 0;
       10:  187:  state->whoseTurn = 0;
       10:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       60:  192:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       50:  193:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:  }
        -:  195:
       10:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
       10:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 20 returned 100% blocks executed 94%
       20:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
       20:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
       20:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  210:    return -1;
       20:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      240:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
      200:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
      200:  216:    newDeck[newDeckPos] = state->deck[player][card];
      200:  217:    newDeckPos++;
      732:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 73%
branch  1 taken 27% (fallthrough)
      532:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
      200:  221:    state->deckCount[player]--;
        -:  222:  }
      220:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
      200:  224:    state->deck[player][i] = newDeck[i];
      200:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
       20:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  320:int supplyCount(int card, struct gameState *state) {
    #####:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 0 returned 0% blocks executed 0%
    #####:  346:int whoseTurn(struct gameState *state) {
    #####:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 11 returned 100% blocks executed 100%
       11:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
       11:  395:  if (state->supplyCount[province] == 0)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
        -:  396:    {
        3:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
        8:  401:  j = 0;
      208:  402:  for (i = 0; i < 25; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  403:    {
      200:  404:      if (state->supplyCount[i] == 0)
branch  0 taken 9% (fallthrough)
branch  1 taken 92%
        -:  405:	{
       17:  406:	  j++;
        -:  407:	}
        -:  408:    }
        8:  409:  if ( j >= 3)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  410:    {
        4:  411:      return 1;
        -:  412:    }
        -:  413:
        4:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 50 returned 100% blocks executed 38%
       50:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
       50:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
       50:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
       50:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
       50:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       50:  576:    state->deckCount[player]--;
       50:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
       50:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 27 returned 100% blocks executed 97%
       27:  583:int getCost(int cardNumber)
        -:  584:{
       27:  585:  switch( cardNumber ) 
branch  0 taken 4%
branch  1 taken 4%
branch  2 taken 4%
branch  3 taken 4%
branch  4 taken 4%
branch  5 taken 4%
branch  6 taken 4%
branch  7 taken 4%
branch  8 taken 4%
branch  9 taken 4%
branch 10 taken 4%
branch 11 taken 4%
branch 12 taken 4%
branch 13 taken 4%
branch 14 taken 4%
branch 15 taken 4%
branch 16 taken 4%
branch 17 taken 4%
branch 18 taken 4%
branch 19 taken 4%
branch 20 taken 4%
branch 21 taken 4%
branch 22 taken 4%
branch 23 taken 4%
branch 24 taken 4%
branch 25 taken 4%
branch 26 taken 4%
branch 27 taken 0%
        -:  586:    {
        -:  587:    case curse:
        1:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        1:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        1:  608:      return 4;
        -:  609:    case mine:
        1:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        1:  614:      return 4;
        -:  615:    case village:
        1:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        1:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        1:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        1:  630:      return 4;
        -:  631:    case embargo: 
        1:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        1:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:// Assignment 2 - refactor card #1: Adventurer
function adventurer_func called 0 returned 0% blocks executed 0%
    #####:  647:int adventurer_func(struct gameState *state)
        -:  648:{
        -:  649:	int cardDrawn;
    #####:  650:	int currentPlayer = whoseTurn(state);	
call    0 never executed
    #####:  651:	int drawntreasure = 0;
        -:  652:	int temphand[MAX_HAND];// moved above the if statement
    #####:  653:	int z = 0;// this is the counter for the temp hand
        -:  654:    
    #####:  655:	while(drawntreasure <= 2) // BUG added!! - Changed to < to <= that what it could end up drawing extra treasure.
branch  0 never executed
branch  1 never executed
        -:  656:	{
        -:  657:		//if the deck is empty we need to shuffle discard and add to deck
    #####:  658:		if (state->deckCount[currentPlayer] <1)
branch  0 never executed
branch  1 never executed
    #####:  659:			shuffle(currentPlayer, state);
call    0 never executed
        -:  660:		
    #####:  661:		drawCard(currentPlayer, state);
call    0 never executed
        -:  662:		
        -:  663:			//top card of hand is most recently drawn card.
    #####:  664:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  665:	
    #####:  666:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  667:				drawntreasure++;
        -:  668:			else
        -:  669:			{
    #####:  670:				temphand[z] = cardDrawn;
        -:  671:				
        -:  672:				//this should just remove the top card (the most recently drawn one).
    #####:  673:				state->handCount[currentPlayer]--; 
    #####:  674:				z++;
        -:  675:			}
        -:  676:		}
        -:  677:      
    #####:  678:		while(z - 1 >= 0)
branch  0 never executed
branch  1 never executed
        -:  679:		{
        -:  680:			// discard all cards in play that have been drawn
    #####:  681:			state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; 
    #####:  682:			z = z - 1;
        -:  683:		}
        -:  684:		
    #####:  685:		return 0;
        -:  686:}
        -:  687:
        -:  688:// Assignment 2 - refactor card #2: Council Room
function council_room_func called 0 returned 0% blocks executed 0%
    #####:  689:int council_room_func(int handPos, struct gameState *state)
        -:  690:{
        -:  691:	int i;
    #####:  692:	int currentPlayer = whoseTurn(state);	
call    0 never executed
        -:  693:	
        -:  694:	//+4 Cards
    #####:  695:	for (i = 1; i < 4; i++) // BUG added!!! = changed i=0 to i=1, which will result in 1 less card drawn.
branch  0 never executed
branch  1 never executed
    #####:  696:		drawCard(currentPlayer, state);
call    0 never executed
        -:  697:
        -:  698:	//+1 Buy
    #####:  699:	state->numBuys++;
        -:  700:	
        -:  701:	//Each other player draws a card
    #####:  702:	for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
    #####:  703:		if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
    #####:  704:			drawCard(i, state);
call    0 never executed
        -:  705:
        -:  706:	//put played card in played card pile
    #####:  707:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  708:
    #####:  709:	return 0;
        -:  710:}
        -:  711:
        -:  712:
        -:  713:// Assignment 2 - refactor card #3: Remodel
function remodel_func called 0 returned 0% blocks executed 0%
    #####:  714:int remodel_func(int choice1, int choice2, int handPos, struct gameState *state)
        -:  715:{
        -:  716:	int i;
        -:  717:	int j;
    #####:  718:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  719:    
    #####:  720:	j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  721:
    #####:  722:	if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  723:		return -1;
        -:  724:
    #####:  725:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  726:
        -:  727:	//discard card from hand
    #####:  728:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  729:
        -:  730:	//discard trashed card
    #####:  731:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  732:	{
    #####:  733:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  734:	    {
    #####:  735:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  736:			break;
        -:  737:	    }
        -:  738:	}
        -:  739:	
    #####:  740:	return 0;
        -:  741:}
        -:  742:
        -:  743:// Assignment 2 - refactor card #4: Smithy
function smithy_func called 0 returned 0% blocks executed 0%
    #####:  744:int smithy_func(int handPos, struct gameState *state)
        -:  745:{
        -:  746:	int i;
    #####:  747:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  748:	
        -:  749:	//+3 Cards
    #####:  750:	for (i = 0; i <= 3; i++) // BUG added!!! = changed < to <=, which will result in 1 more card drawn.
branch  0 never executed
branch  1 never executed
    #####:  751:		drawCard(currentPlayer, state);
call    0 never executed
        -:  752:
        -:  753:	//discard card from hand
    #####:  754:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  755:	
    #####:  756:	return 0;
        -:  757:}
        -:  758:
        -:  759:// Assignment 2 - refactor card #5: Village
function village_func called 0 returned 0% blocks executed 0%
    #####:  760:int village_func(int handPos, struct gameState *state)
        -:  761:{
    #####:  762:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  763:	
        -:  764:	//+1 Card
    #####:  765:	drawCard(currentPlayer, state);
call    0 never executed
        -:  766:			
        -:  767:	//+2 Actions
    #####:  768:	state->numActions = state->numActions + 22; // BUG added!!! = changed 2 to 22, which will result in +22 actions instead of just 2.
        -:  769:			
        -:  770:	//discard played card from hand
    #####:  771:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  772:
    #####:  773:	return 0;
        -:  774:}
        -:  775:
        -:  776:// cardEffect - for assignment 2 - I refactored 5 of these cards (adventurer, 
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  777:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  778:{
        -:  779:  int i;
        -:  780:  int j;
        -:  781:  int k;
        -:  782:  int x;
        -:  783:  int index;
    #####:  784:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  785:  int nextPlayer = currentPlayer + 1;
        -:  786:
    #####:  787:  int tributeRevealedCards[2] = {-1, -1};
        -:  788:  int temphand[MAX_HAND];// moved above the if statement
        -:  789:
    #####:  790:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  791:    nextPlayer = 0;
        -:  792:  }
        -:  793:  
        -:  794:  /* these variables are no longer needed after refactoring
        -:  795:  
        -:  796:    int drawntreasure=0;
        -:  797:	int cardDrawn;
        -:  798:	int z = 0;// this is the counter for the temp hand
        -:  799:	*/
        -:  800:	
        -:  801:  //uses switch to select card and perform actions
    #####:  802:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  803:    {
        -:  804:    case adventurer:
        -:  805:	
    #####:  806:		adventurer_func(state);
call    0 never executed
        -:  807:		
        -:  808:		/* commented out code that is no longer needed due to refactoring
        -:  809:		while(drawntreasure<2)
        -:  810:		{
        -:  811:			//if the deck is empty we need to shuffle discard and add to deck
        -:  812:			if (state->deckCount[currentPlayer] <1)
        -:  813:				shuffle(currentPlayer, state);
        -:  814:		
        -:  815:			drawCard(currentPlayer, state);
        -:  816:		
        -:  817:			//top card of hand is most recently drawn card.
        -:  818:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  819:	
        -:  820:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:  821:				drawntreasure++;
        -:  822:			else
        -:  823:			{
        -:  824:				temphand[z]=cardDrawn;
        -:  825:				
        -:  826:				//this should just remove the top card (the most recently drawn one).
        -:  827:				state->handCount[currentPlayer]--; 
        -:  828:				z++;
        -:  829:			}
        -:  830:		}
        -:  831:      
        -:  832:		while(z-1>=0)
        -:  833:		{
        -:  834:			// discard all cards in play that have been drawn
        -:  835:			state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; 
        -:  836:			z=z-1;
        -:  837:		}
        -:  838:		return 0;
        -:  839:		*/
        -:  840:	
        -:  841:    case council_room:
        -:  842:		
    #####:  843:		council_room_func(handPos, state);
call    0 never executed
        -:  844:		
        -:  845:		/* commented out code that is no longer needed due to refactoring
        -:  846:		
        -:  847:		//+4 Cards
        -:  848:		  for (i = 0; i < 4; i++)
        -:  849:		{
        -:  850:		  drawCard(currentPlayer, state);
        -:  851:		}
        -:  852:				
        -:  853:		  //+1 Buy
        -:  854:		  state->numBuys++;
        -:  855:				
        -:  856:		  //Each other player draws a card
        -:  857:		  for (i = 0; i < state->numPlayers; i++)
        -:  858:		{
        -:  859:		  if ( i != currentPlayer )
        -:  860:			{
        -:  861:			  drawCard(i, state);
        -:  862:			}
        -:  863:		}
        -:  864:				
        -:  865:		  //put played card in played card pile
        -:  866:		  discardCard(handPos, currentPlayer, state, 0);
        -:  867:				
        -:  868:		  return 0;
        -:  869:		*/
        -:  870:		
        -:  871:    case feast:
        -:  872:      //gain card with cost up to 5
        -:  873:      //Backup hand
    #####:  874:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  875:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  876:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  877:      }
        -:  878:      //Backup hand
        -:  879:
        -:  880:      //Update Coins for Buy
    #####:  881:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  882:      x = 1;//Condition to loop on
    #####:  883:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  884:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  885:	  if (DEBUG)
        -:  886:	    printf("None of that card left, sorry!\n");
        -:  887:
        -:  888:	  if (DEBUG){
        -:  889:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  890:	  }
        -:  891:	}
    #####:  892:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  893:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  894:
        -:  895:	  if (DEBUG){
        -:  896:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  897:	  }
        -:  898:	}
        -:  899:	else{
        -:  900:
        -:  901:	  if (DEBUG){
        -:  902:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  903:	  }
        -:  904:
    #####:  905:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  906:	  x = 0;//No more buying cards
        -:  907:
        -:  908:	  if (DEBUG){
        -:  909:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  910:	  }
        -:  911:
        -:  912:	}
        -:  913:      }     
        -:  914:
        -:  915:      //Reset Hand
    #####:  916:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  917:	state->hand[currentPlayer][i] = temphand[i];
    #####:  918:	temphand[i] = -1;
        -:  919:      }
        -:  920:      //Reset Hand
        -:  921:      			
    #####:  922:      return 0;
        -:  923:			
        -:  924:    case gardens:
    #####:  925:      return -1;
        -:  926:			
        -:  927:    case mine:
    #####:  928:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  929:
    #####:  930:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  931:	{
    #####:  932:	  return -1;
        -:  933:	}
        -:  934:		
    #####:  935:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  936:	{
    #####:  937:	  return -1;
        -:  938:	}
        -:  939:
    #####:  940:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  941:	{
    #####:  942:	  return -1;
        -:  943:	}
        -:  944:
    #####:  945:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  946:
        -:  947:      //discard card from hand
    #####:  948:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  949:
        -:  950:      //discard trashed card
    #####:  951:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  952:	{
    #####:  953:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  954:	    {
    #####:  955:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  956:	      break;
        -:  957:	    }
        -:  958:	}
        -:  959:			
    #####:  960:      return 0;
        -:  961:			
        -:  962:    case remodel:
        -:  963:	
    #####:  964:		remodel_func(choice1, choice2, handPos, state);
call    0 never executed
        -:  965:		
        -:  966:		/* commented out code that is no longer needed due to refactoring
        -:  967:			
        -:  968:		  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  969:
        -:  970:		  if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  971:		{
        -:  972:		  return -1;
        -:  973:		}
        -:  974:
        -:  975:		  gainCard(choice2, state, 0, currentPlayer);
        -:  976:
        -:  977:		  //discard card from hand
        -:  978:		  discardCard(handPos, currentPlayer, state, 0);
        -:  979:
        -:  980:		  //discard trashed card
        -:  981:		  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  982:		{
        -:  983:		  if (state->hand[currentPlayer][i] == j)
        -:  984:			{
        -:  985:			  discardCard(i, currentPlayer, state, 0);			
        -:  986:			  break;
        -:  987:			}
        -:  988:		}
        -:  989:
        -:  990:		  return 0;
        -:  991:		*/
        -:  992:		
        -:  993:    case smithy:
        -:  994:	
    #####:  995:		smithy_func(handPos, state);
call    0 never executed
        -:  996:		
        -:  997:		/* commented out code that is no longer needed due to refactoring
        -:  998:			
        -:  999:		  //+3 Cards
        -: 1000:		  for (i = 0; i < 3; i++)
        -: 1001:		{
        -: 1002:		  drawCard(currentPlayer, state);
        -: 1003:		}
        -: 1004:				
        -: 1005:		  //discard card from hand
        -: 1006:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1007:		  return 0;
        -: 1008:		*/
        -: 1009:			
        -: 1010:    case village:
        -: 1011:	
    #####: 1012:		village_func(handPos, state);
call    0 never executed
        -: 1013:		
        -: 1014:		/* commented out code that is no longer needed due to refactoring
        -: 1015:			
        -: 1016:		  //+1 Card
        -: 1017:		  drawCard(currentPlayer, state);
        -: 1018:				
        -: 1019:		  //+2 Actions
        -: 1020:		  state->numActions = state->numActions + 2;
        -: 1021:				
        -: 1022:		  //discard played card from hand
        -: 1023:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1024:		  return 0;
        -: 1025:		*/
        -: 1026:		
        -: 1027:    case baron:
    #####: 1028:      state->numBuys++;//Increase buys by 1!
    #####: 1029:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####: 1030:	int p = 0;//Iterator for hand!
    #####: 1031:	int card_not_discarded = 1;//Flag for discard set!
    #####: 1032:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####: 1033:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####: 1034:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####: 1035:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1036:	    state->discardCount[currentPlayer]++;
    #####: 1037:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####: 1038:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -: 1039:	    }
    #####: 1040:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1041:	    state->handCount[currentPlayer]--;
    #####: 1042:	    card_not_discarded = 0;//Exit the loop
        -: 1043:	  }
    #####: 1044:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -: 1045:	    if(DEBUG) {
        -: 1046:	      printf("No estate cards in your hand, invalid choice\n");
        -: 1047:	      printf("Must gain an estate if there are any\n");
        -: 1048:	    }
    #####: 1049:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1050:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####: 1051:	      state->supplyCount[estate]--;//Decrement estates
    #####: 1052:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1053:		isGameOver(state);
call    0 never executed
        -: 1054:	      }
        -: 1055:	    }
    #####: 1056:	    card_not_discarded = 0;//Exit the loop
        -: 1057:	  }
        -: 1058:			    
        -: 1059:	  else{
    #####: 1060:	    p++;//Next card
        -: 1061:	  }
        -: 1062:	}
        -: 1063:      }
        -: 1064:			    
        -: 1065:      else{
    #####: 1066:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1067:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####: 1068:	  state->supplyCount[estate]--;//Decrement Estates
    #####: 1069:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1070:	    isGameOver(state);
call    0 never executed
        -: 1071:	  }
        -: 1072:	}
        -: 1073:      }
        -: 1074:	    
        -: 1075:      
    #####: 1076:      return 0;
        -: 1077:		
        -: 1078:    case great_hall:
        -: 1079:      //+1 Card
    #####: 1080:      drawCard(currentPlayer, state);
call    0 never executed
        -: 1081:			
        -: 1082:      //+1 Actions
    #####: 1083:      state->numActions++;
        -: 1084:			
        -: 1085:      //discard card from hand
    #####: 1086:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1087:      return 0;
        -: 1088:		
        -: 1089:    case minion:
        -: 1090:      //+1 action
    #####: 1091:      state->numActions++;
        -: 1092:			
        -: 1093:      //discard card from hand
    #####: 1094:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1095:			
    #####: 1096:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -: 1097:	{
    #####: 1098:	  state->coins = state->coins + 2;
        -: 1099:	}
        -: 1100:			
    #####: 1101:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -: 1102:	{
        -: 1103:	  //discard hand
    #####: 1104:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1105:	    {
    #####: 1106:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1107:	    }
        -: 1108:				
        -: 1109:	  //draw 4
    #####: 1110:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1111:	    {
    #####: 1112:	      drawCard(currentPlayer, state);
call    0 never executed
        -: 1113:	    }
        -: 1114:				
        -: 1115:	  //other players discard hand and redraw if hand size > 4
    #####: 1116:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1117:	    {
    #####: 1118:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1119:		{
    #####: 1120:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1121:		    {
        -: 1122:		      //discard hand
    #####: 1123:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1124:			{
    #####: 1125:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1126:			}
        -: 1127:							
        -: 1128:		      //draw 4
    #####: 1129:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1130:			{
    #####: 1131:			  drawCard(i, state);
call    0 never executed
        -: 1132:			}
        -: 1133:		    }
        -: 1134:		}
        -: 1135:	    }
        -: 1136:				
        -: 1137:	}
    #####: 1138:      return 0;
        -: 1139:		
        -: 1140:    case steward:
    #####: 1141:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1142:	{
        -: 1143:	  //+2 cards
    #####: 1144:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1145:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1146:	}
    #####: 1147:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1148:	{
        -: 1149:	  //+2 coins
    #####: 1150:	  state->coins = state->coins + 2;
        -: 1151:	}
        -: 1152:      else
        -: 1153:	{
        -: 1154:	  //trash 2 cards in hand
    #####: 1155:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1156:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1157:	}
        -: 1158:			
        -: 1159:      //discard card from hand
    #####: 1160:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1161:      return 0;
        -: 1162:		
        -: 1163:    case tribute:
    #####: 1164:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1165:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1166:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1167:	  state->deckCount[nextPlayer]--;
        -: 1168:	}
    #####: 1169:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1170:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1171:	  state->discardCount[nextPlayer]--;
        -: 1172:	}
        -: 1173:	else{
        -: 1174:	  //No Card to Reveal
        -: 1175:	  if (DEBUG){
        -: 1176:	    printf("No cards to reveal\n");
        -: 1177:	  }
        -: 1178:	}
        -: 1179:      }
        -: 1180:	    
        -: 1181:      else{
    #####: 1182:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1183:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1184:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1185:	    state->deckCount[nextPlayer]++;
    #####: 1186:	    state->discard[nextPlayer][i] = -1;
    #####: 1187:	    state->discardCount[nextPlayer]--;
        -: 1188:	  }
        -: 1189:			    
    #####: 1190:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1191:	} 
    #####: 1192:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1193:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1194:	state->deckCount[nextPlayer]--;
    #####: 1195:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1196:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1197:	state->deckCount[nextPlayer]--;
        -: 1198:      }    
        -: 1199:		       
    #####: 1200:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1201:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1202:	state->playedCardCount++;
    #####: 1203:	tributeRevealedCards[1] = -1;
        -: 1204:      }
        -: 1205:
    #####: 1206:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1207:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1208:	  state->coins += 2;
        -: 1209:	}
        -: 1210:		    
    #####: 1211:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1212:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1213:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1214:	}
        -: 1215:	else{//Action Card
    #####: 1216:	  state->numActions = state->numActions + 2;
        -: 1217:	}
        -: 1218:      }
        -: 1219:	    
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case ambassador:
    #####: 1223:      j = 0;		//used to check if player has enough cards to discard
        -: 1224:
    #####: 1225:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1226:	{
    #####: 1227:	  return -1;				
        -: 1228:	}
        -: 1229:
    #####: 1230:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1231:	{
    #####: 1232:	  return -1;
        -: 1233:	}
        -: 1234:
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1238:	    {
    #####: 1239:	      j++;
        -: 1240:	    }
        -: 1241:	}
    #####: 1242:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1243:	{
    #####: 1244:	  return -1;				
        -: 1245:	}
        -: 1246:
        -: 1247:      if (DEBUG) 
        -: 1248:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1249:
        -: 1250:      //increase supply count for choosen card by amount being discarded
    #####: 1251:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1252:			
        -: 1253:      //each other player gains a copy of revealed card
    #####: 1254:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:	{
    #####: 1256:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1257:	    {
    #####: 1258:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1259:	    }
        -: 1260:	}
        -: 1261:
        -: 1262:      //discard played card from hand
    #####: 1263:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1264:
        -: 1265:      //trash copies of cards returned to supply
    #####: 1266:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1267:	{
    #####: 1268:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1269:	    {
    #####: 1270:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1271:		{
    #####: 1272:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1273:		  break;
        -: 1274:		}
        -: 1275:	    }
        -: 1276:	}			
        -: 1277:
    #####: 1278:      return 0;
        -: 1279:		
        -: 1280:    case cutpurse:
        -: 1281:
    #####: 1282:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1283:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1284:	{
    #####: 1285:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1286:	    {
    #####: 1287:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1288:		{
    #####: 1289:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1290:		    {
    #####: 1291:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1292:		      break;
        -: 1293:		    }
    #####: 1294:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1295:		    {
    #####: 1296:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1297:			{
        -: 1298:			  if (DEBUG)
        -: 1299:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1300:			}	
    #####: 1301:		      break;
        -: 1302:		    }		
        -: 1303:		}
        -: 1304:					
        -: 1305:	    }
        -: 1306:				
        -: 1307:	}				
        -: 1308:
        -: 1309:      //discard played card from hand
    #####: 1310:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1311:
    #####: 1312:      return 0;
        -: 1313:
        -: 1314:		
        -: 1315:    case embargo: 
        -: 1316:      //+2 Coins
    #####: 1317:      state->coins = state->coins + 2;
        -: 1318:			
        -: 1319:      //see if selected pile is in play
    #####: 1320:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1321:	{
    #####: 1322:	  return -1;
        -: 1323:	}
        -: 1324:			
        -: 1325:      //add embargo token to selected supply pile
    #####: 1326:      state->embargoTokens[choice1]++;
        -: 1327:			
        -: 1328:      //trash card
    #####: 1329:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1330:      return 0;
        -: 1331:		
        -: 1332:    case outpost:
        -: 1333:      //set outpost flag
    #####: 1334:      state->outpostPlayed++;
        -: 1335:			
        -: 1336:      //discard card
    #####: 1337:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1338:      return 0;
        -: 1339:		
        -: 1340:    case salvager:
        -: 1341:      //+1 buy
    #####: 1342:      state->numBuys++;
        -: 1343:			
    #####: 1344:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1345:	{
        -: 1346:	  //gain coins equal to trashed card
    #####: 1347:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1348:	  //trash card
    #####: 1349:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1350:	}
        -: 1351:			
        -: 1352:      //discard card
    #####: 1353:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1354:      return 0;
        -: 1355:		
        -: 1356:    case sea_hag:
    #####: 1357:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1358:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1359:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1360:	  state->discardCount[i]++;
    #####: 1361:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1362:	}
        -: 1363:      }
    #####: 1364:      return 0;
        -: 1365:		
        -: 1366:    case treasure_map:
        -: 1367:      //search hand for another treasure_map
    #####: 1368:      index = -1;
    #####: 1369:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1370:	{
    #####: 1371:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1372:	    {
    #####: 1373:	      index = i;
    #####: 1374:	      break;
        -: 1375:	    }
        -: 1376:	}
    #####: 1377:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1378:	{
        -: 1379:	  //trash both treasure cards
    #####: 1380:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1381:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1382:
        -: 1383:	  //gain 4 Gold cards
    #####: 1384:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1385:	    {
    #####: 1386:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1387:	    }
        -: 1388:				
        -: 1389:	  //return success
    #####: 1390:	  return 1;
        -: 1391:	}
        -: 1392:			
        -: 1393:      //no second treasure_map found in hand
    #####: 1394:      return -1;
        -: 1395:    }
        -: 1396:	
    #####: 1397:  return -1;
        -: 1398:}
        -: 1399:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1400:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1401:{
        -: 1402:	
        -: 1403:  //if card is not trashed, added to Played pile 
    #####: 1404:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1405:    {
        -: 1406:      //add card to played pile
    #####: 1407:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1408:      state->playedCardCount++;
        -: 1409:    }
        -: 1410:	
        -: 1411:  //set played card to -1
    #####: 1412:  state->hand[currentPlayer][handPos] = -1;
        -: 1413:	
        -: 1414:  //remove card from player's hand
    #####: 1415:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1416:    {
        -: 1417:      //reduce number of cards in hand
    #####: 1418:      state->handCount[currentPlayer]--;
        -: 1419:    }
    #####: 1420:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1421:    {
        -: 1422:      //reduce number of cards in hand
    #####: 1423:      state->handCount[currentPlayer]--;
        -: 1424:    }
        -: 1425:  else 	
        -: 1426:    {
        -: 1427:      //replace discarded card with last card in hand
    #####: 1428:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1429:      //set last card to -1
    #####: 1430:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1431:      //reduce number of cards in hand
    #####: 1432:      state->handCount[currentPlayer]--;
        -: 1433:    }
        -: 1434:	
    #####: 1435:  return 0;
        -: 1436:}
        -: 1437:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1438:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1439:{
        -: 1440:  //Note: supplyPos is enum of choosen card
        -: 1441:	
        -: 1442:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1443:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1444:    {
    #####: 1445:      return -1;
        -: 1446:    }
        -: 1447:	
        -: 1448:  //added card for [whoseTurn] current player:
        -: 1449:  // toFlag = 0 : add to discard
        -: 1450:  // toFlag = 1 : add to deck
        -: 1451:  // toFlag = 2 : add to hand
        -: 1452:
    #####: 1453:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1454:    {
    #####: 1455:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1456:      state->deckCount[player]++;
        -: 1457:    }
    #####: 1458:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1459:    {
    #####: 1460:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1461:      state->handCount[player]++;
        -: 1462:    }
        -: 1463:  else
        -: 1464:    {
    #####: 1465:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1466:      state->discardCount[player]++;
        -: 1467:    }
        -: 1468:	
        -: 1469:  //decrease number in supply pile
    #####: 1470:  state->supplyCount[supplyPos]--;
        -: 1471:	 
    #####: 1472:  return 0;
        -: 1473:}
        -: 1474:
function updateCoins called 10 returned 100% blocks executed 82%
       10: 1475:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1476:{
        -: 1477:  int i;
        -: 1478:	
        -: 1479:  //reset coin count
       10: 1480:  state->coins = 0;
        -: 1481:
        -: 1482:  //add coins for each Treasure card in player's hand
       60: 1483:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1484:    {
       50: 1485:      if (state->hand[player][i] == copper)
branch  0 taken 84% (fallthrough)
branch  1 taken 16%
        -: 1486:	{
       42: 1487:	  state->coins += 1;
        -: 1488:	}
        8: 1489:      else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1490:	{
    #####: 1491:	  state->coins += 2;
        -: 1492:	}
        8: 1493:      else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1494:	{
    #####: 1495:	  state->coins += 3;
        -: 1496:	}	
        -: 1497:    }	
        -: 1498:
        -: 1499:  //add bonus
       10: 1500:  state->coins += bonus;
        -: 1501:
       10: 1502:  return 0;
        -: 1503:}
        -: 1504:
        -: 1505:
        -: 1506://end of dominion.c
        -: 1507:
unittest3.c:
Testing updateCoins function...
Checking the updateCoins function provides correct coin count
---------------------------------------------------------------------

Test player 0 with 1 treasure card(s) and 0 bonus.
All Coopers = 1, expected = 1
Great! updateCoins function returned correct number of coins.

All Silvers = 2, expected = 2
Great! updateCoins function returned correct number of coins.

All Golds = 3, expected = 3
Great! updateCoins function returned correct number of coins.

Test player 0 with 1 treasure card(s) and 1 bonus.
All Coopers = 2, expected = 2
Great! updateCoins function returned correct number of coins.

All Silvers = 3, expected = 3
Great! updateCoins function returned correct number of coins.

All Golds = 4, expected = 4
Great! updateCoins function returned correct number of coins.

Test player 0 with 1 treasure card(s) and 2 bonus.
All Coopers = 3, expected = 3
Great! updateCoins function returned correct number of coins.

All Silvers = 4, expected = 4
Great! updateCoins function returned correct number of coins.

All Golds = 5, expected = 5
Great! updateCoins function returned correct number of coins.

Test player 0 with 1 treasure card(s) and 3 bonus.
All Coopers = 4, expected = 4
Great! updateCoins function returned correct number of coins.

All Silvers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Golds = 6, expected = 6
Great! updateCoins function returned correct number of coins.

Test player 0 with 1 treasure card(s) and 4 bonus.
All Coopers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Silvers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Golds = 7, expected = 7
Great! updateCoins function returned correct number of coins.

Test player 0 with 1 treasure card(s) and 5 bonus.
All Coopers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Silvers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Golds = 8, expected = 8
Great! updateCoins function returned correct number of coins.

Test player 0 with 1 treasure card(s) and 6 bonus.
All Coopers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Silvers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Golds = 9, expected = 9
Great! updateCoins function returned correct number of coins.

Test player 0 with 1 treasure card(s) and 7 bonus.
All Coopers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Silvers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Golds = 10, expected = 10
Great! updateCoins function returned correct number of coins.

Test player 0 with 1 treasure card(s) and 8 bonus.
All Coopers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Silvers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Golds = 11, expected = 11
Great! updateCoins function returned correct number of coins.

Test player 0 with 1 treasure card(s) and 9 bonus.
All Coopers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Silvers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Golds = 12, expected = 12
Great! updateCoins function returned correct number of coins.

Test player 0 with 1 treasure card(s) and 10 bonus.
All Coopers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Silvers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Golds = 13, expected = 13
Great! updateCoins function returned correct number of coins.

Test player 0 with 2 treasure card(s) and 0 bonus.
All Coopers = 2, expected = 2
Great! updateCoins function returned correct number of coins.

All Silvers = 4, expected = 4
Great! updateCoins function returned correct number of coins.

All Golds = 6, expected = 6
Great! updateCoins function returned correct number of coins.

Test player 0 with 2 treasure card(s) and 1 bonus.
All Coopers = 3, expected = 3
Great! updateCoins function returned correct number of coins.

All Silvers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Golds = 7, expected = 7
Great! updateCoins function returned correct number of coins.

Test player 0 with 2 treasure card(s) and 2 bonus.
All Coopers = 4, expected = 4
Great! updateCoins function returned correct number of coins.

All Silvers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Golds = 8, expected = 8
Great! updateCoins function returned correct number of coins.

Test player 0 with 2 treasure card(s) and 3 bonus.
All Coopers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Silvers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Golds = 9, expected = 9
Great! updateCoins function returned correct number of coins.

Test player 0 with 2 treasure card(s) and 4 bonus.
All Coopers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Silvers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Golds = 10, expected = 10
Great! updateCoins function returned correct number of coins.

Test player 0 with 2 treasure card(s) and 5 bonus.
All Coopers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Silvers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Golds = 11, expected = 11
Great! updateCoins function returned correct number of coins.

Test player 0 with 2 treasure card(s) and 6 bonus.
All Coopers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Silvers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Golds = 12, expected = 12
Great! updateCoins function returned correct number of coins.

Test player 0 with 2 treasure card(s) and 7 bonus.
All Coopers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Silvers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Golds = 13, expected = 13
Great! updateCoins function returned correct number of coins.

Test player 0 with 2 treasure card(s) and 8 bonus.
All Coopers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Silvers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Golds = 14, expected = 14
Great! updateCoins function returned correct number of coins.

Test player 0 with 2 treasure card(s) and 9 bonus.
All Coopers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Silvers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Golds = 15, expected = 15
Great! updateCoins function returned correct number of coins.

Test player 0 with 2 treasure card(s) and 10 bonus.
All Coopers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Silvers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

All Golds = 16, expected = 16
Great! updateCoins function returned correct number of coins.

Test player 0 with 3 treasure card(s) and 0 bonus.
All Coopers = 3, expected = 3
Great! updateCoins function returned correct number of coins.

All Silvers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Golds = 9, expected = 9
Great! updateCoins function returned correct number of coins.

Test player 0 with 3 treasure card(s) and 1 bonus.
All Coopers = 4, expected = 4
Great! updateCoins function returned correct number of coins.

All Silvers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Golds = 10, expected = 10
Great! updateCoins function returned correct number of coins.

Test player 0 with 3 treasure card(s) and 2 bonus.
All Coopers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Silvers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Golds = 11, expected = 11
Great! updateCoins function returned correct number of coins.

Test player 0 with 3 treasure card(s) and 3 bonus.
All Coopers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Silvers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Golds = 12, expected = 12
Great! updateCoins function returned correct number of coins.

Test player 0 with 3 treasure card(s) and 4 bonus.
All Coopers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Silvers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Golds = 13, expected = 13
Great! updateCoins function returned correct number of coins.

Test player 0 with 3 treasure card(s) and 5 bonus.
All Coopers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Silvers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Golds = 14, expected = 14
Great! updateCoins function returned correct number of coins.

Test player 0 with 3 treasure card(s) and 6 bonus.
All Coopers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Silvers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Golds = 15, expected = 15
Great! updateCoins function returned correct number of coins.

Test player 0 with 3 treasure card(s) and 7 bonus.
All Coopers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Silvers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Golds = 16, expected = 16
Great! updateCoins function returned correct number of coins.

Test player 0 with 3 treasure card(s) and 8 bonus.
All Coopers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Silvers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

All Golds = 17, expected = 17
Great! updateCoins function returned correct number of coins.

Test player 0 with 3 treasure card(s) and 9 bonus.
All Coopers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Silvers = 15, expected = 15
Great! updateCoins function returned correct number of coins.

All Golds = 18, expected = 18
Great! updateCoins function returned correct number of coins.

Test player 0 with 3 treasure card(s) and 10 bonus.
All Coopers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Silvers = 16, expected = 16
Great! updateCoins function returned correct number of coins.

All Golds = 19, expected = 19
Great! updateCoins function returned correct number of coins.

Test player 0 with 4 treasure card(s) and 0 bonus.
All Coopers = 4, expected = 4
Great! updateCoins function returned correct number of coins.

All Silvers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Golds = 12, expected = 12
Great! updateCoins function returned correct number of coins.

Test player 0 with 4 treasure card(s) and 1 bonus.
All Coopers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Silvers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Golds = 13, expected = 13
Great! updateCoins function returned correct number of coins.

Test player 0 with 4 treasure card(s) and 2 bonus.
All Coopers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Silvers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Golds = 14, expected = 14
Great! updateCoins function returned correct number of coins.

Test player 0 with 4 treasure card(s) and 3 bonus.
All Coopers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Silvers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Golds = 15, expected = 15
Great! updateCoins function returned correct number of coins.

Test player 0 with 4 treasure card(s) and 4 bonus.
All Coopers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Silvers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Golds = 16, expected = 16
Great! updateCoins function returned correct number of coins.

Test player 0 with 4 treasure card(s) and 5 bonus.
All Coopers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Silvers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Golds = 17, expected = 17
Great! updateCoins function returned correct number of coins.

Test player 0 with 4 treasure card(s) and 6 bonus.
All Coopers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Silvers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

All Golds = 18, expected = 18
Great! updateCoins function returned correct number of coins.

Test player 0 with 4 treasure card(s) and 7 bonus.
All Coopers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Silvers = 15, expected = 15
Great! updateCoins function returned correct number of coins.

All Golds = 19, expected = 19
Great! updateCoins function returned correct number of coins.

Test player 0 with 4 treasure card(s) and 8 bonus.
All Coopers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Silvers = 16, expected = 16
Great! updateCoins function returned correct number of coins.

All Golds = 20, expected = 20
Great! updateCoins function returned correct number of coins.

Test player 0 with 4 treasure card(s) and 9 bonus.
All Coopers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Silvers = 17, expected = 17
Great! updateCoins function returned correct number of coins.

All Golds = 21, expected = 21
Great! updateCoins function returned correct number of coins.

Test player 0 with 4 treasure card(s) and 10 bonus.
All Coopers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

All Silvers = 18, expected = 18
Great! updateCoins function returned correct number of coins.

All Golds = 22, expected = 22
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure card(s) and 0 bonus.
All Coopers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Silvers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Golds = 15, expected = 15
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure card(s) and 1 bonus.
All Coopers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Silvers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Golds = 16, expected = 16
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure card(s) and 2 bonus.
All Coopers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Silvers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Golds = 17, expected = 17
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure card(s) and 3 bonus.
All Coopers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Silvers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Golds = 18, expected = 18
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure card(s) and 4 bonus.
All Coopers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Silvers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

All Golds = 19, expected = 19
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure card(s) and 5 bonus.
All Coopers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Silvers = 15, expected = 15
Great! updateCoins function returned correct number of coins.

All Golds = 20, expected = 20
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure card(s) and 6 bonus.
All Coopers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Silvers = 16, expected = 16
Great! updateCoins function returned correct number of coins.

All Golds = 21, expected = 21
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure card(s) and 7 bonus.
All Coopers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Silvers = 17, expected = 17
Great! updateCoins function returned correct number of coins.

All Golds = 22, expected = 22
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure card(s) and 8 bonus.
All Coopers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Silvers = 18, expected = 18
Great! updateCoins function returned correct number of coins.

All Golds = 23, expected = 23
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure card(s) and 9 bonus.
All Coopers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

All Silvers = 19, expected = 19
Great! updateCoins function returned correct number of coins.

All Golds = 24, expected = 24
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure card(s) and 10 bonus.
All Coopers = 15, expected = 15
Great! updateCoins function returned correct number of coins.

All Silvers = 20, expected = 20
Great! updateCoins function returned correct number of coins.

All Golds = 25, expected = 25
Great! updateCoins function returned correct number of coins.

Test player 1 with 1 treasure card(s) and 0 bonus.
All Coopers = 1, expected = 1
Great! updateCoins function returned correct number of coins.

All Silvers = 2, expected = 2
Great! updateCoins function returned correct number of coins.

All Golds = 3, expected = 3
Great! updateCoins function returned correct number of coins.

Test player 1 with 1 treasure card(s) and 1 bonus.
All Coopers = 2, expected = 2
Great! updateCoins function returned correct number of coins.

All Silvers = 3, expected = 3
Great! updateCoins function returned correct number of coins.

All Golds = 4, expected = 4
Great! updateCoins function returned correct number of coins.

Test player 1 with 1 treasure card(s) and 2 bonus.
All Coopers = 3, expected = 3
Great! updateCoins function returned correct number of coins.

All Silvers = 4, expected = 4
Great! updateCoins function returned correct number of coins.

All Golds = 5, expected = 5
Great! updateCoins function returned correct number of coins.

Test player 1 with 1 treasure card(s) and 3 bonus.
All Coopers = 4, expected = 4
Great! updateCoins function returned correct number of coins.

All Silvers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Golds = 6, expected = 6
Great! updateCoins function returned correct number of coins.

Test player 1 with 1 treasure card(s) and 4 bonus.
All Coopers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Silvers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Golds = 7, expected = 7
Great! updateCoins function returned correct number of coins.

Test player 1 with 1 treasure card(s) and 5 bonus.
All Coopers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Silvers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Golds = 8, expected = 8
Great! updateCoins function returned correct number of coins.

Test player 1 with 1 treasure card(s) and 6 bonus.
All Coopers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Silvers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Golds = 9, expected = 9
Great! updateCoins function returned correct number of coins.

Test player 1 with 1 treasure card(s) and 7 bonus.
All Coopers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Silvers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Golds = 10, expected = 10
Great! updateCoins function returned correct number of coins.

Test player 1 with 1 treasure card(s) and 8 bonus.
All Coopers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Silvers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Golds = 11, expected = 11
Great! updateCoins function returned correct number of coins.

Test player 1 with 1 treasure card(s) and 9 bonus.
All Coopers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Silvers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Golds = 12, expected = 12
Great! updateCoins function returned correct number of coins.

Test player 1 with 1 treasure card(s) and 10 bonus.
All Coopers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Silvers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Golds = 13, expected = 13
Great! updateCoins function returned correct number of coins.

Test player 1 with 2 treasure card(s) and 0 bonus.
All Coopers = 2, expected = 2
Great! updateCoins function returned correct number of coins.

All Silvers = 4, expected = 4
Great! updateCoins function returned correct number of coins.

All Golds = 6, expected = 6
Great! updateCoins function returned correct number of coins.

Test player 1 with 2 treasure card(s) and 1 bonus.
All Coopers = 3, expected = 3
Great! updateCoins function returned correct number of coins.

All Silvers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Golds = 7, expected = 7
Great! updateCoins function returned correct number of coins.

Test player 1 with 2 treasure card(s) and 2 bonus.
All Coopers = 4, expected = 4
Great! updateCoins function returned correct number of coins.

All Silvers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Golds = 8, expected = 8
Great! updateCoins function returned correct number of coins.

Test player 1 with 2 treasure card(s) and 3 bonus.
All Coopers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Silvers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Golds = 9, expected = 9
Great! updateCoins function returned correct number of coins.

Test player 1 with 2 treasure card(s) and 4 bonus.
All Coopers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Silvers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Golds = 10, expected = 10
Great! updateCoins function returned correct number of coins.

Test player 1 with 2 treasure card(s) and 5 bonus.
All Coopers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Silvers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Golds = 11, expected = 11
Great! updateCoins function returned correct number of coins.

Test player 1 with 2 treasure card(s) and 6 bonus.
All Coopers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Silvers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Golds = 12, expected = 12
Great! updateCoins function returned correct number of coins.

Test player 1 with 2 treasure card(s) and 7 bonus.
All Coopers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Silvers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Golds = 13, expected = 13
Great! updateCoins function returned correct number of coins.

Test player 1 with 2 treasure card(s) and 8 bonus.
All Coopers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Silvers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Golds = 14, expected = 14
Great! updateCoins function returned correct number of coins.

Test player 1 with 2 treasure card(s) and 9 bonus.
All Coopers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Silvers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Golds = 15, expected = 15
Great! updateCoins function returned correct number of coins.

Test player 1 with 2 treasure card(s) and 10 bonus.
All Coopers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Silvers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

All Golds = 16, expected = 16
Great! updateCoins function returned correct number of coins.

Test player 1 with 3 treasure card(s) and 0 bonus.
All Coopers = 3, expected = 3
Great! updateCoins function returned correct number of coins.

All Silvers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Golds = 9, expected = 9
Great! updateCoins function returned correct number of coins.

Test player 1 with 3 treasure card(s) and 1 bonus.
All Coopers = 4, expected = 4
Great! updateCoins function returned correct number of coins.

All Silvers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Golds = 10, expected = 10
Great! updateCoins function returned correct number of coins.

Test player 1 with 3 treasure card(s) and 2 bonus.
All Coopers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Silvers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Golds = 11, expected = 11
Great! updateCoins function returned correct number of coins.

Test player 1 with 3 treasure card(s) and 3 bonus.
All Coopers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Silvers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Golds = 12, expected = 12
Great! updateCoins function returned correct number of coins.

Test player 1 with 3 treasure card(s) and 4 bonus.
All Coopers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Silvers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Golds = 13, expected = 13
Great! updateCoins function returned correct number of coins.

Test player 1 with 3 treasure card(s) and 5 bonus.
All Coopers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Silvers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Golds = 14, expected = 14
Great! updateCoins function returned correct number of coins.

Test player 1 with 3 treasure card(s) and 6 bonus.
All Coopers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Silvers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Golds = 15, expected = 15
Great! updateCoins function returned correct number of coins.

Test player 1 with 3 treasure card(s) and 7 bonus.
All Coopers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Silvers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Golds = 16, expected = 16
Great! updateCoins function returned correct number of coins.

Test player 1 with 3 treasure card(s) and 8 bonus.
All Coopers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Silvers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

All Golds = 17, expected = 17
Great! updateCoins function returned correct number of coins.

Test player 1 with 3 treasure card(s) and 9 bonus.
All Coopers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Silvers = 15, expected = 15
Great! updateCoins function returned correct number of coins.

All Golds = 18, expected = 18
Great! updateCoins function returned correct number of coins.

Test player 1 with 3 treasure card(s) and 10 bonus.
All Coopers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Silvers = 16, expected = 16
Great! updateCoins function returned correct number of coins.

All Golds = 19, expected = 19
Great! updateCoins function returned correct number of coins.

Test player 1 with 4 treasure card(s) and 0 bonus.
All Coopers = 4, expected = 4
Great! updateCoins function returned correct number of coins.

All Silvers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Golds = 12, expected = 12
Great! updateCoins function returned correct number of coins.

Test player 1 with 4 treasure card(s) and 1 bonus.
All Coopers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Silvers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Golds = 13, expected = 13
Great! updateCoins function returned correct number of coins.

Test player 1 with 4 treasure card(s) and 2 bonus.
All Coopers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Silvers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Golds = 14, expected = 14
Great! updateCoins function returned correct number of coins.

Test player 1 with 4 treasure card(s) and 3 bonus.
All Coopers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Silvers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Golds = 15, expected = 15
Great! updateCoins function returned correct number of coins.

Test player 1 with 4 treasure card(s) and 4 bonus.
All Coopers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Silvers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Golds = 16, expected = 16
Great! updateCoins function returned correct number of coins.

Test player 1 with 4 treasure card(s) and 5 bonus.
All Coopers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Silvers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Golds = 17, expected = 17
Great! updateCoins function returned correct number of coins.

Test player 1 with 4 treasure card(s) and 6 bonus.
All Coopers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Silvers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

All Golds = 18, expected = 18
Great! updateCoins function returned correct number of coins.

Test player 1 with 4 treasure card(s) and 7 bonus.
All Coopers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Silvers = 15, expected = 15
Great! updateCoins function returned correct number of coins.

All Golds = 19, expected = 19
Great! updateCoins function returned correct number of coins.

Test player 1 with 4 treasure card(s) and 8 bonus.
All Coopers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Silvers = 16, expected = 16
Great! updateCoins function returned correct number of coins.

All Golds = 20, expected = 20
Great! updateCoins function returned correct number of coins.

Test player 1 with 4 treasure card(s) and 9 bonus.
All Coopers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Silvers = 17, expected = 17
Great! updateCoins function returned correct number of coins.

All Golds = 21, expected = 21
Great! updateCoins function returned correct number of coins.

Test player 1 with 4 treasure card(s) and 10 bonus.
All Coopers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

All Silvers = 18, expected = 18
Great! updateCoins function returned correct number of coins.

All Golds = 22, expected = 22
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure card(s) and 0 bonus.
All Coopers = 5, expected = 5
Great! updateCoins function returned correct number of coins.

All Silvers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Golds = 15, expected = 15
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure card(s) and 1 bonus.
All Coopers = 6, expected = 6
Great! updateCoins function returned correct number of coins.

All Silvers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Golds = 16, expected = 16
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure card(s) and 2 bonus.
All Coopers = 7, expected = 7
Great! updateCoins function returned correct number of coins.

All Silvers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Golds = 17, expected = 17
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure card(s) and 3 bonus.
All Coopers = 8, expected = 8
Great! updateCoins function returned correct number of coins.

All Silvers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Golds = 18, expected = 18
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure card(s) and 4 bonus.
All Coopers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

All Silvers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

All Golds = 19, expected = 19
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure card(s) and 5 bonus.
All Coopers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

All Silvers = 15, expected = 15
Great! updateCoins function returned correct number of coins.

All Golds = 20, expected = 20
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure card(s) and 6 bonus.
All Coopers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

All Silvers = 16, expected = 16
Great! updateCoins function returned correct number of coins.

All Golds = 21, expected = 21
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure card(s) and 7 bonus.
All Coopers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

All Silvers = 17, expected = 17
Great! updateCoins function returned correct number of coins.

All Golds = 22, expected = 22
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure card(s) and 8 bonus.
All Coopers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

All Silvers = 18, expected = 18
Great! updateCoins function returned correct number of coins.

All Golds = 23, expected = 23
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure card(s) and 9 bonus.
All Coopers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

All Silvers = 19, expected = 19
Great! updateCoins function returned correct number of coins.

All Golds = 24, expected = 24
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure card(s) and 10 bonus.
All Coopers = 15, expected = 15
Great! updateCoins function returned correct number of coins.

All Silvers = 20, expected = 20
Great! updateCoins function returned correct number of coins.

All Golds = 25, expected = 25
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 0 bonus.
1 Gold, 2 Silvers, 2 Coppers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 1 bonus.
1 Gold, 2 Silvers, 2 Coppers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 2 bonus.
1 Gold, 2 Silvers, 2 Coppers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 3 bonus.
1 Gold, 2 Silvers, 2 Coppers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 4 bonus.
1 Gold, 2 Silvers, 2 Coppers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 5 bonus.
1 Gold, 2 Silvers, 2 Coppers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 6 bonus.
1 Gold, 2 Silvers, 2 Coppers = 15, expected = 15
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 7 bonus.
1 Gold, 2 Silvers, 2 Coppers = 16, expected = 16
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 8 bonus.
1 Gold, 2 Silvers, 2 Coppers = 17, expected = 17
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 9 bonus.
1 Gold, 2 Silvers, 2 Coppers = 18, expected = 18
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 10 bonus.
1 Gold, 2 Silvers, 2 Coppers = 19, expected = 19
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 0 bonus.
1 Gold, 2 Silvers, 2 Coppers = 9, expected = 9
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 1 bonus.
1 Gold, 2 Silvers, 2 Coppers = 10, expected = 10
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 2 bonus.
1 Gold, 2 Silvers, 2 Coppers = 11, expected = 11
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 3 bonus.
1 Gold, 2 Silvers, 2 Coppers = 12, expected = 12
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 4 bonus.
1 Gold, 2 Silvers, 2 Coppers = 13, expected = 13
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 5 bonus.
1 Gold, 2 Silvers, 2 Coppers = 14, expected = 14
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 6 bonus.
1 Gold, 2 Silvers, 2 Coppers = 15, expected = 15
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 7 bonus.
1 Gold, 2 Silvers, 2 Coppers = 16, expected = 16
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 8 bonus.
1 Gold, 2 Silvers, 2 Coppers = 17, expected = 17
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 9 bonus.
1 Gold, 2 Silvers, 2 Coppers = 18, expected = 18
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 2 copper) & 10 bonus.
1 Gold, 2 Silvers, 2 Coppers = 19, expected = 19
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 0 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 8, expected = 8
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 1 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 9, expected = 9
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 2 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 10, expected = 10
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 3 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 11, expected = 11
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 4 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 12, expected = 12
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 5 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 13, expected = 13
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 6 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 14, expected = 14
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 7 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 15, expected = 15
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 8 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 16, expected = 16
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 9 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 17, expected = 17
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 10 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 18, expected = 18
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 0 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 8, expected = 8
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 1 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 9, expected = 9
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 2 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 10, expected = 10
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 3 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 11, expected = 11
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 4 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 12, expected = 12
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 5 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 13, expected = 13
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 6 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 14, expected = 14
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 7 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 15, expected = 15
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 8 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 16, expected = 16
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 9 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 17, expected = 17
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & 10 bonus.
1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = 18, expected = 18
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 kingdom cards) & 0 bonus.
5 kingdom cards = 0, expected = 0
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 kingdom cards) & 1 bonus.
5 kingdom cards = 1, expected = 1
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 kingdom cards) & 2 bonus.
5 kingdom cards = 2, expected = 2
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 kingdom cards) & 3 bonus.
5 kingdom cards = 3, expected = 3
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 kingdom cards) & 4 bonus.
5 kingdom cards = 4, expected = 4
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 kingdom cards) & 5 bonus.
5 kingdom cards = 5, expected = 5
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 kingdom cards) & 6 bonus.
5 kingdom cards = 6, expected = 6
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 kingdom cards) & 7 bonus.
5 kingdom cards = 7, expected = 7
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 kingdom cards) & 8 bonus.
5 kingdom cards = 8, expected = 8
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 kingdom cards) & 9 bonus.
5 kingdom cards = 9, expected = 9
Great! updateCoins function returned correct number of coins.

Test player 0 with 5 kingdom cards) & 10 bonus.
5 kingdom cards = 10, expected = 10
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 kingdom cards) & 0 bonus.
5 kingdom cards = 0, expected = 0
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 kingdom cards) & 1 bonus.
5 kingdom cards = 1, expected = 1
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 kingdom cards) & 2 bonus.
5 kingdom cards = 2, expected = 2
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 kingdom cards) & 3 bonus.
5 kingdom cards = 3, expected = 3
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 kingdom cards) & 4 bonus.
5 kingdom cards = 4, expected = 4
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 kingdom cards) & 5 bonus.
5 kingdom cards = 5, expected = 5
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 kingdom cards) & 6 bonus.
5 kingdom cards = 6, expected = 6
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 kingdom cards) & 7 bonus.
5 kingdom cards = 7, expected = 7
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 kingdom cards) & 8 bonus.
5 kingdom cards = 8, expected = 8
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 kingdom cards) & 9 bonus.
5 kingdom cards = 9, expected = 9
Great! updateCoins function returned correct number of coins.

Test player 1 with 5 kingdom cards) & 10 bonus.
5 kingdom cards = 10, expected = 10
Great! updateCoins function returned correct number of coins.

---------------------------------------------
Final Testing results of updateCoins function
---------------------------------------------
All tests passed for the updateCoins function!

File 'unittest3.c'
Lines executed:88.50% of 113
Branches executed:100.00% of 34
Taken at least once:79.41% of 34
Calls executed:84.09% of 44
Creating 'unittest3.c.gcov'

        -:    0:Source:unittest3.c
        -:    0:Graph:unittest3.gcno
        -:    0:Data:unittest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* -----------------------------------------------------------------------
        -:    2: * CS362-004 Summer 2017 Assignment 3
        -:    3: * unittest3.c
        -:    4: * 
        -:    5: * Patrick Kwong
        -:    6: * kwongp@oregonstate.edu
        -:    7: *
        -:    8: * Unit test for dominion function: updateCoins
        -:    9: * calculate players coin count during turn by
        -:   10: * adding treasure card(s) value in hand and bonus from cards played
        -:   11: * -----------------------------------------------------------------------
        -:   12: * Include the following lines in the makefile:
        -:   13: *
        -:   14: * unittest3: unittest3.c dominion.o rngs.o
        -:   15: *      gcc -o unittest3 -g unittest3.c dominion.o rngs.o $(CFLAGS)
        -:   16: */
        -:   17:
        -:   18:#include "dominion.h"
        -:   19:#include "dominion_helpers.h"
        -:   20:#include <string.h>
        -:   21:#include <stdio.h>
        -:   22:#include <assert.h>
        -:   23:#include "rngs.h"
        -:   24:#include <stdlib.h>
        -:   25:#include <time.h>
        -:   26:#include <math.h>
        -:   27:
function main called 1 returned 100% blocks executed 85%
        1:   28:int main() {
        -:   29:    int i;
        -:   30:    int seed;
        1:   31:    int numPlayer = 2;
        1:   32:    int maxBonus = 10;
        -:   33:    int p, handCount;
        1:   34:    int gameStatus = 0;
        1:   35:    int bugCount = 0;
        -:   36:    int bonus;
        1:   37:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   38:               , remodel, smithy, village, baron, great_hall};
        -:   39:    struct gameState G;
        1:   40:    int maxHandCount = 5;
        -:   41:    int moreTests[10];
        1:   42:    seed = (rand() % 100); // random seed
call    0 returned 100%
        -:   43:    // arrays of all coppers, silvers, and golds
        -:   44:    int coppers[MAX_HAND];
        -:   45:    int silvers[MAX_HAND];
        -:   46:    int golds[MAX_HAND];
      501:   47:    for (i = 0; i < MAX_HAND; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   48:    {
      500:   49:        coppers[i] = copper;
      500:   50:        silvers[i] = silver;
      500:   51:        golds[i] = gold;
        -:   52:    }
        -:   53:
        1:   54:    printf("Testing updateCoins function...\n");
call    0 returned 100%
        1:   55:    printf("Checking the updateCoins function provides correct coin count\n");
call    0 returned 100%
        1:   56:    printf("---------------------------------------------------------------------\n\n");
call    0 returned 100%
        3:   57:    for (p = 0; p < numPlayer; p++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   58:    {
       12:   59:        for (handCount = 1; handCount <= maxHandCount; handCount++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:   60:        {
      120:   61:            for (bonus = 0; bonus <= maxBonus; bonus++)
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -:   62:            {
      110:   63:                printf("Test player %d with %d treasure card(s) and %d bonus.\n", p, handCount, bonus);
call    0 returned 100%
      110:   64:                memset(&G, 23, sizeof(struct gameState));   // clear the game state
      110:   65:                initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
      110:   66:                G.handCount[p] = handCount;                 // set the number of cards on hand
        -:   67:
        -:   68:                // all copper test
      110:   69:                memcpy(G.hand[p], coppers, sizeof(int) * handCount); // set all the cards to copper
      110:   70:                updateCoins(p, &G, bonus);
call    0 returned 100%
      110:   71:                printf("All Coopers = %d, expected = %d\n", G.coins, handCount * 1 + bonus);
call    0 returned 100%
      110:   72:                gameStatus = (G.coins == handCount * 1 + bonus); // check if the number of coins is correct
      110:   73:                if(gameStatus == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      110:   74:                    printf("Great! updateCoins function returned correct number of coins.\n\n");
call    0 returned 100%
        -:   75:                else
        -:   76:                {
    #####:   77:                    printf("BUG!!! updateCoins function returned wrong number of coins.\n\n");
call    0 never executed
    #####:   78:                    bugCount++;
        -:   79:                }
        -:   80:
        -:   81:                // all silver test
      110:   82:                memcpy(G.hand[p], silvers, sizeof(int) * handCount); // set all the cards to silver
      110:   83:                updateCoins(p, &G, bonus);
call    0 returned 100%
      110:   84:                printf("All Silvers = %d, expected = %d\n", G.coins, handCount * 2 + bonus);
call    0 returned 100%
      110:   85:                gameStatus = (G.coins == handCount * 2 + bonus); // check if the number of coins is correct
      110:   86:                if(gameStatus == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      110:   87:                    printf("Great! updateCoins function returned correct number of coins.\n\n");
call    0 returned 100%
        -:   88:                else
        -:   89:                {
    #####:   90:                    printf("BUG!!! updateCoins function returned wrong number of coins.\n\n");
call    0 never executed
    #####:   91:                    bugCount++;
        -:   92:                }
        -:   93:
        -:   94:                // all gold test
      110:   95:                memcpy(G.hand[p], golds, sizeof(int) * handCount); // set all the cards to gold
      110:   96:                updateCoins(p, &G, bonus);
call    0 returned 100%
      110:   97:                printf("All Golds = %d, expected = %d\n", G.coins, handCount * 3 + bonus);
call    0 returned 100%
      110:   98:                gameStatus = (G.coins == handCount * 3 + bonus); // check if the number of coins is correct
      110:   99:                if(gameStatus == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      110:  100:                    printf("Great! updateCoins function returned correct number of coins.\n\n");
call    0 returned 100%
        -:  101:                else
        -:  102:                {
    #####:  103:                    printf("BUG!!! updateCoins function returned wrong number of coins.\n\n");
call    0 never executed
    #####:  104:                    bugCount++;
        -:  105:                }
        -:  106:            }
        -:  107:        }
        -:  108:    }
        -:  109:
        -:  110:
        -:  111:    // 5 card treasure mix test
        3:  112:    for(p = 0; p < numPlayer; p++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  113:    {
       24:  114:        for (bonus = 0; bonus <= maxBonus; bonus++)
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -:  115:        {
        -:  116:
        -:  117:            
       22:  118:            printf("Test player %d with 5 treasure cards (1 gold, 2 silver, 2 copper) & %d bonus.\n", p, bonus);
call    0 returned 100%
       22:  119:            seed = (rand() % 100); // random seed
call    0 returned 100%
       22:  120:            memset(&G, 23, sizeof(struct gameState));   // clear the game state
       22:  121:            initializeGame(numPlayer, k, seed, &G); // initialize new game
call    0 returned 100%
       22:  122:            G.handCount[p] = 5;
        -:  123:
       22:  124:            moreTests[0] = gold;
       22:  125:            moreTests[1] = silver;
       22:  126:            moreTests[2] = silver;
       22:  127:            moreTests[3] = copper;
       22:  128:            moreTests[4] = copper;
        -:  129:
       22:  130:            memcpy(G.hand[p], moreTests, sizeof(int) * 5); 
       22:  131:            updateCoins(p, &G, bonus);
call    0 returned 100%
       22:  132:            printf("1 Gold, 2 Silvers, 2 Coppers = %d, expected = %d\n", G.coins, (handCount * 1) + 3 + bonus); // 5 treasure, +1 for each silver and +2 for the gold
call    0 returned 100%
       22:  133:            gameStatus = (G.coins == (handCount * 1) + 3 + bonus);
        -:  134:            
       22:  135:            if(gameStatus == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       22:  136:                printf("Great! updateCoins function returned correct number of coins.\n\n");
call    0 returned 100%
        -:  137:            else
        -:  138:            {
    #####:  139:                printf("BUG!!! updateCoins function returned wrong number of coins.\n\n");
call    0 never executed
    #####:  140:                bugCount++;
        -:  141:            }
        -:  142:        }
        -:  143:    }
        -:  144:
        -:  145:    // 4 treasure mix with 1 kingdom card test
        3:  146:    for(p = 0; p < numPlayer; p++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  147:    {
       24:  148:        for (bonus = 0; bonus <= maxBonus; bonus++)
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -:  149:        {        
       22:  150:            printf("Test player %d with 5 treasure cards (1 gold, 2 silver, 1 copper, 1 Smithy) & %d bonus.\n", p, bonus);
call    0 returned 100%
       22:  151:            seed = (rand() % 100); // random seed
call    0 returned 100%
       22:  152:            memset(&G, 23, sizeof(struct gameState));   // clear the game state
       22:  153:            initializeGame(numPlayer, k, seed, &G); // initialize new game
call    0 returned 100%
       22:  154:            G.handCount[p] = 5;
        -:  155:
       22:  156:            moreTests[0] = gold;
       22:  157:            moreTests[1] = silver;
       22:  158:            moreTests[2] = silver;
       22:  159:            moreTests[3] = copper;
       22:  160:            moreTests[4] = smithy;
        -:  161:
       22:  162:            memcpy(G.hand[p], moreTests, sizeof(int) * 5); 
       22:  163:            updateCoins(p, &G, bonus);
call    0 returned 100%
       22:  164:            printf("1 Gold, 2 Silvers, 1 Coppers, 1 Smithy = %d, expected = %d\n", G.coins, (handCount * 1) + 2 + bonus);
call    0 returned 100%
       22:  165:            gameStatus = (G.coins == (handCount * 1) + 2 + bonus);
        -:  166:
       22:  167:            if(gameStatus == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       22:  168:                printf("Great! updateCoins function returned correct number of coins.\n\n");
call    0 returned 100%
        -:  169:            else
        -:  170:            {
    #####:  171:                printf("BUG!!! updateCoins function returned wrong number of coins.\n\n");
call    0 never executed
    #####:  172:                bugCount++;
        -:  173:            }
        -:  174:        }
        -:  175:    }
        -:  176:
        -:  177:    // 5 kingdom card test and no treasure
        3:  178:    for(p = 0; p < numPlayer; p++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  179:    {
       24:  180:        for (bonus = 0; bonus <= maxBonus; bonus++)
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -:  181:        {        
       22:  182:            printf("Test player %d with 5 kingdom cards) & %d bonus.\n", p, bonus);
call    0 returned 100%
       22:  183:            seed = (rand() % 100); // random seed
call    0 returned 100%
       22:  184:            memset(&G, 23, sizeof(struct gameState));   // clear the game state
       22:  185:            initializeGame(numPlayer, k, seed, &G); // initialize new game
call    0 returned 100%
       22:  186:            G.handCount[p] = 5;
        -:  187:
       22:  188:            moreTests[0] = feast;
       22:  189:            moreTests[1] = gardens;
       22:  190:            moreTests[2] = village;
       22:  191:            moreTests[3] = baron;
       22:  192:            moreTests[4] = smithy;
        -:  193:
       22:  194:            memcpy(G.hand[p], moreTests, sizeof(int) * 5); 
       22:  195:            updateCoins(p, &G, bonus);
call    0 returned 100%
       22:  196:            printf("5 kingdom cards = %d, expected = %d\n", G.coins, 0 + bonus);
call    0 returned 100%
       22:  197:            gameStatus = (G.coins == 0 + bonus);
        -:  198:
       22:  199:            if(gameStatus == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       22:  200:                printf("Great! updateCoins function returned correct number of coins.\n\n");
call    0 returned 100%
        -:  201:            else
        -:  202:            {
    #####:  203:                printf("BUG!!! updateCoins function returned wrong number of coins.\n\n");
call    0 never executed
    #####:  204:                bugCount++;
        -:  205:            }
        -:  206:        }
        -:  207:    }
        -:  208:
        -:  209:    // output the test results overall
        1:  210:    printf("---------------------------------------------\n");
call    0 returned 100%
        1:  211:    printf("Final Testing results of updateCoins function\n");
call    0 returned 100%
        1:  212:    printf("---------------------------------------------\n");
call    0 returned 100%
        1:  213:    if(bugCount == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  214:        printf("All tests passed for the updateCoins function!\n\n");
call    0 returned 100%
        -:  215:    else
    #####:  216:        printf("updateCoins failed provide correct number of coins for %d condition(s), check above for which ones.\n\n", bugCount);
call    0 never executed
        -:  217:    
        1:  218:    return 0;
        -:  219:}
File 'dominion.c'
Lines executed:23.27% of 563
Branches executed:24.46% of 417
Taken at least once:22.06% of 417
Calls executed:7.00% of 100
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:3
        -:    0:Programs:3
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 5580 returned 100% blocks executed 83%
     5580:    8:int compare(const void* a, const void* b) {
     5580:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:    return 1;
     5580:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
     1488:   12:    return -1;
     4092:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 187 returned 100% blocks executed 89%
      187:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      187:   44:  SelectStream(1);
call    0 returned 100%
      187:   45:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:  
        -:   47:  //check number of players
      187:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:    {
        1:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      186:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     2046:   57:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:    {
    20460:   59:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:        {
    18600:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      186:   73:  if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   74:    {
      186:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
    #####:   77:  else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      186:   87:  if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:    {
      186:   89:      state->supplyCount[estate] = 8;
      186:   90:      state->supplyCount[duchy] = 8;
      186:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      186:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      186:  102:  state->supplyCount[silver] = 40;
      186:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
     3906:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:    {
    30690:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:	{
    28830:  110:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     1860:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
        -:  114:		{
      744:  115:		  if (numPlayers == 2){ 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      372:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     1488:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     1860:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    26970:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
      558:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:    {
      372:  140:      state->deckCount[i] = 0;
     1488:  141:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:	{
     1116:  143:	  state->deck[i][j] = estate;
     1116:  144:	  state->deckCount[i]++;
        -:  145:	}
     2976:  146:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:	{
     2604:  148:	  state->deck[i][j] = copper;
     2604:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
      558:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:    {
      372:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
      558:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      372:  166:      state->handCount[i] = 0;
      372:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
     5208:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:    {
     5022:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      186:  182:  state->outpostPlayed = 0;
      186:  183:  state->phase = 0;
      186:  184:  state->numActions = 1;
      186:  185:  state->numBuys = 1;
      186:  186:  state->playedCardCount = 0;
      186:  187:  state->whoseTurn = 0;
      186:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     1116:  192:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      930:  193:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:  }
        -:  195:
      186:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
      186:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 372 returned 100% blocks executed 94%
      372:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
      372:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
      372:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  210:    return -1;
      372:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     4464:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     3720:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     3720:  216:    newDeck[newDeckPos] = state->deck[player][card];
     3720:  217:    newDeckPos++;
    13904:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 73%
branch  1 taken 27% (fallthrough)
    10184:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
     3720:  221:    state->deckCount[player]--;
        -:  222:  }
     4092:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     3720:  224:    state->deck[player][i] = newDeck[i];
     3720:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
      372:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  320:int supplyCount(int card, struct gameState *state) {
    #####:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 0 returned 0% blocks executed 0%
    #####:  346:int whoseTurn(struct gameState *state) {
    #####:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 11 returned 100% blocks executed 100%
       11:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
       11:  395:  if (state->supplyCount[province] == 0)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
        -:  396:    {
        3:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
        8:  401:  j = 0;
      208:  402:  for (i = 0; i < 25; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  403:    {
      200:  404:      if (state->supplyCount[i] == 0)
branch  0 taken 9% (fallthrough)
branch  1 taken 92%
        -:  405:	{
       17:  406:	  j++;
        -:  407:	}
        -:  408:    }
        8:  409:  if ( j >= 3)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  410:    {
        4:  411:      return 1;
        -:  412:    }
        -:  413:
        4:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 930 returned 100% blocks executed 38%
      930:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
      930:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
      930:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
      930:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
      930:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      930:  576:    state->deckCount[player]--;
      930:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
      930:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 27 returned 100% blocks executed 97%
       27:  583:int getCost(int cardNumber)
        -:  584:{
       27:  585:  switch( cardNumber ) 
branch  0 taken 4%
branch  1 taken 4%
branch  2 taken 4%
branch  3 taken 4%
branch  4 taken 4%
branch  5 taken 4%
branch  6 taken 4%
branch  7 taken 4%
branch  8 taken 4%
branch  9 taken 4%
branch 10 taken 4%
branch 11 taken 4%
branch 12 taken 4%
branch 13 taken 4%
branch 14 taken 4%
branch 15 taken 4%
branch 16 taken 4%
branch 17 taken 4%
branch 18 taken 4%
branch 19 taken 4%
branch 20 taken 4%
branch 21 taken 4%
branch 22 taken 4%
branch 23 taken 4%
branch 24 taken 4%
branch 25 taken 4%
branch 26 taken 4%
branch 27 taken 0%
        -:  586:    {
        -:  587:    case curse:
        1:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        1:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        1:  608:      return 4;
        -:  609:    case mine:
        1:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        1:  614:      return 4;
        -:  615:    case village:
        1:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        1:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        1:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        1:  630:      return 4;
        -:  631:    case embargo: 
        1:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        1:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:// Assignment 2 - refactor card #1: Adventurer
function adventurer_func called 0 returned 0% blocks executed 0%
    #####:  647:int adventurer_func(struct gameState *state)
        -:  648:{
        -:  649:	int cardDrawn;
    #####:  650:	int currentPlayer = whoseTurn(state);	
call    0 never executed
    #####:  651:	int drawntreasure = 0;
        -:  652:	int temphand[MAX_HAND];// moved above the if statement
    #####:  653:	int z = 0;// this is the counter for the temp hand
        -:  654:    
    #####:  655:	while(drawntreasure <= 2) // BUG added!! - Changed to < to <= that what it could end up drawing extra treasure.
branch  0 never executed
branch  1 never executed
        -:  656:	{
        -:  657:		//if the deck is empty we need to shuffle discard and add to deck
    #####:  658:		if (state->deckCount[currentPlayer] <1)
branch  0 never executed
branch  1 never executed
    #####:  659:			shuffle(currentPlayer, state);
call    0 never executed
        -:  660:		
    #####:  661:		drawCard(currentPlayer, state);
call    0 never executed
        -:  662:		
        -:  663:			//top card of hand is most recently drawn card.
    #####:  664:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  665:	
    #####:  666:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  667:				drawntreasure++;
        -:  668:			else
        -:  669:			{
    #####:  670:				temphand[z] = cardDrawn;
        -:  671:				
        -:  672:				//this should just remove the top card (the most recently drawn one).
    #####:  673:				state->handCount[currentPlayer]--; 
    #####:  674:				z++;
        -:  675:			}
        -:  676:		}
        -:  677:      
    #####:  678:		while(z - 1 >= 0)
branch  0 never executed
branch  1 never executed
        -:  679:		{
        -:  680:			// discard all cards in play that have been drawn
    #####:  681:			state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; 
    #####:  682:			z = z - 1;
        -:  683:		}
        -:  684:		
    #####:  685:		return 0;
        -:  686:}
        -:  687:
        -:  688:// Assignment 2 - refactor card #2: Council Room
function council_room_func called 0 returned 0% blocks executed 0%
    #####:  689:int council_room_func(int handPos, struct gameState *state)
        -:  690:{
        -:  691:	int i;
    #####:  692:	int currentPlayer = whoseTurn(state);	
call    0 never executed
        -:  693:	
        -:  694:	//+4 Cards
    #####:  695:	for (i = 1; i < 4; i++) // BUG added!!! = changed i=0 to i=1, which will result in 1 less card drawn.
branch  0 never executed
branch  1 never executed
    #####:  696:		drawCard(currentPlayer, state);
call    0 never executed
        -:  697:
        -:  698:	//+1 Buy
    #####:  699:	state->numBuys++;
        -:  700:	
        -:  701:	//Each other player draws a card
    #####:  702:	for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
    #####:  703:		if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
    #####:  704:			drawCard(i, state);
call    0 never executed
        -:  705:
        -:  706:	//put played card in played card pile
    #####:  707:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  708:
    #####:  709:	return 0;
        -:  710:}
        -:  711:
        -:  712:
        -:  713:// Assignment 2 - refactor card #3: Remodel
function remodel_func called 0 returned 0% blocks executed 0%
    #####:  714:int remodel_func(int choice1, int choice2, int handPos, struct gameState *state)
        -:  715:{
        -:  716:	int i;
        -:  717:	int j;
    #####:  718:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  719:    
    #####:  720:	j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  721:
    #####:  722:	if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  723:		return -1;
        -:  724:
    #####:  725:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  726:
        -:  727:	//discard card from hand
    #####:  728:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  729:
        -:  730:	//discard trashed card
    #####:  731:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  732:	{
    #####:  733:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  734:	    {
    #####:  735:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  736:			break;
        -:  737:	    }
        -:  738:	}
        -:  739:	
    #####:  740:	return 0;
        -:  741:}
        -:  742:
        -:  743:// Assignment 2 - refactor card #4: Smithy
function smithy_func called 0 returned 0% blocks executed 0%
    #####:  744:int smithy_func(int handPos, struct gameState *state)
        -:  745:{
        -:  746:	int i;
    #####:  747:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  748:	
        -:  749:	//+3 Cards
    #####:  750:	for (i = 0; i <= 3; i++) // BUG added!!! = changed < to <=, which will result in 1 more card drawn.
branch  0 never executed
branch  1 never executed
    #####:  751:		drawCard(currentPlayer, state);
call    0 never executed
        -:  752:
        -:  753:	//discard card from hand
    #####:  754:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  755:	
    #####:  756:	return 0;
        -:  757:}
        -:  758:
        -:  759:// Assignment 2 - refactor card #5: Village
function village_func called 0 returned 0% blocks executed 0%
    #####:  760:int village_func(int handPos, struct gameState *state)
        -:  761:{
    #####:  762:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  763:	
        -:  764:	//+1 Card
    #####:  765:	drawCard(currentPlayer, state);
call    0 never executed
        -:  766:			
        -:  767:	//+2 Actions
    #####:  768:	state->numActions = state->numActions + 22; // BUG added!!! = changed 2 to 22, which will result in +22 actions instead of just 2.
        -:  769:			
        -:  770:	//discard played card from hand
    #####:  771:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  772:
    #####:  773:	return 0;
        -:  774:}
        -:  775:
        -:  776:// cardEffect - for assignment 2 - I refactored 5 of these cards (adventurer, 
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  777:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  778:{
        -:  779:  int i;
        -:  780:  int j;
        -:  781:  int k;
        -:  782:  int x;
        -:  783:  int index;
    #####:  784:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  785:  int nextPlayer = currentPlayer + 1;
        -:  786:
    #####:  787:  int tributeRevealedCards[2] = {-1, -1};
        -:  788:  int temphand[MAX_HAND];// moved above the if statement
        -:  789:
    #####:  790:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  791:    nextPlayer = 0;
        -:  792:  }
        -:  793:  
        -:  794:  /* these variables are no longer needed after refactoring
        -:  795:  
        -:  796:    int drawntreasure=0;
        -:  797:	int cardDrawn;
        -:  798:	int z = 0;// this is the counter for the temp hand
        -:  799:	*/
        -:  800:	
        -:  801:  //uses switch to select card and perform actions
    #####:  802:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  803:    {
        -:  804:    case adventurer:
        -:  805:	
    #####:  806:		adventurer_func(state);
call    0 never executed
        -:  807:		
        -:  808:		/* commented out code that is no longer needed due to refactoring
        -:  809:		while(drawntreasure<2)
        -:  810:		{
        -:  811:			//if the deck is empty we need to shuffle discard and add to deck
        -:  812:			if (state->deckCount[currentPlayer] <1)
        -:  813:				shuffle(currentPlayer, state);
        -:  814:		
        -:  815:			drawCard(currentPlayer, state);
        -:  816:		
        -:  817:			//top card of hand is most recently drawn card.
        -:  818:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  819:	
        -:  820:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:  821:				drawntreasure++;
        -:  822:			else
        -:  823:			{
        -:  824:				temphand[z]=cardDrawn;
        -:  825:				
        -:  826:				//this should just remove the top card (the most recently drawn one).
        -:  827:				state->handCount[currentPlayer]--; 
        -:  828:				z++;
        -:  829:			}
        -:  830:		}
        -:  831:      
        -:  832:		while(z-1>=0)
        -:  833:		{
        -:  834:			// discard all cards in play that have been drawn
        -:  835:			state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; 
        -:  836:			z=z-1;
        -:  837:		}
        -:  838:		return 0;
        -:  839:		*/
        -:  840:	
        -:  841:    case council_room:
        -:  842:		
    #####:  843:		council_room_func(handPos, state);
call    0 never executed
        -:  844:		
        -:  845:		/* commented out code that is no longer needed due to refactoring
        -:  846:		
        -:  847:		//+4 Cards
        -:  848:		  for (i = 0; i < 4; i++)
        -:  849:		{
        -:  850:		  drawCard(currentPlayer, state);
        -:  851:		}
        -:  852:				
        -:  853:		  //+1 Buy
        -:  854:		  state->numBuys++;
        -:  855:				
        -:  856:		  //Each other player draws a card
        -:  857:		  for (i = 0; i < state->numPlayers; i++)
        -:  858:		{
        -:  859:		  if ( i != currentPlayer )
        -:  860:			{
        -:  861:			  drawCard(i, state);
        -:  862:			}
        -:  863:		}
        -:  864:				
        -:  865:		  //put played card in played card pile
        -:  866:		  discardCard(handPos, currentPlayer, state, 0);
        -:  867:				
        -:  868:		  return 0;
        -:  869:		*/
        -:  870:		
        -:  871:    case feast:
        -:  872:      //gain card with cost up to 5
        -:  873:      //Backup hand
    #####:  874:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  875:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  876:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  877:      }
        -:  878:      //Backup hand
        -:  879:
        -:  880:      //Update Coins for Buy
    #####:  881:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  882:      x = 1;//Condition to loop on
    #####:  883:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  884:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  885:	  if (DEBUG)
        -:  886:	    printf("None of that card left, sorry!\n");
        -:  887:
        -:  888:	  if (DEBUG){
        -:  889:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  890:	  }
        -:  891:	}
    #####:  892:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  893:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  894:
        -:  895:	  if (DEBUG){
        -:  896:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  897:	  }
        -:  898:	}
        -:  899:	else{
        -:  900:
        -:  901:	  if (DEBUG){
        -:  902:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  903:	  }
        -:  904:
    #####:  905:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  906:	  x = 0;//No more buying cards
        -:  907:
        -:  908:	  if (DEBUG){
        -:  909:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  910:	  }
        -:  911:
        -:  912:	}
        -:  913:      }     
        -:  914:
        -:  915:      //Reset Hand
    #####:  916:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  917:	state->hand[currentPlayer][i] = temphand[i];
    #####:  918:	temphand[i] = -1;
        -:  919:      }
        -:  920:      //Reset Hand
        -:  921:      			
    #####:  922:      return 0;
        -:  923:			
        -:  924:    case gardens:
    #####:  925:      return -1;
        -:  926:			
        -:  927:    case mine:
    #####:  928:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  929:
    #####:  930:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  931:	{
    #####:  932:	  return -1;
        -:  933:	}
        -:  934:		
    #####:  935:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  936:	{
    #####:  937:	  return -1;
        -:  938:	}
        -:  939:
    #####:  940:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  941:	{
    #####:  942:	  return -1;
        -:  943:	}
        -:  944:
    #####:  945:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  946:
        -:  947:      //discard card from hand
    #####:  948:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  949:
        -:  950:      //discard trashed card
    #####:  951:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  952:	{
    #####:  953:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  954:	    {
    #####:  955:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  956:	      break;
        -:  957:	    }
        -:  958:	}
        -:  959:			
    #####:  960:      return 0;
        -:  961:			
        -:  962:    case remodel:
        -:  963:	
    #####:  964:		remodel_func(choice1, choice2, handPos, state);
call    0 never executed
        -:  965:		
        -:  966:		/* commented out code that is no longer needed due to refactoring
        -:  967:			
        -:  968:		  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  969:
        -:  970:		  if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  971:		{
        -:  972:		  return -1;
        -:  973:		}
        -:  974:
        -:  975:		  gainCard(choice2, state, 0, currentPlayer);
        -:  976:
        -:  977:		  //discard card from hand
        -:  978:		  discardCard(handPos, currentPlayer, state, 0);
        -:  979:
        -:  980:		  //discard trashed card
        -:  981:		  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  982:		{
        -:  983:		  if (state->hand[currentPlayer][i] == j)
        -:  984:			{
        -:  985:			  discardCard(i, currentPlayer, state, 0);			
        -:  986:			  break;
        -:  987:			}
        -:  988:		}
        -:  989:
        -:  990:		  return 0;
        -:  991:		*/
        -:  992:		
        -:  993:    case smithy:
        -:  994:	
    #####:  995:		smithy_func(handPos, state);
call    0 never executed
        -:  996:		
        -:  997:		/* commented out code that is no longer needed due to refactoring
        -:  998:			
        -:  999:		  //+3 Cards
        -: 1000:		  for (i = 0; i < 3; i++)
        -: 1001:		{
        -: 1002:		  drawCard(currentPlayer, state);
        -: 1003:		}
        -: 1004:				
        -: 1005:		  //discard card from hand
        -: 1006:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1007:		  return 0;
        -: 1008:		*/
        -: 1009:			
        -: 1010:    case village:
        -: 1011:	
    #####: 1012:		village_func(handPos, state);
call    0 never executed
        -: 1013:		
        -: 1014:		/* commented out code that is no longer needed due to refactoring
        -: 1015:			
        -: 1016:		  //+1 Card
        -: 1017:		  drawCard(currentPlayer, state);
        -: 1018:				
        -: 1019:		  //+2 Actions
        -: 1020:		  state->numActions = state->numActions + 2;
        -: 1021:				
        -: 1022:		  //discard played card from hand
        -: 1023:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1024:		  return 0;
        -: 1025:		*/
        -: 1026:		
        -: 1027:    case baron:
    #####: 1028:      state->numBuys++;//Increase buys by 1!
    #####: 1029:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####: 1030:	int p = 0;//Iterator for hand!
    #####: 1031:	int card_not_discarded = 1;//Flag for discard set!
    #####: 1032:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####: 1033:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####: 1034:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####: 1035:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1036:	    state->discardCount[currentPlayer]++;
    #####: 1037:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####: 1038:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -: 1039:	    }
    #####: 1040:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1041:	    state->handCount[currentPlayer]--;
    #####: 1042:	    card_not_discarded = 0;//Exit the loop
        -: 1043:	  }
    #####: 1044:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -: 1045:	    if(DEBUG) {
        -: 1046:	      printf("No estate cards in your hand, invalid choice\n");
        -: 1047:	      printf("Must gain an estate if there are any\n");
        -: 1048:	    }
    #####: 1049:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1050:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####: 1051:	      state->supplyCount[estate]--;//Decrement estates
    #####: 1052:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1053:		isGameOver(state);
call    0 never executed
        -: 1054:	      }
        -: 1055:	    }
    #####: 1056:	    card_not_discarded = 0;//Exit the loop
        -: 1057:	  }
        -: 1058:			    
        -: 1059:	  else{
    #####: 1060:	    p++;//Next card
        -: 1061:	  }
        -: 1062:	}
        -: 1063:      }
        -: 1064:			    
        -: 1065:      else{
    #####: 1066:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1067:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####: 1068:	  state->supplyCount[estate]--;//Decrement Estates
    #####: 1069:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1070:	    isGameOver(state);
call    0 never executed
        -: 1071:	  }
        -: 1072:	}
        -: 1073:      }
        -: 1074:	    
        -: 1075:      
    #####: 1076:      return 0;
        -: 1077:		
        -: 1078:    case great_hall:
        -: 1079:      //+1 Card
    #####: 1080:      drawCard(currentPlayer, state);
call    0 never executed
        -: 1081:			
        -: 1082:      //+1 Actions
    #####: 1083:      state->numActions++;
        -: 1084:			
        -: 1085:      //discard card from hand
    #####: 1086:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1087:      return 0;
        -: 1088:		
        -: 1089:    case minion:
        -: 1090:      //+1 action
    #####: 1091:      state->numActions++;
        -: 1092:			
        -: 1093:      //discard card from hand
    #####: 1094:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1095:			
    #####: 1096:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -: 1097:	{
    #####: 1098:	  state->coins = state->coins + 2;
        -: 1099:	}
        -: 1100:			
    #####: 1101:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -: 1102:	{
        -: 1103:	  //discard hand
    #####: 1104:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1105:	    {
    #####: 1106:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1107:	    }
        -: 1108:				
        -: 1109:	  //draw 4
    #####: 1110:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1111:	    {
    #####: 1112:	      drawCard(currentPlayer, state);
call    0 never executed
        -: 1113:	    }
        -: 1114:				
        -: 1115:	  //other players discard hand and redraw if hand size > 4
    #####: 1116:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1117:	    {
    #####: 1118:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1119:		{
    #####: 1120:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1121:		    {
        -: 1122:		      //discard hand
    #####: 1123:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1124:			{
    #####: 1125:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1126:			}
        -: 1127:							
        -: 1128:		      //draw 4
    #####: 1129:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1130:			{
    #####: 1131:			  drawCard(i, state);
call    0 never executed
        -: 1132:			}
        -: 1133:		    }
        -: 1134:		}
        -: 1135:	    }
        -: 1136:				
        -: 1137:	}
    #####: 1138:      return 0;
        -: 1139:		
        -: 1140:    case steward:
    #####: 1141:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1142:	{
        -: 1143:	  //+2 cards
    #####: 1144:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1145:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1146:	}
    #####: 1147:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1148:	{
        -: 1149:	  //+2 coins
    #####: 1150:	  state->coins = state->coins + 2;
        -: 1151:	}
        -: 1152:      else
        -: 1153:	{
        -: 1154:	  //trash 2 cards in hand
    #####: 1155:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1156:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1157:	}
        -: 1158:			
        -: 1159:      //discard card from hand
    #####: 1160:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1161:      return 0;
        -: 1162:		
        -: 1163:    case tribute:
    #####: 1164:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1165:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1166:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1167:	  state->deckCount[nextPlayer]--;
        -: 1168:	}
    #####: 1169:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1170:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1171:	  state->discardCount[nextPlayer]--;
        -: 1172:	}
        -: 1173:	else{
        -: 1174:	  //No Card to Reveal
        -: 1175:	  if (DEBUG){
        -: 1176:	    printf("No cards to reveal\n");
        -: 1177:	  }
        -: 1178:	}
        -: 1179:      }
        -: 1180:	    
        -: 1181:      else{
    #####: 1182:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1183:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1184:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1185:	    state->deckCount[nextPlayer]++;
    #####: 1186:	    state->discard[nextPlayer][i] = -1;
    #####: 1187:	    state->discardCount[nextPlayer]--;
        -: 1188:	  }
        -: 1189:			    
    #####: 1190:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1191:	} 
    #####: 1192:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1193:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1194:	state->deckCount[nextPlayer]--;
    #####: 1195:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1196:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1197:	state->deckCount[nextPlayer]--;
        -: 1198:      }    
        -: 1199:		       
    #####: 1200:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1201:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1202:	state->playedCardCount++;
    #####: 1203:	tributeRevealedCards[1] = -1;
        -: 1204:      }
        -: 1205:
    #####: 1206:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1207:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1208:	  state->coins += 2;
        -: 1209:	}
        -: 1210:		    
    #####: 1211:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1212:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1213:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1214:	}
        -: 1215:	else{//Action Card
    #####: 1216:	  state->numActions = state->numActions + 2;
        -: 1217:	}
        -: 1218:      }
        -: 1219:	    
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case ambassador:
    #####: 1223:      j = 0;		//used to check if player has enough cards to discard
        -: 1224:
    #####: 1225:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1226:	{
    #####: 1227:	  return -1;				
        -: 1228:	}
        -: 1229:
    #####: 1230:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1231:	{
    #####: 1232:	  return -1;
        -: 1233:	}
        -: 1234:
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1238:	    {
    #####: 1239:	      j++;
        -: 1240:	    }
        -: 1241:	}
    #####: 1242:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1243:	{
    #####: 1244:	  return -1;				
        -: 1245:	}
        -: 1246:
        -: 1247:      if (DEBUG) 
        -: 1248:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1249:
        -: 1250:      //increase supply count for choosen card by amount being discarded
    #####: 1251:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1252:			
        -: 1253:      //each other player gains a copy of revealed card
    #####: 1254:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:	{
    #####: 1256:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1257:	    {
    #####: 1258:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1259:	    }
        -: 1260:	}
        -: 1261:
        -: 1262:      //discard played card from hand
    #####: 1263:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1264:
        -: 1265:      //trash copies of cards returned to supply
    #####: 1266:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1267:	{
    #####: 1268:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1269:	    {
    #####: 1270:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1271:		{
    #####: 1272:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1273:		  break;
        -: 1274:		}
        -: 1275:	    }
        -: 1276:	}			
        -: 1277:
    #####: 1278:      return 0;
        -: 1279:		
        -: 1280:    case cutpurse:
        -: 1281:
    #####: 1282:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1283:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1284:	{
    #####: 1285:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1286:	    {
    #####: 1287:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1288:		{
    #####: 1289:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1290:		    {
    #####: 1291:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1292:		      break;
        -: 1293:		    }
    #####: 1294:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1295:		    {
    #####: 1296:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1297:			{
        -: 1298:			  if (DEBUG)
        -: 1299:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1300:			}	
    #####: 1301:		      break;
        -: 1302:		    }		
        -: 1303:		}
        -: 1304:					
        -: 1305:	    }
        -: 1306:				
        -: 1307:	}				
        -: 1308:
        -: 1309:      //discard played card from hand
    #####: 1310:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1311:
    #####: 1312:      return 0;
        -: 1313:
        -: 1314:		
        -: 1315:    case embargo: 
        -: 1316:      //+2 Coins
    #####: 1317:      state->coins = state->coins + 2;
        -: 1318:			
        -: 1319:      //see if selected pile is in play
    #####: 1320:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1321:	{
    #####: 1322:	  return -1;
        -: 1323:	}
        -: 1324:			
        -: 1325:      //add embargo token to selected supply pile
    #####: 1326:      state->embargoTokens[choice1]++;
        -: 1327:			
        -: 1328:      //trash card
    #####: 1329:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1330:      return 0;
        -: 1331:		
        -: 1332:    case outpost:
        -: 1333:      //set outpost flag
    #####: 1334:      state->outpostPlayed++;
        -: 1335:			
        -: 1336:      //discard card
    #####: 1337:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1338:      return 0;
        -: 1339:		
        -: 1340:    case salvager:
        -: 1341:      //+1 buy
    #####: 1342:      state->numBuys++;
        -: 1343:			
    #####: 1344:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1345:	{
        -: 1346:	  //gain coins equal to trashed card
    #####: 1347:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1348:	  //trash card
    #####: 1349:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1350:	}
        -: 1351:			
        -: 1352:      //discard card
    #####: 1353:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1354:      return 0;
        -: 1355:		
        -: 1356:    case sea_hag:
    #####: 1357:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1358:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1359:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1360:	  state->discardCount[i]++;
    #####: 1361:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1362:	}
        -: 1363:      }
    #####: 1364:      return 0;
        -: 1365:		
        -: 1366:    case treasure_map:
        -: 1367:      //search hand for another treasure_map
    #####: 1368:      index = -1;
    #####: 1369:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1370:	{
    #####: 1371:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1372:	    {
    #####: 1373:	      index = i;
    #####: 1374:	      break;
        -: 1375:	    }
        -: 1376:	}
    #####: 1377:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1378:	{
        -: 1379:	  //trash both treasure cards
    #####: 1380:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1381:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1382:
        -: 1383:	  //gain 4 Gold cards
    #####: 1384:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1385:	    {
    #####: 1386:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1387:	    }
        -: 1388:				
        -: 1389:	  //return success
    #####: 1390:	  return 1;
        -: 1391:	}
        -: 1392:			
        -: 1393:      //no second treasure_map found in hand
    #####: 1394:      return -1;
        -: 1395:    }
        -: 1396:	
    #####: 1397:  return -1;
        -: 1398:}
        -: 1399:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1400:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1401:{
        -: 1402:	
        -: 1403:  //if card is not trashed, added to Played pile 
    #####: 1404:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1405:    {
        -: 1406:      //add card to played pile
    #####: 1407:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1408:      state->playedCardCount++;
        -: 1409:    }
        -: 1410:	
        -: 1411:  //set played card to -1
    #####: 1412:  state->hand[currentPlayer][handPos] = -1;
        -: 1413:	
        -: 1414:  //remove card from player's hand
    #####: 1415:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1416:    {
        -: 1417:      //reduce number of cards in hand
    #####: 1418:      state->handCount[currentPlayer]--;
        -: 1419:    }
    #####: 1420:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1421:    {
        -: 1422:      //reduce number of cards in hand
    #####: 1423:      state->handCount[currentPlayer]--;
        -: 1424:    }
        -: 1425:  else 	
        -: 1426:    {
        -: 1427:      //replace discarded card with last card in hand
    #####: 1428:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1429:      //set last card to -1
    #####: 1430:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1431:      //reduce number of cards in hand
    #####: 1432:      state->handCount[currentPlayer]--;
        -: 1433:    }
        -: 1434:	
    #####: 1435:  return 0;
        -: 1436:}
        -: 1437:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1438:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1439:{
        -: 1440:  //Note: supplyPos is enum of choosen card
        -: 1441:	
        -: 1442:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1443:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1444:    {
    #####: 1445:      return -1;
        -: 1446:    }
        -: 1447:	
        -: 1448:  //added card for [whoseTurn] current player:
        -: 1449:  // toFlag = 0 : add to discard
        -: 1450:  // toFlag = 1 : add to deck
        -: 1451:  // toFlag = 2 : add to hand
        -: 1452:
    #####: 1453:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1454:    {
    #####: 1455:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1456:      state->deckCount[player]++;
        -: 1457:    }
    #####: 1458:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1459:    {
    #####: 1460:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1461:      state->handCount[player]++;
        -: 1462:    }
        -: 1463:  else
        -: 1464:    {
    #####: 1465:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1466:      state->discardCount[player]++;
        -: 1467:    }
        -: 1468:	
        -: 1469:  //decrease number in supply pile
    #####: 1470:  state->supplyCount[supplyPos]--;
        -: 1471:	 
    #####: 1472:  return 0;
        -: 1473:}
        -: 1474:
function updateCoins called 582 returned 100% blocks executed 100%
      582: 1475:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1476:{
        -: 1477:  int i;
        -: 1478:	
        -: 1479:  //reset coin count
      582: 1480:  state->coins = 0;
        -: 1481:
        -: 1482:  //add coins for each Treasure card in player's hand
     2832: 1483:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 79%
branch  1 taken 21% (fallthrough)
        -: 1484:    {
     2250: 1485:      if (state->hand[player][i] == copper)
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
        -: 1486:	{
     1256: 1487:	  state->coins += 1;
        -: 1488:	}
      994: 1489:      else if (state->hand[player][i] == silver)
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
        -: 1490:	{
      418: 1491:	  state->coins += 2;
        -: 1492:	}
      576: 1493:      else if (state->hand[player][i] == gold)
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
        -: 1494:	{
      374: 1495:	  state->coins += 3;
        -: 1496:	}	
        -: 1497:    }	
        -: 1498:
        -: 1499:  //add bonus
      582: 1500:  state->coins += bonus;
        -: 1501:
      582: 1502:  return 0;
        -: 1503:}
        -: 1504:
        -: 1505:
        -: 1506://end of dominion.c
        -: 1507:
unittest4.c:
Testing supplyCount function...
Checking the supplyCount function returns correct number in supply
------------------------------------------------------------------

Testing with 2 players 
------------------------

supplyCount(adventurer, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(council_room, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(feast, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(gardens, &G) = 8, expected: 8
Great! supplyCount function returned the correct supply count.

supplyCount(mine, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(remodel, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(smithy, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(village, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(baron, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(great_hall, &G) = 8, expected: 8
Great! supplyCount function returned the correct supply count.

supplyCount(estate, &G) = 8, expected: 8
Great! supplyCount function returned the correct supply count.

supplyCount(duchy, &G) = 8, expected: 8
Great! supplyCount function returned the correct supply count.

supplyCount(province, &G) = 8, expected: 8
Great! supplyCount function returned the correct supply count.

supplyCount(curse, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(gold, &G) = 30, expected: 30
Great! supplyCount function returned the correct supply count.

supplyCount(silver, &G) = 40, expected: 40
Great! supplyCount function returned the correct supply count.

supplyCount(silver, &G) = 40, expected: 40
Great! supplyCount function returned the correct supply count.

supplyCount(copper, &G) = 46, expected: 46
Great! supplyCount function returned the correct supply count.

Testing with 3 players 
------------------------

supplyCount(adventurer, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(council_room, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(feast, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(gardens, &G) = 12, expected: 12
Great! supplyCount function returned the correct supply count.

supplyCount(mine, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(remodel, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(smithy, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(village, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(baron, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(great_hall, &G) = 12, expected: 12
Great! supplyCount function returned the correct supply count.

supplyCount(estate, &G) = 12, expected: 12
Great! supplyCount function returned the correct supply count.

supplyCount(duchy, &G) = 12, expected: 12
Great! supplyCount function returned the correct supply count.

supplyCount(province, &G) = 12, expected: 12
Great! supplyCount function returned the correct supply count.

supplyCount(curse, &G) = 20, expected: 20
Great! supplyCount function returned the correct supply count.

supplyCount(gold, &G) = 30, expected: 30
Great! supplyCount function returned the correct supply count.

supplyCount(silver, &G) = 40, expected: 40
Great! supplyCount function returned the correct supply count.

supplyCount(silver, &G) = 40, expected: 40
Great! supplyCount function returned the correct supply count.

supplyCount(copper, &G) = 39, expected: 39
Great! supplyCount function returned the correct supply count.

Testing with 4 players 
------------------------

supplyCount(adventurer, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(council_room, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(feast, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(gardens, &G) = 12, expected: 12
Great! supplyCount function returned the correct supply count.

supplyCount(mine, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(remodel, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(smithy, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(village, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(baron, &G) = 10, expected: 10
Great! supplyCount function returned the correct supply count.

supplyCount(great_hall, &G) = 12, expected: 12
Great! supplyCount function returned the correct supply count.

supplyCount(estate, &G) = 12, expected: 12
Great! supplyCount function returned the correct supply count.

supplyCount(duchy, &G) = 12, expected: 12
Great! supplyCount function returned the correct supply count.

supplyCount(province, &G) = 12, expected: 12
Great! supplyCount function returned the correct supply count.

supplyCount(curse, &G) = 30, expected: 30
Great! supplyCount function returned the correct supply count.

supplyCount(gold, &G) = 30, expected: 30
Great! supplyCount function returned the correct supply count.

supplyCount(silver, &G) = 40, expected: 40
Great! supplyCount function returned the correct supply count.

supplyCount(silver, &G) = 40, expected: 40
Great! supplyCount function returned the correct supply count.

supplyCount(copper, &G) = 32, expected: 32
Great! supplyCount function returned the correct supply count.

supplyCount(copper, &G) = 5, expected: 5
Great! supplyCount function returned the correct supply count.

supplyCount(silver, &G) = 11, expected: 11
Great! supplyCount function returned the correct supply count.

supplyCount(estate, &G) = 3, expected: 3
Great! supplyCount function returned the correct supply count.

supplyCount(adventurer, &G) = 11, expected: 11
Great! supplyCount function returned the correct supply count.

supplyCount(smithy, &G) = 0, expected: 0
Great! supplyCount function returned the correct supply count.

supplyCount(curse, &G) = -1, expected: -1
Great! supplyCount function returned the correct supply count.

--------------------------------------------
Final Testing results of supplyCount function
-------------------------------------------
All tests passed for the supplyCount function!

File 'unittest4.c'
Lines executed:74.74% of 194
Branches executed:100.00% of 66
Taken at least once:62.12% of 66
Calls executed:77.06% of 109
Creating 'unittest4.c.gcov'

        -:    0:Source:unittest4.c
        -:    0:Graph:unittest4.gcno
        -:    0:Data:unittest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* -----------------------------------------------------------------------
        -:    2: * CS362-004 Summer 2017 Assignment 3
        -:    3: * unittest4.c
        -:    4: * 
        -:    5: * Patrick Kwong
        -:    6: * kwongp@oregonstate.edu
        -:    7: *
        -:    8: * Unit test for dominion function: supplyCount
        -:    9: * supplyCount returns the correct number in supply piles 
        -:   10: * -----------------------------------------------------------------------
        -:   11: * Include the following lines in the makefile:
        -:   12: *
        -:   13: * unittest4: unittest4.c dominion.o rngs.o
        -:   14: *      gcc -o unittest4 -g unittest4.c dominion.o rngs.o $(CFLAGS)
        -:   15: */
        -:   16:
        -:   17:#include "dominion.h"
        -:   18:#include "dominion_helpers.h"
        -:   19:#include "rngs.h"
        -:   20:#include <string.h>
        -:   21:#include <assert.h>
        -:   22:#include <stdio.h>
        -:   23:#include <stdlib.h>
        -:   24:#include <time.h>
        -:   25:#include <math.h>
        -:   26:
function main called 1 returned 100% blocks executed 73%
        1:   27:int main() 
        -:   28:{
        -:   29:    int count, seed, expected, i;
        1:   30:    int bugCount = 0;
        1:   31:    int numPlayer = 2;
        1:   32:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   33:               , remodel, smithy, village, baron, great_hall};
        -:   34:    struct gameState G;
        1:   35:    seed = (rand() % 100); // random seed
call    0 returned 100%
        -:   36: 
        1:   37:    printf("Testing supplyCount function...\n");
call    0 returned 100%
        1:   38:    printf("Checking the supplyCount function returns correct number in supply\n");
call    0 returned 100%
        1:   39:    printf("------------------------------------------------------------------\n\n");
call    0 returned 100%
        -:   40:
        4:   41:    for (i = 0; i < 3; i++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:   42:    {
        3:   43:        printf("Testing with %d players \n", numPlayer);
call    0 returned 100%
        3:   44:        printf("------------------------\n\n");
call    0 returned 100%
        -:   45:
        3:   46:        memset(&G, 23, sizeof(struct gameState));   // clear the game state
        3:   47:        initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:   48:
        -:   49:        // test number of supply piles after initializing game
        3:   50:        count = supplyCount(adventurer, &G);
call    0 returned 100%
        3:   51:        printf ("supplyCount(adventurer, &G) = %d, expected: 10\n", count);
call    0 returned 100%
        3:   52:        if(count == 10)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:   53:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:   54:        else{
    #####:   55:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:   56:            bugCount++;
        -:   57:        }
        -:   58:
        3:   59:        count = supplyCount(council_room, &G);
call    0 returned 100%
        3:   60:        printf ("supplyCount(council_room, &G) = %d, expected: 10\n", count);
call    0 returned 100%
        3:   61:        if(count == 10)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:   62:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:   63:        else{
    #####:   64:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:   65:            bugCount++;
        -:   66:        }
        -:   67:        
        3:   68:        count = supplyCount(feast, &G);
call    0 returned 100%
        3:   69:        printf ("supplyCount(feast, &G) = %d, expected: 10\n", count);
call    0 returned 100%
        3:   70:        if(count == 10)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:   71:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:   72:        else{
    #####:   73:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:   74:            bugCount++;
        -:   75:        }
        -:   76:        
        -:   77:        // rules = start supply for gardens 8 cards for 2 players, 12 for 3 or more players
        3:   78:        count = supplyCount(gardens, &G);
call    0 returned 100%
        3:   79:        if(numPlayer == 2) 
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:   80:            expected = 8;
        -:   81:        else
        2:   82:            expected = 12;
        3:   83:        printf ("supplyCount(gardens, &G) = %d, expected: %d\n", count, expected);
call    0 returned 100%
        3:   84:        if(count == expected)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:   85:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:   86:        else{
    #####:   87:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:   88:            bugCount++;
        -:   89:        }
        -:   90:        
        3:   91:        count = supplyCount(mine, &G);
call    0 returned 100%
        3:   92:        printf ("supplyCount(mine, &G) = %d, expected: 10\n", count);
call    0 returned 100%
        3:   93:        if(count == 10)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:   94:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:   95:        else{
    #####:   96:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:   97:            bugCount++;
        -:   98:        }
        -:   99:        
        3:  100:        count = supplyCount(remodel, &G);
call    0 returned 100%
        3:  101:        printf ("supplyCount(remodel, &G) = %d, expected: 10\n", count);
call    0 returned 100%
        3:  102:        if(count == 10)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  103:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  104:        else{
    #####:  105:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  106:            bugCount++;
        -:  107:        }
        -:  108:        
        3:  109:        count = supplyCount(smithy, &G);
call    0 returned 100%
        3:  110:        printf ("supplyCount(smithy, &G) = %d, expected: 10\n", count);
call    0 returned 100%
        3:  111:        if(count == 10)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  112:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  113:        else{
    #####:  114:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  115:            bugCount++;
        -:  116:        }
        -:  117:        
        3:  118:        count = supplyCount(village, &G);
call    0 returned 100%
        3:  119:        printf ("supplyCount(village, &G) = %d, expected: 10\n", count);
call    0 returned 100%
        3:  120:        if(count == 10)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  121:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  122:        else{
    #####:  123:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  124:            bugCount++;
        -:  125:        }
        -:  126:        
        3:  127:        count = supplyCount(baron, &G);
call    0 returned 100%
        3:  128:        printf ("supplyCount(baron, &G) = %d, expected: 10\n", count);
call    0 returned 100%
        3:  129:        if(count == 10)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  130:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  131:        else{
    #####:  132:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  133:            bugCount++;
        -:  134:        }
        -:  135:        
        -:  136:        // rules = start supply for great_hall 8 cards for 2 players, 12 for 3 or more players
        3:  137:        count = supplyCount(great_hall, &G);
call    0 returned 100%
        3:  138:        if(numPlayer == 2) 
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:  139:            expected = 8;
        -:  140:        else
        2:  141:            expected = 12;
        3:  142:        printf ("supplyCount(great_hall, &G) = %d, expected: %d\n", count, expected);
call    0 returned 100%
        3:  143:        if(count == expected)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  144:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  145:        else{
    #####:  146:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  147:            bugCount++;
        -:  148:        }
        -:  149:
        -:  150:        // rules = start supply for victory 8 cards for 2 players, 12 for 3 or more players
        3:  151:        count = supplyCount(estate, &G);
call    0 returned 100%
        3:  152:        if(numPlayer == 2) 
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:  153:            expected = 8;
        -:  154:        else
        2:  155:            expected = 12;
        3:  156:        printf ("supplyCount(estate, &G) = %d, expected: %d\n", count, expected);
call    0 returned 100%
        3:  157:        if(count == expected)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  158:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  159:        else{
    #####:  160:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  161:            bugCount++;
        -:  162:        }
        -:  163:
        -:  164:        // rules = start supply for victory 8 cards for 2 players, 12 for 3 or more players
        3:  165:        count = supplyCount(duchy, &G);
call    0 returned 100%
        3:  166:        if(numPlayer == 2) 
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:  167:            expected = 8;
        -:  168:        else
        2:  169:            expected = 12;
        3:  170:        printf ("supplyCount(duchy, &G) = %d, expected: %d\n", count, expected);
call    0 returned 100%
        3:  171:        if(count == expected)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  172:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  173:        else{
    #####:  174:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  175:            bugCount++;
        -:  176:        }
        -:  177:
        -:  178:        // rules = start supply for victory 8 cards for 2 players, 12 for 3 or more players
        3:  179:        count = supplyCount(province, &G);
call    0 returned 100%
        3:  180:        if(numPlayer == 2) 
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:  181:            expected = 8;
        -:  182:        else
        2:  183:            expected = 12;
        3:  184:        printf ("supplyCount(province, &G) = %d, expected: %d\n", count, expected);
call    0 returned 100%
        3:  185:        if(count == expected)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  186:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  187:        else{
    #####:  188:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  189:            bugCount++;
        -:  190:        }
        -:  191:
        -:  192:        // rules = start supply for curse 10 cards for 2 players, 20 for 3 players, 30 for 4 players
        3:  193:        count = supplyCount(curse, &G);
call    0 returned 100%
        3:  194:        if(numPlayer == 2) 
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:  195:            expected = 10;
        2:  196:        else if(numPlayer == 3) 
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  197:            expected = 20;
        -:  198:        else
        1:  199:            expected = 30;
        3:  200:        printf ("supplyCount(curse, &G) = %d, expected: %d\n", count, expected);
call    0 returned 100%
        3:  201:        if(count == expected)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  202:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  203:        else{
    #####:  204:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  205:            bugCount++;
        -:  206:        }
        -:  207:
        3:  208:        count = supplyCount(gold, &G);
call    0 returned 100%
        3:  209:        printf ("supplyCount(gold, &G) = %d, expected: 30\n", count);
call    0 returned 100%
        3:  210:        if(count == 30)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  211:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  212:        else{
    #####:  213:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  214:            bugCount++;
        -:  215:        }
        -:  216:
        3:  217:        count = supplyCount(silver, &G);
call    0 returned 100%
        3:  218:        printf ("supplyCount(silver, &G) = %d, expected: 40\n", count);
call    0 returned 100%
        3:  219:        if(count == 40)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  220:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  221:        else{
    #####:  222:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  223:            bugCount++;
        -:  224:        }
        -:  225:
        3:  226:        count = supplyCount(silver, &G);
call    0 returned 100%
        3:  227:        printf ("supplyCount(silver, &G) = %d, expected: 40\n", count);
call    0 returned 100%
        3:  228:        if(count == 40)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  229:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  230:        else{
    #####:  231:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  232:            bugCount++;
        -:  233:        }
        -:  234:
        -:  235:
        -:  236:        // rules = start supply for coppers is whatever is leftover after giving 7 coppers to each player from 60 total coppers in gmae
        3:  237:        count = supplyCount(copper, &G);
call    0 returned 100%
        3:  238:        expected = 60 - (7 * numPlayer);
        3:  239:        printf ("supplyCount(copper, &G) = %d, expected: %d\n", count, expected);
call    0 returned 100%
        3:  240:        if(count == expected)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  241:            printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  242:        else{
    #####:  243:            printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  244:            bugCount++;
        -:  245:        }
        3:  246:        numPlayer++;
        -:  247:        // dang i've pretty much tested the initializeGame...
        -:  248:    }
        -:  249:
        -:  250:    // some tests with manual changes to supplyCount
        1:  251:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:  252:    initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:  253:
        1:  254:    G.supplyCount[copper] = 5;
        1:  255:    count = supplyCount(copper, &G);
call    0 returned 100%
        1:  256:    printf ("supplyCount(copper, &G) = %d, expected: 5\n", count);
call    0 returned 100%
        1:  257:    if(count == 5)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  258:        printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  259:    else{
    #####:  260:        printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  261:        bugCount++;
        -:  262:    }
        -:  263:
        1:  264:    G.supplyCount[silver] = 11;
        1:  265:    count = supplyCount(silver, &G);
call    0 returned 100%
        1:  266:    printf ("supplyCount(silver, &G) = %d, expected: 11\n", count);
call    0 returned 100%
        1:  267:    if(count == 11)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  268:        printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  269:    else{
    #####:  270:        printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  271:        bugCount++;
        -:  272:    }
        -:  273:
        1:  274:    G.supplyCount[estate] = 3;
        1:  275:    count = supplyCount(estate, &G);
call    0 returned 100%
        1:  276:    printf ("supplyCount(estate, &G) = %d, expected: 3\n", count);
call    0 returned 100%
        1:  277:    if(count == 3)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  278:        printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  279:    else{
    #####:  280:        printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  281:        bugCount++;
        -:  282:    }
        -:  283:
        1:  284:    G.supplyCount[adventurer] = 11;
        1:  285:    count = supplyCount(adventurer, &G);
call    0 returned 100%
        1:  286:    printf ("supplyCount(adventurer, &G) = %d, expected: 11\n", count);
call    0 returned 100%
        1:  287:    if(count == 11)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  288:        printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  289:    else{
    #####:  290:        printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  291:        bugCount++;
        -:  292:    }
        -:  293:
        1:  294:    G.supplyCount[smithy] = 0;
        1:  295:    count = supplyCount(smithy, &G);
call    0 returned 100%
        1:  296:    printf ("supplyCount(smithy, &G) = %d, expected: 0\n", count);
call    0 returned 100%
        1:  297:    if(count == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  298:        printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  299:    else{
    #####:  300:        printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  301:        bugCount++;
        -:  302:    }
        -:  303:
        -:  304:    // probably shouldn't be able to set supply to -1
        1:  305:    G.supplyCount[curse] = -1;
        1:  306:    count = supplyCount(curse, &G);
call    0 returned 100%
        1:  307:    printf ("supplyCount(curse, &G) = %d, expected: -1\n", count);
call    0 returned 100%
        1:  308:    if(count == -1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  309:        printf("Great! supplyCount function returned the correct supply count.\n\n");
call    0 returned 100%
        -:  310:    else{
    #####:  311:        printf("BUG!!! supplyCount function returned the wrong supply count.\n\n");
call    0 never executed
    #####:  312:        bugCount++;
        -:  313:    }
        -:  314:    
        -:  315:    // output the test results overall
        1:  316:    printf("--------------------------------------------\n");
call    0 returned 100%
        1:  317:    printf("Final Testing results of supplyCount function\n");
call    0 returned 100%
        1:  318:    printf("-------------------------------------------\n");
call    0 returned 100%
        1:  319:    if(bugCount == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  320:        printf("All tests passed for the supplyCount function!\n\n");
call    0 returned 100%
        -:  321:    else
    #####:  322:        printf("supplyCount returned wrong supply count for %d condition(s), check above for which ones.\n\n", bugCount);
call    0 never executed
        -:  323:    
        1:  324:    return 0;
        -:  325:}
File 'dominion.c'
Lines executed:24.87% of 563
Branches executed:24.94% of 417
Taken at least once:23.26% of 417
Calls executed:7.00% of 100
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:4
        -:    0:Programs:4
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 5715 returned 100% blocks executed 83%
     5715:    8:int compare(const void* a, const void* b) {
     5715:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:    return 1;
     5715:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
     1524:   12:    return -1;
     4191:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 191 returned 100% blocks executed 97%
      191:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      191:   44:  SelectStream(1);
call    0 returned 100%
      191:   45:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:  
        -:   47:  //check number of players
      191:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:    {
        2:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      189:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     2079:   57:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:    {
    20790:   59:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:        {
    18900:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      189:   73:  if (numPlayers == 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   74:    {
      187:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
        2:   77:  else if (numPlayers == 3)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:   78:    {
        1:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
        1:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      189:   87:  if (numPlayers == 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   88:    {
      187:   89:      state->supplyCount[estate] = 8;
      187:   90:      state->supplyCount[duchy] = 8;
      187:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
        2:   95:      state->supplyCount[estate] = 12;
        2:   96:      state->supplyCount[duchy] = 12;
        2:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      189:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      189:  102:  state->supplyCount[silver] = 40;
      189:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
     3969:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:    {
    31185:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:	{
    29295:  110:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     1890:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
        -:  114:		{
      756:  115:		  if (numPlayers == 2){ 
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      374:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
        4:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     1512:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     1890:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    27405:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
      570:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:    {
      381:  140:      state->deckCount[i] = 0;
     1524:  141:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:	{
     1143:  143:	  state->deck[i][j] = estate;
     1143:  144:	  state->deckCount[i]++;
        -:  145:	}
     3048:  146:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:	{
     2667:  148:	  state->deck[i][j] = copper;
     2667:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
      570:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:    {
      381:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
      570:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      381:  166:      state->handCount[i] = 0;
      381:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
     5292:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:    {
     5103:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      189:  182:  state->outpostPlayed = 0;
      189:  183:  state->phase = 0;
      189:  184:  state->numActions = 1;
      189:  185:  state->numBuys = 1;
      189:  186:  state->playedCardCount = 0;
      189:  187:  state->whoseTurn = 0;
      189:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     1134:  192:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      945:  193:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:  }
        -:  195:
      189:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
      189:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 381 returned 100% blocks executed 94%
      381:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
      381:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
      381:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  210:    return -1;
      381:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     4572:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     3810:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     3810:  216:    newDeck[newDeckPos] = state->deck[player][card];
     3810:  217:    newDeckPos++;
    14228:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 73%
branch  1 taken 27% (fallthrough)
    10418:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
     3810:  221:    state->deckCount[player]--;
        -:  222:  }
     4191:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     3810:  224:    state->deck[player][i] = newDeck[i];
     3810:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
      381:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 60 returned 100% blocks executed 100%
       60:  320:int supplyCount(int card, struct gameState *state) {
       60:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 0 returned 0% blocks executed 0%
    #####:  346:int whoseTurn(struct gameState *state) {
    #####:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 11 returned 100% blocks executed 100%
       11:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
       11:  395:  if (state->supplyCount[province] == 0)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
        -:  396:    {
        3:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
        8:  401:  j = 0;
      208:  402:  for (i = 0; i < 25; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  403:    {
      200:  404:      if (state->supplyCount[i] == 0)
branch  0 taken 9% (fallthrough)
branch  1 taken 92%
        -:  405:	{
       17:  406:	  j++;
        -:  407:	}
        -:  408:    }
        8:  409:  if ( j >= 3)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  410:    {
        4:  411:      return 1;
        -:  412:    }
        -:  413:
        4:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 945 returned 100% blocks executed 38%
      945:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
      945:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
      945:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
      945:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
      945:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      945:  576:    state->deckCount[player]--;
      945:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
      945:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 27 returned 100% blocks executed 97%
       27:  583:int getCost(int cardNumber)
        -:  584:{
       27:  585:  switch( cardNumber ) 
branch  0 taken 4%
branch  1 taken 4%
branch  2 taken 4%
branch  3 taken 4%
branch  4 taken 4%
branch  5 taken 4%
branch  6 taken 4%
branch  7 taken 4%
branch  8 taken 4%
branch  9 taken 4%
branch 10 taken 4%
branch 11 taken 4%
branch 12 taken 4%
branch 13 taken 4%
branch 14 taken 4%
branch 15 taken 4%
branch 16 taken 4%
branch 17 taken 4%
branch 18 taken 4%
branch 19 taken 4%
branch 20 taken 4%
branch 21 taken 4%
branch 22 taken 4%
branch 23 taken 4%
branch 24 taken 4%
branch 25 taken 4%
branch 26 taken 4%
branch 27 taken 0%
        -:  586:    {
        -:  587:    case curse:
        1:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        1:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        1:  608:      return 4;
        -:  609:    case mine:
        1:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        1:  614:      return 4;
        -:  615:    case village:
        1:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        1:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        1:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        1:  630:      return 4;
        -:  631:    case embargo: 
        1:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        1:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:// Assignment 2 - refactor card #1: Adventurer
function adventurer_func called 0 returned 0% blocks executed 0%
    #####:  647:int adventurer_func(struct gameState *state)
        -:  648:{
        -:  649:	int cardDrawn;
    #####:  650:	int currentPlayer = whoseTurn(state);	
call    0 never executed
    #####:  651:	int drawntreasure = 0;
        -:  652:	int temphand[MAX_HAND];// moved above the if statement
    #####:  653:	int z = 0;// this is the counter for the temp hand
        -:  654:    
    #####:  655:	while(drawntreasure <= 2) // BUG added!! - Changed to < to <= that what it could end up drawing extra treasure.
branch  0 never executed
branch  1 never executed
        -:  656:	{
        -:  657:		//if the deck is empty we need to shuffle discard and add to deck
    #####:  658:		if (state->deckCount[currentPlayer] <1)
branch  0 never executed
branch  1 never executed
    #####:  659:			shuffle(currentPlayer, state);
call    0 never executed
        -:  660:		
    #####:  661:		drawCard(currentPlayer, state);
call    0 never executed
        -:  662:		
        -:  663:			//top card of hand is most recently drawn card.
    #####:  664:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  665:	
    #####:  666:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  667:				drawntreasure++;
        -:  668:			else
        -:  669:			{
    #####:  670:				temphand[z] = cardDrawn;
        -:  671:				
        -:  672:				//this should just remove the top card (the most recently drawn one).
    #####:  673:				state->handCount[currentPlayer]--; 
    #####:  674:				z++;
        -:  675:			}
        -:  676:		}
        -:  677:      
    #####:  678:		while(z - 1 >= 0)
branch  0 never executed
branch  1 never executed
        -:  679:		{
        -:  680:			// discard all cards in play that have been drawn
    #####:  681:			state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; 
    #####:  682:			z = z - 1;
        -:  683:		}
        -:  684:		
    #####:  685:		return 0;
        -:  686:}
        -:  687:
        -:  688:// Assignment 2 - refactor card #2: Council Room
function council_room_func called 0 returned 0% blocks executed 0%
    #####:  689:int council_room_func(int handPos, struct gameState *state)
        -:  690:{
        -:  691:	int i;
    #####:  692:	int currentPlayer = whoseTurn(state);	
call    0 never executed
        -:  693:	
        -:  694:	//+4 Cards
    #####:  695:	for (i = 1; i < 4; i++) // BUG added!!! = changed i=0 to i=1, which will result in 1 less card drawn.
branch  0 never executed
branch  1 never executed
    #####:  696:		drawCard(currentPlayer, state);
call    0 never executed
        -:  697:
        -:  698:	//+1 Buy
    #####:  699:	state->numBuys++;
        -:  700:	
        -:  701:	//Each other player draws a card
    #####:  702:	for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
    #####:  703:		if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
    #####:  704:			drawCard(i, state);
call    0 never executed
        -:  705:
        -:  706:	//put played card in played card pile
    #####:  707:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  708:
    #####:  709:	return 0;
        -:  710:}
        -:  711:
        -:  712:
        -:  713:// Assignment 2 - refactor card #3: Remodel
function remodel_func called 0 returned 0% blocks executed 0%
    #####:  714:int remodel_func(int choice1, int choice2, int handPos, struct gameState *state)
        -:  715:{
        -:  716:	int i;
        -:  717:	int j;
    #####:  718:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  719:    
    #####:  720:	j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  721:
    #####:  722:	if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  723:		return -1;
        -:  724:
    #####:  725:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  726:
        -:  727:	//discard card from hand
    #####:  728:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  729:
        -:  730:	//discard trashed card
    #####:  731:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  732:	{
    #####:  733:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  734:	    {
    #####:  735:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  736:			break;
        -:  737:	    }
        -:  738:	}
        -:  739:	
    #####:  740:	return 0;
        -:  741:}
        -:  742:
        -:  743:// Assignment 2 - refactor card #4: Smithy
function smithy_func called 0 returned 0% blocks executed 0%
    #####:  744:int smithy_func(int handPos, struct gameState *state)
        -:  745:{
        -:  746:	int i;
    #####:  747:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  748:	
        -:  749:	//+3 Cards
    #####:  750:	for (i = 0; i <= 3; i++) // BUG added!!! = changed < to <=, which will result in 1 more card drawn.
branch  0 never executed
branch  1 never executed
    #####:  751:		drawCard(currentPlayer, state);
call    0 never executed
        -:  752:
        -:  753:	//discard card from hand
    #####:  754:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  755:	
    #####:  756:	return 0;
        -:  757:}
        -:  758:
        -:  759:// Assignment 2 - refactor card #5: Village
function village_func called 0 returned 0% blocks executed 0%
    #####:  760:int village_func(int handPos, struct gameState *state)
        -:  761:{
    #####:  762:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  763:	
        -:  764:	//+1 Card
    #####:  765:	drawCard(currentPlayer, state);
call    0 never executed
        -:  766:			
        -:  767:	//+2 Actions
    #####:  768:	state->numActions = state->numActions + 22; // BUG added!!! = changed 2 to 22, which will result in +22 actions instead of just 2.
        -:  769:			
        -:  770:	//discard played card from hand
    #####:  771:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  772:
    #####:  773:	return 0;
        -:  774:}
        -:  775:
        -:  776:// cardEffect - for assignment 2 - I refactored 5 of these cards (adventurer, 
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  777:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  778:{
        -:  779:  int i;
        -:  780:  int j;
        -:  781:  int k;
        -:  782:  int x;
        -:  783:  int index;
    #####:  784:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  785:  int nextPlayer = currentPlayer + 1;
        -:  786:
    #####:  787:  int tributeRevealedCards[2] = {-1, -1};
        -:  788:  int temphand[MAX_HAND];// moved above the if statement
        -:  789:
    #####:  790:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  791:    nextPlayer = 0;
        -:  792:  }
        -:  793:  
        -:  794:  /* these variables are no longer needed after refactoring
        -:  795:  
        -:  796:    int drawntreasure=0;
        -:  797:	int cardDrawn;
        -:  798:	int z = 0;// this is the counter for the temp hand
        -:  799:	*/
        -:  800:	
        -:  801:  //uses switch to select card and perform actions
    #####:  802:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  803:    {
        -:  804:    case adventurer:
        -:  805:	
    #####:  806:		adventurer_func(state);
call    0 never executed
        -:  807:		
        -:  808:		/* commented out code that is no longer needed due to refactoring
        -:  809:		while(drawntreasure<2)
        -:  810:		{
        -:  811:			//if the deck is empty we need to shuffle discard and add to deck
        -:  812:			if (state->deckCount[currentPlayer] <1)
        -:  813:				shuffle(currentPlayer, state);
        -:  814:		
        -:  815:			drawCard(currentPlayer, state);
        -:  816:		
        -:  817:			//top card of hand is most recently drawn card.
        -:  818:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  819:	
        -:  820:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:  821:				drawntreasure++;
        -:  822:			else
        -:  823:			{
        -:  824:				temphand[z]=cardDrawn;
        -:  825:				
        -:  826:				//this should just remove the top card (the most recently drawn one).
        -:  827:				state->handCount[currentPlayer]--; 
        -:  828:				z++;
        -:  829:			}
        -:  830:		}
        -:  831:      
        -:  832:		while(z-1>=0)
        -:  833:		{
        -:  834:			// discard all cards in play that have been drawn
        -:  835:			state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; 
        -:  836:			z=z-1;
        -:  837:		}
        -:  838:		return 0;
        -:  839:		*/
        -:  840:	
        -:  841:    case council_room:
        -:  842:		
    #####:  843:		council_room_func(handPos, state);
call    0 never executed
        -:  844:		
        -:  845:		/* commented out code that is no longer needed due to refactoring
        -:  846:		
        -:  847:		//+4 Cards
        -:  848:		  for (i = 0; i < 4; i++)
        -:  849:		{
        -:  850:		  drawCard(currentPlayer, state);
        -:  851:		}
        -:  852:				
        -:  853:		  //+1 Buy
        -:  854:		  state->numBuys++;
        -:  855:				
        -:  856:		  //Each other player draws a card
        -:  857:		  for (i = 0; i < state->numPlayers; i++)
        -:  858:		{
        -:  859:		  if ( i != currentPlayer )
        -:  860:			{
        -:  861:			  drawCard(i, state);
        -:  862:			}
        -:  863:		}
        -:  864:				
        -:  865:		  //put played card in played card pile
        -:  866:		  discardCard(handPos, currentPlayer, state, 0);
        -:  867:				
        -:  868:		  return 0;
        -:  869:		*/
        -:  870:		
        -:  871:    case feast:
        -:  872:      //gain card with cost up to 5
        -:  873:      //Backup hand
    #####:  874:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  875:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  876:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  877:      }
        -:  878:      //Backup hand
        -:  879:
        -:  880:      //Update Coins for Buy
    #####:  881:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  882:      x = 1;//Condition to loop on
    #####:  883:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  884:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  885:	  if (DEBUG)
        -:  886:	    printf("None of that card left, sorry!\n");
        -:  887:
        -:  888:	  if (DEBUG){
        -:  889:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  890:	  }
        -:  891:	}
    #####:  892:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  893:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  894:
        -:  895:	  if (DEBUG){
        -:  896:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  897:	  }
        -:  898:	}
        -:  899:	else{
        -:  900:
        -:  901:	  if (DEBUG){
        -:  902:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  903:	  }
        -:  904:
    #####:  905:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  906:	  x = 0;//No more buying cards
        -:  907:
        -:  908:	  if (DEBUG){
        -:  909:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  910:	  }
        -:  911:
        -:  912:	}
        -:  913:      }     
        -:  914:
        -:  915:      //Reset Hand
    #####:  916:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  917:	state->hand[currentPlayer][i] = temphand[i];
    #####:  918:	temphand[i] = -1;
        -:  919:      }
        -:  920:      //Reset Hand
        -:  921:      			
    #####:  922:      return 0;
        -:  923:			
        -:  924:    case gardens:
    #####:  925:      return -1;
        -:  926:			
        -:  927:    case mine:
    #####:  928:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  929:
    #####:  930:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  931:	{
    #####:  932:	  return -1;
        -:  933:	}
        -:  934:		
    #####:  935:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  936:	{
    #####:  937:	  return -1;
        -:  938:	}
        -:  939:
    #####:  940:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  941:	{
    #####:  942:	  return -1;
        -:  943:	}
        -:  944:
    #####:  945:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  946:
        -:  947:      //discard card from hand
    #####:  948:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  949:
        -:  950:      //discard trashed card
    #####:  951:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  952:	{
    #####:  953:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  954:	    {
    #####:  955:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  956:	      break;
        -:  957:	    }
        -:  958:	}
        -:  959:			
    #####:  960:      return 0;
        -:  961:			
        -:  962:    case remodel:
        -:  963:	
    #####:  964:		remodel_func(choice1, choice2, handPos, state);
call    0 never executed
        -:  965:		
        -:  966:		/* commented out code that is no longer needed due to refactoring
        -:  967:			
        -:  968:		  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  969:
        -:  970:		  if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  971:		{
        -:  972:		  return -1;
        -:  973:		}
        -:  974:
        -:  975:		  gainCard(choice2, state, 0, currentPlayer);
        -:  976:
        -:  977:		  //discard card from hand
        -:  978:		  discardCard(handPos, currentPlayer, state, 0);
        -:  979:
        -:  980:		  //discard trashed card
        -:  981:		  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  982:		{
        -:  983:		  if (state->hand[currentPlayer][i] == j)
        -:  984:			{
        -:  985:			  discardCard(i, currentPlayer, state, 0);			
        -:  986:			  break;
        -:  987:			}
        -:  988:		}
        -:  989:
        -:  990:		  return 0;
        -:  991:		*/
        -:  992:		
        -:  993:    case smithy:
        -:  994:	
    #####:  995:		smithy_func(handPos, state);
call    0 never executed
        -:  996:		
        -:  997:		/* commented out code that is no longer needed due to refactoring
        -:  998:			
        -:  999:		  //+3 Cards
        -: 1000:		  for (i = 0; i < 3; i++)
        -: 1001:		{
        -: 1002:		  drawCard(currentPlayer, state);
        -: 1003:		}
        -: 1004:				
        -: 1005:		  //discard card from hand
        -: 1006:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1007:		  return 0;
        -: 1008:		*/
        -: 1009:			
        -: 1010:    case village:
        -: 1011:	
    #####: 1012:		village_func(handPos, state);
call    0 never executed
        -: 1013:		
        -: 1014:		/* commented out code that is no longer needed due to refactoring
        -: 1015:			
        -: 1016:		  //+1 Card
        -: 1017:		  drawCard(currentPlayer, state);
        -: 1018:				
        -: 1019:		  //+2 Actions
        -: 1020:		  state->numActions = state->numActions + 2;
        -: 1021:				
        -: 1022:		  //discard played card from hand
        -: 1023:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1024:		  return 0;
        -: 1025:		*/
        -: 1026:		
        -: 1027:    case baron:
    #####: 1028:      state->numBuys++;//Increase buys by 1!
    #####: 1029:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####: 1030:	int p = 0;//Iterator for hand!
    #####: 1031:	int card_not_discarded = 1;//Flag for discard set!
    #####: 1032:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####: 1033:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####: 1034:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####: 1035:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1036:	    state->discardCount[currentPlayer]++;
    #####: 1037:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####: 1038:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -: 1039:	    }
    #####: 1040:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1041:	    state->handCount[currentPlayer]--;
    #####: 1042:	    card_not_discarded = 0;//Exit the loop
        -: 1043:	  }
    #####: 1044:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -: 1045:	    if(DEBUG) {
        -: 1046:	      printf("No estate cards in your hand, invalid choice\n");
        -: 1047:	      printf("Must gain an estate if there are any\n");
        -: 1048:	    }
    #####: 1049:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1050:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####: 1051:	      state->supplyCount[estate]--;//Decrement estates
    #####: 1052:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1053:		isGameOver(state);
call    0 never executed
        -: 1054:	      }
        -: 1055:	    }
    #####: 1056:	    card_not_discarded = 0;//Exit the loop
        -: 1057:	  }
        -: 1058:			    
        -: 1059:	  else{
    #####: 1060:	    p++;//Next card
        -: 1061:	  }
        -: 1062:	}
        -: 1063:      }
        -: 1064:			    
        -: 1065:      else{
    #####: 1066:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1067:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####: 1068:	  state->supplyCount[estate]--;//Decrement Estates
    #####: 1069:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1070:	    isGameOver(state);
call    0 never executed
        -: 1071:	  }
        -: 1072:	}
        -: 1073:      }
        -: 1074:	    
        -: 1075:      
    #####: 1076:      return 0;
        -: 1077:		
        -: 1078:    case great_hall:
        -: 1079:      //+1 Card
    #####: 1080:      drawCard(currentPlayer, state);
call    0 never executed
        -: 1081:			
        -: 1082:      //+1 Actions
    #####: 1083:      state->numActions++;
        -: 1084:			
        -: 1085:      //discard card from hand
    #####: 1086:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1087:      return 0;
        -: 1088:		
        -: 1089:    case minion:
        -: 1090:      //+1 action
    #####: 1091:      state->numActions++;
        -: 1092:			
        -: 1093:      //discard card from hand
    #####: 1094:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1095:			
    #####: 1096:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -: 1097:	{
    #####: 1098:	  state->coins = state->coins + 2;
        -: 1099:	}
        -: 1100:			
    #####: 1101:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -: 1102:	{
        -: 1103:	  //discard hand
    #####: 1104:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1105:	    {
    #####: 1106:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1107:	    }
        -: 1108:				
        -: 1109:	  //draw 4
    #####: 1110:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1111:	    {
    #####: 1112:	      drawCard(currentPlayer, state);
call    0 never executed
        -: 1113:	    }
        -: 1114:				
        -: 1115:	  //other players discard hand and redraw if hand size > 4
    #####: 1116:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1117:	    {
    #####: 1118:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1119:		{
    #####: 1120:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1121:		    {
        -: 1122:		      //discard hand
    #####: 1123:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1124:			{
    #####: 1125:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1126:			}
        -: 1127:							
        -: 1128:		      //draw 4
    #####: 1129:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1130:			{
    #####: 1131:			  drawCard(i, state);
call    0 never executed
        -: 1132:			}
        -: 1133:		    }
        -: 1134:		}
        -: 1135:	    }
        -: 1136:				
        -: 1137:	}
    #####: 1138:      return 0;
        -: 1139:		
        -: 1140:    case steward:
    #####: 1141:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1142:	{
        -: 1143:	  //+2 cards
    #####: 1144:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1145:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1146:	}
    #####: 1147:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1148:	{
        -: 1149:	  //+2 coins
    #####: 1150:	  state->coins = state->coins + 2;
        -: 1151:	}
        -: 1152:      else
        -: 1153:	{
        -: 1154:	  //trash 2 cards in hand
    #####: 1155:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1156:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1157:	}
        -: 1158:			
        -: 1159:      //discard card from hand
    #####: 1160:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1161:      return 0;
        -: 1162:		
        -: 1163:    case tribute:
    #####: 1164:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1165:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1166:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1167:	  state->deckCount[nextPlayer]--;
        -: 1168:	}
    #####: 1169:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1170:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1171:	  state->discardCount[nextPlayer]--;
        -: 1172:	}
        -: 1173:	else{
        -: 1174:	  //No Card to Reveal
        -: 1175:	  if (DEBUG){
        -: 1176:	    printf("No cards to reveal\n");
        -: 1177:	  }
        -: 1178:	}
        -: 1179:      }
        -: 1180:	    
        -: 1181:      else{
    #####: 1182:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1183:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1184:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1185:	    state->deckCount[nextPlayer]++;
    #####: 1186:	    state->discard[nextPlayer][i] = -1;
    #####: 1187:	    state->discardCount[nextPlayer]--;
        -: 1188:	  }
        -: 1189:			    
    #####: 1190:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1191:	} 
    #####: 1192:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1193:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1194:	state->deckCount[nextPlayer]--;
    #####: 1195:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1196:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1197:	state->deckCount[nextPlayer]--;
        -: 1198:      }    
        -: 1199:		       
    #####: 1200:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1201:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1202:	state->playedCardCount++;
    #####: 1203:	tributeRevealedCards[1] = -1;
        -: 1204:      }
        -: 1205:
    #####: 1206:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1207:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1208:	  state->coins += 2;
        -: 1209:	}
        -: 1210:		    
    #####: 1211:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1212:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1213:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1214:	}
        -: 1215:	else{//Action Card
    #####: 1216:	  state->numActions = state->numActions + 2;
        -: 1217:	}
        -: 1218:      }
        -: 1219:	    
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case ambassador:
    #####: 1223:      j = 0;		//used to check if player has enough cards to discard
        -: 1224:
    #####: 1225:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1226:	{
    #####: 1227:	  return -1;				
        -: 1228:	}
        -: 1229:
    #####: 1230:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1231:	{
    #####: 1232:	  return -1;
        -: 1233:	}
        -: 1234:
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1238:	    {
    #####: 1239:	      j++;
        -: 1240:	    }
        -: 1241:	}
    #####: 1242:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1243:	{
    #####: 1244:	  return -1;				
        -: 1245:	}
        -: 1246:
        -: 1247:      if (DEBUG) 
        -: 1248:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1249:
        -: 1250:      //increase supply count for choosen card by amount being discarded
    #####: 1251:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1252:			
        -: 1253:      //each other player gains a copy of revealed card
    #####: 1254:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:	{
    #####: 1256:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1257:	    {
    #####: 1258:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1259:	    }
        -: 1260:	}
        -: 1261:
        -: 1262:      //discard played card from hand
    #####: 1263:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1264:
        -: 1265:      //trash copies of cards returned to supply
    #####: 1266:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1267:	{
    #####: 1268:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1269:	    {
    #####: 1270:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1271:		{
    #####: 1272:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1273:		  break;
        -: 1274:		}
        -: 1275:	    }
        -: 1276:	}			
        -: 1277:
    #####: 1278:      return 0;
        -: 1279:		
        -: 1280:    case cutpurse:
        -: 1281:
    #####: 1282:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1283:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1284:	{
    #####: 1285:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1286:	    {
    #####: 1287:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1288:		{
    #####: 1289:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1290:		    {
    #####: 1291:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1292:		      break;
        -: 1293:		    }
    #####: 1294:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1295:		    {
    #####: 1296:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1297:			{
        -: 1298:			  if (DEBUG)
        -: 1299:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1300:			}	
    #####: 1301:		      break;
        -: 1302:		    }		
        -: 1303:		}
        -: 1304:					
        -: 1305:	    }
        -: 1306:				
        -: 1307:	}				
        -: 1308:
        -: 1309:      //discard played card from hand
    #####: 1310:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1311:
    #####: 1312:      return 0;
        -: 1313:
        -: 1314:		
        -: 1315:    case embargo: 
        -: 1316:      //+2 Coins
    #####: 1317:      state->coins = state->coins + 2;
        -: 1318:			
        -: 1319:      //see if selected pile is in play
    #####: 1320:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1321:	{
    #####: 1322:	  return -1;
        -: 1323:	}
        -: 1324:			
        -: 1325:      //add embargo token to selected supply pile
    #####: 1326:      state->embargoTokens[choice1]++;
        -: 1327:			
        -: 1328:      //trash card
    #####: 1329:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1330:      return 0;
        -: 1331:		
        -: 1332:    case outpost:
        -: 1333:      //set outpost flag
    #####: 1334:      state->outpostPlayed++;
        -: 1335:			
        -: 1336:      //discard card
    #####: 1337:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1338:      return 0;
        -: 1339:		
        -: 1340:    case salvager:
        -: 1341:      //+1 buy
    #####: 1342:      state->numBuys++;
        -: 1343:			
    #####: 1344:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1345:	{
        -: 1346:	  //gain coins equal to trashed card
    #####: 1347:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1348:	  //trash card
    #####: 1349:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1350:	}
        -: 1351:			
        -: 1352:      //discard card
    #####: 1353:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1354:      return 0;
        -: 1355:		
        -: 1356:    case sea_hag:
    #####: 1357:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1358:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1359:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1360:	  state->discardCount[i]++;
    #####: 1361:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1362:	}
        -: 1363:      }
    #####: 1364:      return 0;
        -: 1365:		
        -: 1366:    case treasure_map:
        -: 1367:      //search hand for another treasure_map
    #####: 1368:      index = -1;
    #####: 1369:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1370:	{
    #####: 1371:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1372:	    {
    #####: 1373:	      index = i;
    #####: 1374:	      break;
        -: 1375:	    }
        -: 1376:	}
    #####: 1377:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1378:	{
        -: 1379:	  //trash both treasure cards
    #####: 1380:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1381:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1382:
        -: 1383:	  //gain 4 Gold cards
    #####: 1384:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1385:	    {
    #####: 1386:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1387:	    }
        -: 1388:				
        -: 1389:	  //return success
    #####: 1390:	  return 1;
        -: 1391:	}
        -: 1392:			
        -: 1393:      //no second treasure_map found in hand
    #####: 1394:      return -1;
        -: 1395:    }
        -: 1396:	
    #####: 1397:  return -1;
        -: 1398:}
        -: 1399:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1400:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1401:{
        -: 1402:	
        -: 1403:  //if card is not trashed, added to Played pile 
    #####: 1404:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1405:    {
        -: 1406:      //add card to played pile
    #####: 1407:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1408:      state->playedCardCount++;
        -: 1409:    }
        -: 1410:	
        -: 1411:  //set played card to -1
    #####: 1412:  state->hand[currentPlayer][handPos] = -1;
        -: 1413:	
        -: 1414:  //remove card from player's hand
    #####: 1415:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1416:    {
        -: 1417:      //reduce number of cards in hand
    #####: 1418:      state->handCount[currentPlayer]--;
        -: 1419:    }
    #####: 1420:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1421:    {
        -: 1422:      //reduce number of cards in hand
    #####: 1423:      state->handCount[currentPlayer]--;
        -: 1424:    }
        -: 1425:  else 	
        -: 1426:    {
        -: 1427:      //replace discarded card with last card in hand
    #####: 1428:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1429:      //set last card to -1
    #####: 1430:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1431:      //reduce number of cards in hand
    #####: 1432:      state->handCount[currentPlayer]--;
        -: 1433:    }
        -: 1434:	
    #####: 1435:  return 0;
        -: 1436:}
        -: 1437:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1438:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1439:{
        -: 1440:  //Note: supplyPos is enum of choosen card
        -: 1441:	
        -: 1442:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1443:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1444:    {
    #####: 1445:      return -1;
        -: 1446:    }
        -: 1447:	
        -: 1448:  //added card for [whoseTurn] current player:
        -: 1449:  // toFlag = 0 : add to discard
        -: 1450:  // toFlag = 1 : add to deck
        -: 1451:  // toFlag = 2 : add to hand
        -: 1452:
    #####: 1453:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1454:    {
    #####: 1455:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1456:      state->deckCount[player]++;
        -: 1457:    }
    #####: 1458:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1459:    {
    #####: 1460:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1461:      state->handCount[player]++;
        -: 1462:    }
        -: 1463:  else
        -: 1464:    {
    #####: 1465:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1466:      state->discardCount[player]++;
        -: 1467:    }
        -: 1468:	
        -: 1469:  //decrease number in supply pile
    #####: 1470:  state->supplyCount[supplyPos]--;
        -: 1471:	 
    #####: 1472:  return 0;
        -: 1473:}
        -: 1474:
function updateCoins called 585 returned 100% blocks executed 100%
      585: 1475:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1476:{
        -: 1477:  int i;
        -: 1478:	
        -: 1479:  //reset coin count
      585: 1480:  state->coins = 0;
        -: 1481:
        -: 1482:  //add coins for each Treasure card in player's hand
     2850: 1483:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 79%
branch  1 taken 21% (fallthrough)
        -: 1484:    {
     2265: 1485:      if (state->hand[player][i] == copper)
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
        -: 1486:	{
     1271: 1487:	  state->coins += 1;
        -: 1488:	}
      994: 1489:      else if (state->hand[player][i] == silver)
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
        -: 1490:	{
      418: 1491:	  state->coins += 2;
        -: 1492:	}
      576: 1493:      else if (state->hand[player][i] == gold)
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
        -: 1494:	{
      374: 1495:	  state->coins += 3;
        -: 1496:	}	
        -: 1497:    }	
        -: 1498:
        -: 1499:  //add bonus
      585: 1500:  state->coins += bonus;
        -: 1501:
      585: 1502:  return 0;
        -: 1503:}
        -: 1504:
        -: 1505:
        -: 1506://end of dominion.c
        -: 1507:
cardtest1.c:

Testing refactored adventurer card function
-------------------------------------------

Checking if correct number of cards after using refactored adventurer card .
Previous hand count: 6, After Adventurer: 8
Expected hand count after Adventurer: 7 (+1 = +2 drawn from Adventurer and -1 from discarding Adventurer.
Bug!!! Ended with the incorrect number of cards in hand after Adventurer.

Checking if refactored adventurer card adds only treasure cards to hand.
Great! Adventurer added only treasure cards to hand.

Checking if refactored adventurer card drew enough cards to hand.
Great! Adventurer drew enough cards from deck.

Checking if refactored adventurer card discarded correct number of cards to hand.
Previous deck count: 5 cards, After Adventurer: 0 cards
Previous discard count: 0 cards, After Adventurer: 3 cards
Expected deck count after Adventurer: 3 card.
Great! Adventurer discarded the correct number of cards to hand.

Checking if refactored adventurer card altered other player's hand.
Great! Adventurer didn't alter other player's cards.

Checking if refactored adventurer card altered the Victory and Kingdom piles.
Great! Adventurer didn't alter the Victory and Kingdom piles.
---------------------------------------------------
Final Testing results of refactored adventurer card
---------------------------------------------------
refactored adventurer card failed for 1 condition(s), check above for which ones.

File 'cardtest1.c'
Lines executed:72.86% of 70
Branches executed:75.00% of 32
Taken at least once:40.63% of 32
Calls executed:72.97% of 37
Creating 'cardtest1.c.gcov'

        -:    0:Source:cardtest1.c
        -:    0:Graph:cardtest1.gcno
        -:    0:Data:cardtest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:
        -:    2:/* -----------------------------------------------------------------------
        -:    3: * CS362-004 Summer 2017 Assignment 3
        -:    4: * cardtest1.c
        -:    5: *
        -:    6: * Patrick Kwong
        -:    7: * kwongp@oregonstate.edu
        -:    8: * 
        -:    9: * Unit test for my refactored dominion card function: adventurer_func
        -:   10: * reveal cards from deck until you reveal 2 treasure cards
        -:   11: * put 2 treasure cards in hand and discarded other revealed cards
        -:   12: * 
        -:   13: * Used provided cardtest4.c and testUpdateCoins.c examples
        -:   14: * -----------------------------------------------------------------------
        -:   15: * Include the following lines in the makefile:
        -:   16: *
        -:   17: * cardtest1: cardtest1.c dominion.o rngs.o
        -:   18: *      gcc -o cardtest1 -g cardtest1.c dominion.o rngs.o $(CFLAGS)
        -:   19: */
        -:   20:
        -:   21:#include "dominion.h"
        -:   22:#include "dominion_helpers.h"
        -:   23:#include <string.h>
        -:   24:#include <stdio.h>
        -:   25:#include <assert.h>
        -:   26:#include "rngs.h"
        -:   27:#include <stdlib.h>
        -:   28:#include <time.h>
        -:   29:#include <math.h>
        -:   30:
function main called 1 returned 100% blocks executed 66%
        1:   31:int main() {
        -:   32:    int i;
        -:   33:    int seed;
        1:   34:    int numPlayer = 2;
        1:   35:    int bugCount = 0;
        1:   36:    int flag = 0;
        -:   37:    int prevCount, afterCount;
        1:   38:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   39:               , remodel, smithy, village, baron, great_hall};
        -:   40:    struct gameState G, prevG;
        1:   41:    seed = (rand() % 100);
call    0 returned 100%
        -:   42:
        1:   43:    printf("\nTesting refactored adventurer card function\n");
call    0 returned 100%
        1:   44:    printf("-------------------------------------------\n");
call    0 returned 100%
        -:   45:    
        1:   46:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   47:    initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        1:   48:    gainCard(adventurer, &G, 2, 0); // add adventurer card to player 1's hand
call    0 returned 100%
        -:   49:    
        1:   50:    memcpy(&prevG, &G, sizeof(struct gameState)); //create clone of game state to run tests on
        1:   51:    adventurer_func(&G);
call    0 returned 100%
        -:   52:    
        -:   53:    // get hand counts
        1:   54:    prevCount = prevG.handCount[0];
        1:   55:    afterCount = G.handCount[0];
        -:   56:
        -:   57:    // check if correct number of cards after refactored adventurer card
        1:   58:    printf("\nChecking if correct number of cards after using refactored adventurer card .\n");
call    0 returned 100%
        1:   59:    printf("Previous hand count: %d, After Adventurer: %d\n", prevCount, afterCount);
call    0 returned 100%
        1:   60:    printf("Expected hand count after Adventurer: 7 (+1 = +2 drawn from Adventurer and -1 from discarding Adventurer.\n");
call    0 returned 100%
        1:   61:    if(prevG.handCount[0]+1 != G.handCount[0]){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   62:        printf("Bug!!! Ended with the incorrect number of cards in hand after Adventurer.\n");
call    0 returned 100%
        1:   63:        bugCount++;
        -:   64:    }
        -:   65:    else
    #####:   66:        printf("Great! Ended with the correct number of cards in hand after Adventurer.\n");
call    0 never executed
        -:   67:
        -:   68:    // check if adventurer added the only treasure cards to hand 
        1:   69:    printf("\nChecking if refactored adventurer card adds only treasure cards to hand.\n");
call    0 returned 100%
        1:   70:    if(G.hand[0][G.handCount[0]-2] != copper && G.hand[0][G.handCount[0]-2] != silver && G.hand[0][G.handCount[0]-2] != gold){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   71:        printf("Bug!!! Adventurer added a card beside a treasure.\n");
call    0 never executed
    #####:   72:        bugCount++;
        -:   73:    }
        1:   74:    else if(G.hand[0][G.handCount[0]-1] != copper && G.hand[0][G.handCount[0]-1] != silver && G.hand[0][G.handCount[0]-1] != gold){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   75:        printf("Bug!!! Adventurer added a card beside a treasure.\n");
call    0 never executed
    #####:   76:        bugCount++;
        -:   77:    }
        -:   78:    else
        1:   79:        printf("Great! Adventurer added only treasure cards to hand.\n");
call    0 returned 100%
        -:   80:
        -:   81:    // check if adventurer drew enough cards from deck 
        1:   82:    printf("\nChecking if refactored adventurer card drew enough cards to hand.\n");
call    0 returned 100%
        1:   83:    if(prevG.deckCount[0]-2 < G.deckCount[0]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   84:        printf("Bug!!! Adventurer didn't draw enough cards from the deck.\n");
call    0 never executed
    #####:   85:        bugCount++;
        -:   86:    }
        -:   87:    else
        1:   88:        printf("Great! Adventurer drew enough cards from deck.\n");
call    0 returned 100%
        -:   89:
        -:   90:    // check if adventurer discarded the correct number cards to hand 
        1:   91:    printf("\nChecking if refactored adventurer card discarded correct number of cards to hand.\n");
call    0 returned 100%
        1:   92:    printf("Previous deck count: %d cards, After Adventurer: %d cards\n", prevG.deckCount[0], G.deckCount[0]);    
call    0 returned 100%
        1:   93:    printf("Previous discard count: %d cards, After Adventurer: %d cards\n", prevG.discardCount[0], G.discardCount[0]);
call    0 returned 100%
        1:   94:    printf("Expected deck count after Adventurer: %d card.\n", (prevG.deckCount[0] - 2));
call    0 returned 100%
        1:   95:    if((prevG.deckCount[0] - G.deckCount[0]) == (G.deckCount[0] - prevG.deckCount[0] + 1)){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   96:        printf("Bug!!! Adventurer discarded the incorrect number of cards to hand.\n");
call    0 never executed
    #####:   97:        bugCount++;
        -:   98:    }
        -:   99:    else
        1:  100:        printf("Great! Adventurer discarded the correct number of cards to hand.\n");
call    0 returned 100%
        -:  101:
        -:  102:
        -:  103:    // check if Adventurer altered other player's cards
        1:  104:    printf("\nChecking if refactored adventurer card altered other player's hand.\n");
call    0 returned 100%
        1:  105:    if(prevG.handCount[1] != G.handCount[1]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  106:        printf("Bug!!! Adventurer altered other player's cards\n");
call    0 never executed
    #####:  107:        bugCount++;
        -:  108:    }
        1:  109:    else if(prevG.deckCount[1] != G.deckCount[1]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  110:        printf("Bug!!! Adventurer altered other player's cards\n");
call    0 never executed
    #####:  111:        bugCount++;
        -:  112:    }
        1:  113:    else if(prevG.discardCount[1] != G.discardCount[1]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  114:        printf("Bug!!! Adventurer altered other player's cards\n");
call    0 never executed
    #####:  115:        bugCount++;
        -:  116:    }
        -:  117:    else
        1:  118:        printf("Great! Adventurer didn't alter other player's cards.\n");
call    0 returned 100%
        -:  119:    
        -:  120:    // check if Adventurer altered the victory and kingdom piles
        1:  121:    printf("\nChecking if refactored adventurer card altered the Victory and Kingdom piles.\n");
call    0 returned 100%
        1:  122:    int arraySize = sizeof(G.supplyCount) / sizeof(int);
       28:  123:    for(i = 0; i < arraySize; i++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       27:  124:        if(G.supplyCount[i] != prevG.supplyCount[i]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  125:            flag = 1;
        -:  126:        }
        -:  127:    }
        1:  128:    if(flag == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  129:        printf("Great! Adventurer didn't alter the Victory and Kingdom piles.\n");
call    0 returned 100%
        -:  130:    else
        -:  131:    {
    #####:  132:        printf("Bug!!! Kingdom/Victory supplied have been altered\n");
call    0 never executed
    #####:  133:        bugCount++;
        -:  134:    }
        -:  135:
        -:  136:    // output the test results overall
        1:  137:    printf("---------------------------------------------------\n");
call    0 returned 100%
        1:  138:    printf("Final Testing results of refactored adventurer card\n");
call    0 returned 100%
        1:  139:    printf("---------------------------------------------------\n");
call    0 returned 100%
        -:  140:
        1:  141:    if(bugCount == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  142:        printf("All tests passed for the refactored adventurer card!\n\n");
call    0 never executed
        -:  143:    else
        1:  144:        printf("refactored adventurer card failed for %d condition(s), check above for which ones.\n\n", bugCount);
call    0 returned 100%
        -:  145:    
        1:  146:    return 0;
        -:  147:}
File 'dominion.c'
Lines executed:31.62% of 563
Branches executed:30.22% of 417
Taken at least once:27.34% of 417
Calls executed:12.00% of 100
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:5
        -:    0:Programs:5
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 5745 returned 100% blocks executed 83%
     5745:    8:int compare(const void* a, const void* b) {
     5745:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:    return 1;
     5745:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
     1532:   12:    return -1;
     4213:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 192 returned 100% blocks executed 97%
      192:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      192:   44:  SelectStream(1);
call    0 returned 100%
      192:   45:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:  
        -:   47:  //check number of players
      192:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:    {
        2:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      190:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     2090:   57:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:    {
    20900:   59:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:        {
    19000:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      190:   73:  if (numPlayers == 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   74:    {
      188:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
        2:   77:  else if (numPlayers == 3)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:   78:    {
        1:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
        1:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      190:   87:  if (numPlayers == 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   88:    {
      188:   89:      state->supplyCount[estate] = 8;
      188:   90:      state->supplyCount[duchy] = 8;
      188:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
        2:   95:      state->supplyCount[estate] = 12;
        2:   96:      state->supplyCount[duchy] = 12;
        2:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      190:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      190:  102:  state->supplyCount[silver] = 40;
      190:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
     3990:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:    {
    31350:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:	{
    29450:  110:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     1900:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
        -:  114:		{
      760:  115:		  if (numPlayers == 2){ 
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      376:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
        4:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     1520:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     1900:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    27550:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
      573:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:    {
      383:  140:      state->deckCount[i] = 0;
     1532:  141:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:	{
     1149:  143:	  state->deck[i][j] = estate;
     1149:  144:	  state->deckCount[i]++;
        -:  145:	}
     3064:  146:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:	{
     2681:  148:	  state->deck[i][j] = copper;
     2681:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
      573:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:    {
      383:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
      573:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      383:  166:      state->handCount[i] = 0;
      383:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
     5320:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:    {
     5130:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      190:  182:  state->outpostPlayed = 0;
      190:  183:  state->phase = 0;
      190:  184:  state->numActions = 1;
      190:  185:  state->numBuys = 1;
      190:  186:  state->playedCardCount = 0;
      190:  187:  state->whoseTurn = 0;
      190:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     1140:  192:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      950:  193:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:  }
        -:  195:
      190:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
      190:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 385 returned 100% blocks executed 100%
      385:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
      385:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
      385:  209:  if (state->deckCount[player] < 1)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2:  210:    return -1;
      383:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     4596:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     3830:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     3830:  216:    newDeck[newDeckPos] = state->deck[player][card];
     3830:  217:    newDeckPos++;
    14306:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 73%
branch  1 taken 27% (fallthrough)
    10476:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
     3830:  221:    state->deckCount[player]--;
        -:  222:  }
     4213:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     3830:  224:    state->deck[player][i] = newDeck[i];
     3830:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
      383:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 61 returned 100% blocks executed 100%
       61:  320:int supplyCount(int card, struct gameState *state) {
       61:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 1 returned 100% blocks executed 100%
        1:  346:int whoseTurn(struct gameState *state) {
        1:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 11 returned 100% blocks executed 100%
       11:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
       11:  395:  if (state->supplyCount[province] == 0)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
        -:  396:    {
        3:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
        8:  401:  j = 0;
      208:  402:  for (i = 0; i < 25; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  403:    {
      200:  404:      if (state->supplyCount[i] == 0)
branch  0 taken 9% (fallthrough)
branch  1 taken 92%
        -:  405:	{
       17:  406:	  j++;
        -:  407:	}
        -:  408:    }
        8:  409:  if ( j >= 3)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  410:    {
        4:  411:      return 1;
        -:  412:    }
        -:  413:
        4:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 956 returned 100% blocks executed 85%
      956:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
      956:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
        1:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
        1:  538:    state->deckCount[player] = state->discardCount[player];
        1:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
        1:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
        1:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
        1:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
        1:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
        1:  559:    if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
      955:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
      955:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
      955:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      955:  576:    state->deckCount[player]--;
      955:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
      955:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 27 returned 100% blocks executed 97%
       27:  583:int getCost(int cardNumber)
        -:  584:{
       27:  585:  switch( cardNumber ) 
branch  0 taken 4%
branch  1 taken 4%
branch  2 taken 4%
branch  3 taken 4%
branch  4 taken 4%
branch  5 taken 4%
branch  6 taken 4%
branch  7 taken 4%
branch  8 taken 4%
branch  9 taken 4%
branch 10 taken 4%
branch 11 taken 4%
branch 12 taken 4%
branch 13 taken 4%
branch 14 taken 4%
branch 15 taken 4%
branch 16 taken 4%
branch 17 taken 4%
branch 18 taken 4%
branch 19 taken 4%
branch 20 taken 4%
branch 21 taken 4%
branch 22 taken 4%
branch 23 taken 4%
branch 24 taken 4%
branch 25 taken 4%
branch 26 taken 4%
branch 27 taken 0%
        -:  586:    {
        -:  587:    case curse:
        1:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        1:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        1:  608:      return 4;
        -:  609:    case mine:
        1:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        1:  614:      return 4;
        -:  615:    case village:
        1:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        1:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        1:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        1:  630:      return 4;
        -:  631:    case embargo: 
        1:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        1:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:// Assignment 2 - refactor card #1: Adventurer
function adventurer_func called 1 returned 100% blocks executed 100%
        1:  647:int adventurer_func(struct gameState *state)
        -:  648:{
        -:  649:	int cardDrawn;
        1:  650:	int currentPlayer = whoseTurn(state);	
call    0 returned 100%
        1:  651:	int drawntreasure = 0;
        -:  652:	int temphand[MAX_HAND];// moved above the if statement
        1:  653:	int z = 0;// this is the counter for the temp hand
        -:  654:    
        8:  655:	while(drawntreasure <= 2) // BUG added!! - Changed to < to <= that what it could end up drawing extra treasure.
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        -:  656:	{
        -:  657:		//if the deck is empty we need to shuffle discard and add to deck
        6:  658:		if (state->deckCount[currentPlayer] <1)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        1:  659:			shuffle(currentPlayer, state);
call    0 returned 100%
        -:  660:		
        6:  661:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  662:		
        -:  663:			//top card of hand is most recently drawn card.
        6:  664:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  665:	
        6:  666:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        3:  667:				drawntreasure++;
        -:  668:			else
        -:  669:			{
        3:  670:				temphand[z] = cardDrawn;
        -:  671:				
        -:  672:				//this should just remove the top card (the most recently drawn one).
        3:  673:				state->handCount[currentPlayer]--; 
        3:  674:				z++;
        -:  675:			}
        -:  676:		}
        -:  677:      
        5:  678:		while(z - 1 >= 0)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  679:		{
        -:  680:			// discard all cards in play that have been drawn
        3:  681:			state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; 
        3:  682:			z = z - 1;
        -:  683:		}
        -:  684:		
        1:  685:		return 0;
        -:  686:}
        -:  687:
        -:  688:// Assignment 2 - refactor card #2: Council Room
function council_room_func called 0 returned 0% blocks executed 0%
    #####:  689:int council_room_func(int handPos, struct gameState *state)
        -:  690:{
        -:  691:	int i;
    #####:  692:	int currentPlayer = whoseTurn(state);	
call    0 never executed
        -:  693:	
        -:  694:	//+4 Cards
    #####:  695:	for (i = 1; i < 4; i++) // BUG added!!! = changed i=0 to i=1, which will result in 1 less card drawn.
branch  0 never executed
branch  1 never executed
    #####:  696:		drawCard(currentPlayer, state);
call    0 never executed
        -:  697:
        -:  698:	//+1 Buy
    #####:  699:	state->numBuys++;
        -:  700:	
        -:  701:	//Each other player draws a card
    #####:  702:	for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
    #####:  703:		if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
    #####:  704:			drawCard(i, state);
call    0 never executed
        -:  705:
        -:  706:	//put played card in played card pile
    #####:  707:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  708:
    #####:  709:	return 0;
        -:  710:}
        -:  711:
        -:  712:
        -:  713:// Assignment 2 - refactor card #3: Remodel
function remodel_func called 0 returned 0% blocks executed 0%
    #####:  714:int remodel_func(int choice1, int choice2, int handPos, struct gameState *state)
        -:  715:{
        -:  716:	int i;
        -:  717:	int j;
    #####:  718:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  719:    
    #####:  720:	j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  721:
    #####:  722:	if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  723:		return -1;
        -:  724:
    #####:  725:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  726:
        -:  727:	//discard card from hand
    #####:  728:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  729:
        -:  730:	//discard trashed card
    #####:  731:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  732:	{
    #####:  733:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  734:	    {
    #####:  735:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  736:			break;
        -:  737:	    }
        -:  738:	}
        -:  739:	
    #####:  740:	return 0;
        -:  741:}
        -:  742:
        -:  743:// Assignment 2 - refactor card #4: Smithy
function smithy_func called 0 returned 0% blocks executed 0%
    #####:  744:int smithy_func(int handPos, struct gameState *state)
        -:  745:{
        -:  746:	int i;
    #####:  747:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  748:	
        -:  749:	//+3 Cards
    #####:  750:	for (i = 0; i <= 3; i++) // BUG added!!! = changed < to <=, which will result in 1 more card drawn.
branch  0 never executed
branch  1 never executed
    #####:  751:		drawCard(currentPlayer, state);
call    0 never executed
        -:  752:
        -:  753:	//discard card from hand
    #####:  754:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  755:	
    #####:  756:	return 0;
        -:  757:}
        -:  758:
        -:  759:// Assignment 2 - refactor card #5: Village
function village_func called 0 returned 0% blocks executed 0%
    #####:  760:int village_func(int handPos, struct gameState *state)
        -:  761:{
    #####:  762:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  763:	
        -:  764:	//+1 Card
    #####:  765:	drawCard(currentPlayer, state);
call    0 never executed
        -:  766:			
        -:  767:	//+2 Actions
    #####:  768:	state->numActions = state->numActions + 22; // BUG added!!! = changed 2 to 22, which will result in +22 actions instead of just 2.
        -:  769:			
        -:  770:	//discard played card from hand
    #####:  771:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  772:
    #####:  773:	return 0;
        -:  774:}
        -:  775:
        -:  776:// cardEffect - for assignment 2 - I refactored 5 of these cards (adventurer, 
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  777:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  778:{
        -:  779:  int i;
        -:  780:  int j;
        -:  781:  int k;
        -:  782:  int x;
        -:  783:  int index;
    #####:  784:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  785:  int nextPlayer = currentPlayer + 1;
        -:  786:
    #####:  787:  int tributeRevealedCards[2] = {-1, -1};
        -:  788:  int temphand[MAX_HAND];// moved above the if statement
        -:  789:
    #####:  790:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  791:    nextPlayer = 0;
        -:  792:  }
        -:  793:  
        -:  794:  /* these variables are no longer needed after refactoring
        -:  795:  
        -:  796:    int drawntreasure=0;
        -:  797:	int cardDrawn;
        -:  798:	int z = 0;// this is the counter for the temp hand
        -:  799:	*/
        -:  800:	
        -:  801:  //uses switch to select card and perform actions
    #####:  802:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  803:    {
        -:  804:    case adventurer:
        -:  805:	
    #####:  806:		adventurer_func(state);
call    0 never executed
        -:  807:		
        -:  808:		/* commented out code that is no longer needed due to refactoring
        -:  809:		while(drawntreasure<2)
        -:  810:		{
        -:  811:			//if the deck is empty we need to shuffle discard and add to deck
        -:  812:			if (state->deckCount[currentPlayer] <1)
        -:  813:				shuffle(currentPlayer, state);
        -:  814:		
        -:  815:			drawCard(currentPlayer, state);
        -:  816:		
        -:  817:			//top card of hand is most recently drawn card.
        -:  818:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  819:	
        -:  820:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:  821:				drawntreasure++;
        -:  822:			else
        -:  823:			{
        -:  824:				temphand[z]=cardDrawn;
        -:  825:				
        -:  826:				//this should just remove the top card (the most recently drawn one).
        -:  827:				state->handCount[currentPlayer]--; 
        -:  828:				z++;
        -:  829:			}
        -:  830:		}
        -:  831:      
        -:  832:		while(z-1>=0)
        -:  833:		{
        -:  834:			// discard all cards in play that have been drawn
        -:  835:			state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; 
        -:  836:			z=z-1;
        -:  837:		}
        -:  838:		return 0;
        -:  839:		*/
        -:  840:	
        -:  841:    case council_room:
        -:  842:		
    #####:  843:		council_room_func(handPos, state);
call    0 never executed
        -:  844:		
        -:  845:		/* commented out code that is no longer needed due to refactoring
        -:  846:		
        -:  847:		//+4 Cards
        -:  848:		  for (i = 0; i < 4; i++)
        -:  849:		{
        -:  850:		  drawCard(currentPlayer, state);
        -:  851:		}
        -:  852:				
        -:  853:		  //+1 Buy
        -:  854:		  state->numBuys++;
        -:  855:				
        -:  856:		  //Each other player draws a card
        -:  857:		  for (i = 0; i < state->numPlayers; i++)
        -:  858:		{
        -:  859:		  if ( i != currentPlayer )
        -:  860:			{
        -:  861:			  drawCard(i, state);
        -:  862:			}
        -:  863:		}
        -:  864:				
        -:  865:		  //put played card in played card pile
        -:  866:		  discardCard(handPos, currentPlayer, state, 0);
        -:  867:				
        -:  868:		  return 0;
        -:  869:		*/
        -:  870:		
        -:  871:    case feast:
        -:  872:      //gain card with cost up to 5
        -:  873:      //Backup hand
    #####:  874:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  875:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  876:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  877:      }
        -:  878:      //Backup hand
        -:  879:
        -:  880:      //Update Coins for Buy
    #####:  881:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  882:      x = 1;//Condition to loop on
    #####:  883:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  884:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  885:	  if (DEBUG)
        -:  886:	    printf("None of that card left, sorry!\n");
        -:  887:
        -:  888:	  if (DEBUG){
        -:  889:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  890:	  }
        -:  891:	}
    #####:  892:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  893:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  894:
        -:  895:	  if (DEBUG){
        -:  896:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  897:	  }
        -:  898:	}
        -:  899:	else{
        -:  900:
        -:  901:	  if (DEBUG){
        -:  902:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  903:	  }
        -:  904:
    #####:  905:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  906:	  x = 0;//No more buying cards
        -:  907:
        -:  908:	  if (DEBUG){
        -:  909:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  910:	  }
        -:  911:
        -:  912:	}
        -:  913:      }     
        -:  914:
        -:  915:      //Reset Hand
    #####:  916:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  917:	state->hand[currentPlayer][i] = temphand[i];
    #####:  918:	temphand[i] = -1;
        -:  919:      }
        -:  920:      //Reset Hand
        -:  921:      			
    #####:  922:      return 0;
        -:  923:			
        -:  924:    case gardens:
    #####:  925:      return -1;
        -:  926:			
        -:  927:    case mine:
    #####:  928:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  929:
    #####:  930:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  931:	{
    #####:  932:	  return -1;
        -:  933:	}
        -:  934:		
    #####:  935:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  936:	{
    #####:  937:	  return -1;
        -:  938:	}
        -:  939:
    #####:  940:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  941:	{
    #####:  942:	  return -1;
        -:  943:	}
        -:  944:
    #####:  945:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  946:
        -:  947:      //discard card from hand
    #####:  948:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  949:
        -:  950:      //discard trashed card
    #####:  951:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  952:	{
    #####:  953:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  954:	    {
    #####:  955:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  956:	      break;
        -:  957:	    }
        -:  958:	}
        -:  959:			
    #####:  960:      return 0;
        -:  961:			
        -:  962:    case remodel:
        -:  963:	
    #####:  964:		remodel_func(choice1, choice2, handPos, state);
call    0 never executed
        -:  965:		
        -:  966:		/* commented out code that is no longer needed due to refactoring
        -:  967:			
        -:  968:		  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  969:
        -:  970:		  if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  971:		{
        -:  972:		  return -1;
        -:  973:		}
        -:  974:
        -:  975:		  gainCard(choice2, state, 0, currentPlayer);
        -:  976:
        -:  977:		  //discard card from hand
        -:  978:		  discardCard(handPos, currentPlayer, state, 0);
        -:  979:
        -:  980:		  //discard trashed card
        -:  981:		  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  982:		{
        -:  983:		  if (state->hand[currentPlayer][i] == j)
        -:  984:			{
        -:  985:			  discardCard(i, currentPlayer, state, 0);			
        -:  986:			  break;
        -:  987:			}
        -:  988:		}
        -:  989:
        -:  990:		  return 0;
        -:  991:		*/
        -:  992:		
        -:  993:    case smithy:
        -:  994:	
    #####:  995:		smithy_func(handPos, state);
call    0 never executed
        -:  996:		
        -:  997:		/* commented out code that is no longer needed due to refactoring
        -:  998:			
        -:  999:		  //+3 Cards
        -: 1000:		  for (i = 0; i < 3; i++)
        -: 1001:		{
        -: 1002:		  drawCard(currentPlayer, state);
        -: 1003:		}
        -: 1004:				
        -: 1005:		  //discard card from hand
        -: 1006:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1007:		  return 0;
        -: 1008:		*/
        -: 1009:			
        -: 1010:    case village:
        -: 1011:	
    #####: 1012:		village_func(handPos, state);
call    0 never executed
        -: 1013:		
        -: 1014:		/* commented out code that is no longer needed due to refactoring
        -: 1015:			
        -: 1016:		  //+1 Card
        -: 1017:		  drawCard(currentPlayer, state);
        -: 1018:				
        -: 1019:		  //+2 Actions
        -: 1020:		  state->numActions = state->numActions + 2;
        -: 1021:				
        -: 1022:		  //discard played card from hand
        -: 1023:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1024:		  return 0;
        -: 1025:		*/
        -: 1026:		
        -: 1027:    case baron:
    #####: 1028:      state->numBuys++;//Increase buys by 1!
    #####: 1029:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####: 1030:	int p = 0;//Iterator for hand!
    #####: 1031:	int card_not_discarded = 1;//Flag for discard set!
    #####: 1032:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####: 1033:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####: 1034:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####: 1035:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1036:	    state->discardCount[currentPlayer]++;
    #####: 1037:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####: 1038:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -: 1039:	    }
    #####: 1040:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1041:	    state->handCount[currentPlayer]--;
    #####: 1042:	    card_not_discarded = 0;//Exit the loop
        -: 1043:	  }
    #####: 1044:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -: 1045:	    if(DEBUG) {
        -: 1046:	      printf("No estate cards in your hand, invalid choice\n");
        -: 1047:	      printf("Must gain an estate if there are any\n");
        -: 1048:	    }
    #####: 1049:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1050:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####: 1051:	      state->supplyCount[estate]--;//Decrement estates
    #####: 1052:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1053:		isGameOver(state);
call    0 never executed
        -: 1054:	      }
        -: 1055:	    }
    #####: 1056:	    card_not_discarded = 0;//Exit the loop
        -: 1057:	  }
        -: 1058:			    
        -: 1059:	  else{
    #####: 1060:	    p++;//Next card
        -: 1061:	  }
        -: 1062:	}
        -: 1063:      }
        -: 1064:			    
        -: 1065:      else{
    #####: 1066:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1067:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####: 1068:	  state->supplyCount[estate]--;//Decrement Estates
    #####: 1069:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1070:	    isGameOver(state);
call    0 never executed
        -: 1071:	  }
        -: 1072:	}
        -: 1073:      }
        -: 1074:	    
        -: 1075:      
    #####: 1076:      return 0;
        -: 1077:		
        -: 1078:    case great_hall:
        -: 1079:      //+1 Card
    #####: 1080:      drawCard(currentPlayer, state);
call    0 never executed
        -: 1081:			
        -: 1082:      //+1 Actions
    #####: 1083:      state->numActions++;
        -: 1084:			
        -: 1085:      //discard card from hand
    #####: 1086:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1087:      return 0;
        -: 1088:		
        -: 1089:    case minion:
        -: 1090:      //+1 action
    #####: 1091:      state->numActions++;
        -: 1092:			
        -: 1093:      //discard card from hand
    #####: 1094:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1095:			
    #####: 1096:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -: 1097:	{
    #####: 1098:	  state->coins = state->coins + 2;
        -: 1099:	}
        -: 1100:			
    #####: 1101:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -: 1102:	{
        -: 1103:	  //discard hand
    #####: 1104:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1105:	    {
    #####: 1106:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1107:	    }
        -: 1108:				
        -: 1109:	  //draw 4
    #####: 1110:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1111:	    {
    #####: 1112:	      drawCard(currentPlayer, state);
call    0 never executed
        -: 1113:	    }
        -: 1114:				
        -: 1115:	  //other players discard hand and redraw if hand size > 4
    #####: 1116:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1117:	    {
    #####: 1118:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1119:		{
    #####: 1120:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1121:		    {
        -: 1122:		      //discard hand
    #####: 1123:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1124:			{
    #####: 1125:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1126:			}
        -: 1127:							
        -: 1128:		      //draw 4
    #####: 1129:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1130:			{
    #####: 1131:			  drawCard(i, state);
call    0 never executed
        -: 1132:			}
        -: 1133:		    }
        -: 1134:		}
        -: 1135:	    }
        -: 1136:				
        -: 1137:	}
    #####: 1138:      return 0;
        -: 1139:		
        -: 1140:    case steward:
    #####: 1141:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1142:	{
        -: 1143:	  //+2 cards
    #####: 1144:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1145:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1146:	}
    #####: 1147:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1148:	{
        -: 1149:	  //+2 coins
    #####: 1150:	  state->coins = state->coins + 2;
        -: 1151:	}
        -: 1152:      else
        -: 1153:	{
        -: 1154:	  //trash 2 cards in hand
    #####: 1155:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1156:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1157:	}
        -: 1158:			
        -: 1159:      //discard card from hand
    #####: 1160:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1161:      return 0;
        -: 1162:		
        -: 1163:    case tribute:
    #####: 1164:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1165:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1166:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1167:	  state->deckCount[nextPlayer]--;
        -: 1168:	}
    #####: 1169:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1170:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1171:	  state->discardCount[nextPlayer]--;
        -: 1172:	}
        -: 1173:	else{
        -: 1174:	  //No Card to Reveal
        -: 1175:	  if (DEBUG){
        -: 1176:	    printf("No cards to reveal\n");
        -: 1177:	  }
        -: 1178:	}
        -: 1179:      }
        -: 1180:	    
        -: 1181:      else{
    #####: 1182:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1183:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1184:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1185:	    state->deckCount[nextPlayer]++;
    #####: 1186:	    state->discard[nextPlayer][i] = -1;
    #####: 1187:	    state->discardCount[nextPlayer]--;
        -: 1188:	  }
        -: 1189:			    
    #####: 1190:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1191:	} 
    #####: 1192:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1193:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1194:	state->deckCount[nextPlayer]--;
    #####: 1195:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1196:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1197:	state->deckCount[nextPlayer]--;
        -: 1198:      }    
        -: 1199:		       
    #####: 1200:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1201:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1202:	state->playedCardCount++;
    #####: 1203:	tributeRevealedCards[1] = -1;
        -: 1204:      }
        -: 1205:
    #####: 1206:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1207:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1208:	  state->coins += 2;
        -: 1209:	}
        -: 1210:		    
    #####: 1211:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1212:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1213:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1214:	}
        -: 1215:	else{//Action Card
    #####: 1216:	  state->numActions = state->numActions + 2;
        -: 1217:	}
        -: 1218:      }
        -: 1219:	    
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case ambassador:
    #####: 1223:      j = 0;		//used to check if player has enough cards to discard
        -: 1224:
    #####: 1225:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1226:	{
    #####: 1227:	  return -1;				
        -: 1228:	}
        -: 1229:
    #####: 1230:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1231:	{
    #####: 1232:	  return -1;
        -: 1233:	}
        -: 1234:
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1238:	    {
    #####: 1239:	      j++;
        -: 1240:	    }
        -: 1241:	}
    #####: 1242:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1243:	{
    #####: 1244:	  return -1;				
        -: 1245:	}
        -: 1246:
        -: 1247:      if (DEBUG) 
        -: 1248:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1249:
        -: 1250:      //increase supply count for choosen card by amount being discarded
    #####: 1251:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1252:			
        -: 1253:      //each other player gains a copy of revealed card
    #####: 1254:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:	{
    #####: 1256:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1257:	    {
    #####: 1258:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1259:	    }
        -: 1260:	}
        -: 1261:
        -: 1262:      //discard played card from hand
    #####: 1263:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1264:
        -: 1265:      //trash copies of cards returned to supply
    #####: 1266:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1267:	{
    #####: 1268:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1269:	    {
    #####: 1270:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1271:		{
    #####: 1272:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1273:		  break;
        -: 1274:		}
        -: 1275:	    }
        -: 1276:	}			
        -: 1277:
    #####: 1278:      return 0;
        -: 1279:		
        -: 1280:    case cutpurse:
        -: 1281:
    #####: 1282:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1283:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1284:	{
    #####: 1285:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1286:	    {
    #####: 1287:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1288:		{
    #####: 1289:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1290:		    {
    #####: 1291:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1292:		      break;
        -: 1293:		    }
    #####: 1294:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1295:		    {
    #####: 1296:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1297:			{
        -: 1298:			  if (DEBUG)
        -: 1299:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1300:			}	
    #####: 1301:		      break;
        -: 1302:		    }		
        -: 1303:		}
        -: 1304:					
        -: 1305:	    }
        -: 1306:				
        -: 1307:	}				
        -: 1308:
        -: 1309:      //discard played card from hand
    #####: 1310:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1311:
    #####: 1312:      return 0;
        -: 1313:
        -: 1314:		
        -: 1315:    case embargo: 
        -: 1316:      //+2 Coins
    #####: 1317:      state->coins = state->coins + 2;
        -: 1318:			
        -: 1319:      //see if selected pile is in play
    #####: 1320:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1321:	{
    #####: 1322:	  return -1;
        -: 1323:	}
        -: 1324:			
        -: 1325:      //add embargo token to selected supply pile
    #####: 1326:      state->embargoTokens[choice1]++;
        -: 1327:			
        -: 1328:      //trash card
    #####: 1329:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1330:      return 0;
        -: 1331:		
        -: 1332:    case outpost:
        -: 1333:      //set outpost flag
    #####: 1334:      state->outpostPlayed++;
        -: 1335:			
        -: 1336:      //discard card
    #####: 1337:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1338:      return 0;
        -: 1339:		
        -: 1340:    case salvager:
        -: 1341:      //+1 buy
    #####: 1342:      state->numBuys++;
        -: 1343:			
    #####: 1344:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1345:	{
        -: 1346:	  //gain coins equal to trashed card
    #####: 1347:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1348:	  //trash card
    #####: 1349:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1350:	}
        -: 1351:			
        -: 1352:      //discard card
    #####: 1353:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1354:      return 0;
        -: 1355:		
        -: 1356:    case sea_hag:
    #####: 1357:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1358:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1359:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1360:	  state->discardCount[i]++;
    #####: 1361:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1362:	}
        -: 1363:      }
    #####: 1364:      return 0;
        -: 1365:		
        -: 1366:    case treasure_map:
        -: 1367:      //search hand for another treasure_map
    #####: 1368:      index = -1;
    #####: 1369:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1370:	{
    #####: 1371:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1372:	    {
    #####: 1373:	      index = i;
    #####: 1374:	      break;
        -: 1375:	    }
        -: 1376:	}
    #####: 1377:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1378:	{
        -: 1379:	  //trash both treasure cards
    #####: 1380:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1381:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1382:
        -: 1383:	  //gain 4 Gold cards
    #####: 1384:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1385:	    {
    #####: 1386:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1387:	    }
        -: 1388:				
        -: 1389:	  //return success
    #####: 1390:	  return 1;
        -: 1391:	}
        -: 1392:			
        -: 1393:      //no second treasure_map found in hand
    #####: 1394:      return -1;
        -: 1395:    }
        -: 1396:	
    #####: 1397:  return -1;
        -: 1398:}
        -: 1399:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1400:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1401:{
        -: 1402:	
        -: 1403:  //if card is not trashed, added to Played pile 
    #####: 1404:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1405:    {
        -: 1406:      //add card to played pile
    #####: 1407:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1408:      state->playedCardCount++;
        -: 1409:    }
        -: 1410:	
        -: 1411:  //set played card to -1
    #####: 1412:  state->hand[currentPlayer][handPos] = -1;
        -: 1413:	
        -: 1414:  //remove card from player's hand
    #####: 1415:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1416:    {
        -: 1417:      //reduce number of cards in hand
    #####: 1418:      state->handCount[currentPlayer]--;
        -: 1419:    }
    #####: 1420:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1421:    {
        -: 1422:      //reduce number of cards in hand
    #####: 1423:      state->handCount[currentPlayer]--;
        -: 1424:    }
        -: 1425:  else 	
        -: 1426:    {
        -: 1427:      //replace discarded card with last card in hand
    #####: 1428:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1429:      //set last card to -1
    #####: 1430:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1431:      //reduce number of cards in hand
    #####: 1432:      state->handCount[currentPlayer]--;
        -: 1433:    }
        -: 1434:	
    #####: 1435:  return 0;
        -: 1436:}
        -: 1437:
function gainCard called 1 returned 100% blocks executed 70%
        1: 1438:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1439:{
        -: 1440:  //Note: supplyPos is enum of choosen card
        -: 1441:	
        -: 1442:  //check if supply pile is empty (0) or card is not used in game (-1)
        1: 1443:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1444:    {
    #####: 1445:      return -1;
        -: 1446:    }
        -: 1447:	
        -: 1448:  //added card for [whoseTurn] current player:
        -: 1449:  // toFlag = 0 : add to discard
        -: 1450:  // toFlag = 1 : add to deck
        -: 1451:  // toFlag = 2 : add to hand
        -: 1452:
        1: 1453:  if (toFlag == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1454:    {
    #####: 1455:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1456:      state->deckCount[player]++;
        -: 1457:    }
        1: 1458:  else if (toFlag == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1459:    {
        1: 1460:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
        1: 1461:      state->handCount[player]++;
        -: 1462:    }
        -: 1463:  else
        -: 1464:    {
    #####: 1465:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1466:      state->discardCount[player]++;
        -: 1467:    }
        -: 1468:	
        -: 1469:  //decrease number in supply pile
        1: 1470:  state->supplyCount[supplyPos]--;
        -: 1471:	 
        1: 1472:  return 0;
        -: 1473:}
        -: 1474:
function updateCoins called 586 returned 100% blocks executed 100%
      586: 1475:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1476:{
        -: 1477:  int i;
        -: 1478:	
        -: 1479:  //reset coin count
      586: 1480:  state->coins = 0;
        -: 1481:
        -: 1482:  //add coins for each Treasure card in player's hand
     2856: 1483:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 79%
branch  1 taken 21% (fallthrough)
        -: 1484:    {
     2270: 1485:      if (state->hand[player][i] == copper)
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
        -: 1486:	{
     1276: 1487:	  state->coins += 1;
        -: 1488:	}
      994: 1489:      else if (state->hand[player][i] == silver)
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
        -: 1490:	{
      418: 1491:	  state->coins += 2;
        -: 1492:	}
      576: 1493:      else if (state->hand[player][i] == gold)
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
        -: 1494:	{
      374: 1495:	  state->coins += 3;
        -: 1496:	}	
        -: 1497:    }	
        -: 1498:
        -: 1499:  //add bonus
      586: 1500:  state->coins += bonus;
        -: 1501:
      586: 1502:  return 0;
        -: 1503:}
        -: 1504:
        -: 1505:
        -: 1506://end of dominion.c
        -: 1507:
cardtest2.c:

Testing refactored Smithy card function
-----------------------------------------

Checking hand count is correct after using refactored Smithy card.
Previous hand count: 6, After Smithy: 9
Expected hand count after Smithy: 8 (+2 = +3 drawn from smithy and -1 from discarding smithy.
Bug!!! Ended with the incorrect number of cards in hand after Smithy.

Checking if refactored Smithy card drew enough cards to hand.
Previous deck count: 5, After Smithy: 1
Smithy drew: 4 cards. Expected to draw 3 cards.
Bug!!! Smithy didn't draw correct nunmber of cards from the deck.

Checking if refactored Smithy card altered other player's hand.
Great! Smithy didn't alter other player's cards.

Checking if refactored Smithy card altered the Victory and Kingdom piles.
Great! Smithy didn't alter the Victory and Kingdom piles.
---------------------------------------------------
Final Testing results of refactored smithy card
---------------------------------------------------
refactored smithy card failed for 2 condition(s), check above for which ones.

File 'cardtest2.c'
Lines executed:77.78% of 54
Branches executed:100.00% of 18
Taken at least once:55.56% of 18
Calls executed:75.86% of 29
Creating 'cardtest2.c.gcov'

        -:    0:Source:cardtest2.c
        -:    0:Graph:cardtest2.gcno
        -:    0:Data:cardtest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:
        -:    2:/* -----------------------------------------------------------------------
        -:    3: * CS362-004 Summer 2017 Assignment 3
        -:    4: * cardtest2.c
        -:    5: * 
        -:    6: * Patrick Kwong
        -:    7: * kwongp@oregonstate.edu
        -:    8: *
        -:    9: * Unit test for my refactored smithy card function: smithy_func
        -:   10: * draws 3 cards
        -:   11: *
        -:   12: * Used provided cardtest4.c and testUpdateCoins.c examples
        -:   13: * -----------------------------------------------------------------------
        -:   14: * Include the following lines in the makefile:
        -:   15: *
        -:   16: * cardtest2: cardtest2.c dominion.o rngs.o
        -:   17: *      gcc -o cardtest2 -g cardtest2.c dominion.o rngs.o $(CFLAGS)
        -:   18: */
        -:   19:
        -:   20:#include "dominion.h"
        -:   21:#include "dominion_helpers.h"
        -:   22:#include <string.h>
        -:   23:#include <stdio.h>
        -:   24:#include <assert.h>
        -:   25:#include "rngs.h"
        -:   26:#include <stdlib.h>
        -:   27:#include <time.h>
        -:   28:#include <math.h>
        -:   29:
function main called 1 returned 100% blocks executed 76%
        1:   30:int main() {
        -:   31:    int i;
        -:   32:    int seed;
        1:   33:    int numPlayer = 2;
        1:   34:    int bugCount = 0;
        1:   35:    int flag = 0;
        1:   36:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   37:               , remodel, smithy, village, baron, great_hall};
        -:   38:    struct gameState G, prevG;
        1:   39:    seed = (rand() % 100);
call    0 returned 100%
        -:   40:
        1:   41:    printf("\nTesting refactored Smithy card function\n");
call    0 returned 100%
        1:   42:    printf("-----------------------------------------\n");
call    0 returned 100%
        -:   43:    
        1:   44:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   45:    initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:   46:
        1:   47:    gainCard(smithy, &G, 2, 0); // add smithy card to player 1's hand
call    0 returned 100%
        1:   48:    memcpy(&prevG, &G, sizeof(struct gameState)); //create clone of game state to run tests on
        -:   49:
        1:   50:    smithy_func(G.handCount[0], &G);
call    0 returned 100%
        -:   51:
        -:   52:    // check if hand count correct after Smithy 
        1:   53:    printf("\nChecking hand count is correct after using refactored Smithy card.\n");
call    0 returned 100%
        1:   54:    printf("Previous hand count: %d, After Smithy: %d\n", prevG.handCount[0], G.handCount[0]);
call    0 returned 100%
        1:   55:    printf("Expected hand count after Smithy: 8 (+2 = +3 drawn from smithy and -1 from discarding smithy.\n");
call    0 returned 100%
        1:   56:    if(prevG.handCount[0]+2 != G.handCount[0]){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   57:        printf("Bug!!! Ended with the incorrect number of cards in hand after Smithy.\n");
call    0 returned 100%
        1:   58:        bugCount++;
        -:   59:    }
        -:   60:    else
    #####:   61:        printf("Great! Ended with the correct number of cards in hand after Smithy.\n");
call    0 never executed
        -:   62:
        -:   63:    // check if Smithy drew the correct cards from deck
        1:   64:    printf("\nChecking if refactored Smithy card drew enough cards to hand.\n");
call    0 returned 100%
        1:   65:    printf("Previous deck count: %d, After Smithy: %d\n", prevG.deckCount[0], G.deckCount[0]);
call    0 returned 100%
        1:   66:    printf("Smithy drew: %d cards. Expected to draw 3 cards.\n", prevG.deckCount[0] - G.deckCount[0]);
call    0 returned 100%
        1:   67:    if((prevG.deckCount[0] - G.deckCount[0]) != 3){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   68:        printf("Bug!!! Smithy didn't draw correct nunmber of cards from the deck.\n");
call    0 returned 100%
        1:   69:        bugCount++;
        -:   70:    }
        -:   71:    else
    #####:   72:        printf("Great! Smithy drew correct number of cards from deck.\n");
call    0 never executed
        -:   73:
        -:   74:    // check if smithy altered other player's cards
        1:   75:    printf("\nChecking if refactored Smithy card altered other player's hand.\n");
call    0 returned 100%
        1:   76:    if(prevG.handCount[1] != G.handCount[1]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   77:        printf("Bug!!! Smithy altered other player's cards\n");
call    0 never executed
    #####:   78:        bugCount++;
        -:   79:    }
        1:   80:    else if(prevG.deckCount[1] != G.deckCount[1]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   81:        printf("Bug!!! Ssmithy altered other player's cards\n");
call    0 never executed
    #####:   82:        bugCount++;
        -:   83:    }
        1:   84:    else if(prevG.discardCount[1] != G.discardCount[1]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   85:        printf("Bug!!! Smithy altered other player's cards\n");
call    0 never executed
    #####:   86:        bugCount++;
        -:   87:    }
        -:   88:    else
        1:   89:        printf("Great! Smithy didn't alter other player's cards.\n");
call    0 returned 100%
        -:   90:    
        -:   91:    // check if Smithy altered the victory and kingdom piles
        1:   92:    printf("\nChecking if refactored Smithy card altered the Victory and Kingdom piles.\n");
call    0 returned 100%
        1:   93:    int arraySize = sizeof(G.supplyCount) / sizeof(int);
       28:   94:    for(i = 0; i < arraySize; i++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       27:   95:        if(G.supplyCount[i] != prevG.supplyCount[i]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   96:            flag = 1;
        -:   97:        }
        -:   98:    }
        1:   99:    if(flag == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  100:        printf("Great! Smithy didn't alter the Victory and Kingdom piles.\n");
call    0 returned 100%
        -:  101:    else
        -:  102:    {
    #####:  103:        printf("Bug!!! Kingdom/Victory supplied have been altered\n");
call    0 never executed
    #####:  104:        bugCount++;
        -:  105:    }
        -:  106:
        -:  107:    // output the test results overall
        1:  108:    printf("---------------------------------------------------\n");
call    0 returned 100%
        1:  109:    printf("Final Testing results of refactored smithy card\n");
call    0 returned 100%
        1:  110:    printf("---------------------------------------------------\n");
call    0 returned 100%
        -:  111:
        1:  112:    if(bugCount == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  113:        printf("All tests passed for the refactored smithy card!\n\n");
call    0 never executed
        -:  114:    else
        1:  115:        printf("refactored smithy card failed for %d condition(s), check above for which ones.\n\n", bugCount);
call    0 returned 100%
        -:  116:
        1:  117:    return 0;
        -:  118:}
File 'dominion.c'
Lines executed:34.64% of 563
Branches executed:32.13% of 417
Taken at least once:28.54% of 417
Calls executed:15.00% of 100
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:6
        -:    0:Programs:6
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 5775 returned 100% blocks executed 83%
     5775:    8:int compare(const void* a, const void* b) {
     5775:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:    return 1;
     5775:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
     1540:   12:    return -1;
     4235:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 193 returned 100% blocks executed 97%
      193:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      193:   44:  SelectStream(1);
call    0 returned 100%
      193:   45:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:  
        -:   47:  //check number of players
      193:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:    {
        2:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      191:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     2101:   57:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:    {
    21010:   59:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:        {
    19100:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      191:   73:  if (numPlayers == 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   74:    {
      189:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
        2:   77:  else if (numPlayers == 3)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:   78:    {
        1:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
        1:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      191:   87:  if (numPlayers == 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   88:    {
      189:   89:      state->supplyCount[estate] = 8;
      189:   90:      state->supplyCount[duchy] = 8;
      189:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
        2:   95:      state->supplyCount[estate] = 12;
        2:   96:      state->supplyCount[duchy] = 12;
        2:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      191:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      191:  102:  state->supplyCount[silver] = 40;
      191:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
     4011:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:    {
    31515:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:	{
    29605:  110:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     1910:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
        -:  114:		{
      764:  115:		  if (numPlayers == 2){ 
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      378:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
        4:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     1528:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     1910:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    27695:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
      576:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:    {
      385:  140:      state->deckCount[i] = 0;
     1540:  141:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:	{
     1155:  143:	  state->deck[i][j] = estate;
     1155:  144:	  state->deckCount[i]++;
        -:  145:	}
     3080:  146:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:	{
     2695:  148:	  state->deck[i][j] = copper;
     2695:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
      576:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:    {
      385:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
      576:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      385:  166:      state->handCount[i] = 0;
      385:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
     5348:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:    {
     5157:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      191:  182:  state->outpostPlayed = 0;
      191:  183:  state->phase = 0;
      191:  184:  state->numActions = 1;
      191:  185:  state->numBuys = 1;
      191:  186:  state->playedCardCount = 0;
      191:  187:  state->whoseTurn = 0;
      191:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     1146:  192:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      955:  193:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:  }
        -:  195:
      191:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
      191:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 387 returned 100% blocks executed 100%
      387:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
      387:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
      387:  209:  if (state->deckCount[player] < 1)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2:  210:    return -1;
      385:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     4620:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     3850:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     3850:  216:    newDeck[newDeckPos] = state->deck[player][card];
     3850:  217:    newDeckPos++;
    14384:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 73%
branch  1 taken 27% (fallthrough)
    10534:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
     3850:  221:    state->deckCount[player]--;
        -:  222:  }
     4235:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     3850:  224:    state->deck[player][i] = newDeck[i];
     3850:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
      385:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 62 returned 100% blocks executed 100%
       62:  320:int supplyCount(int card, struct gameState *state) {
       62:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 2 returned 100% blocks executed 100%
        2:  346:int whoseTurn(struct gameState *state) {
        2:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 11 returned 100% blocks executed 100%
       11:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
       11:  395:  if (state->supplyCount[province] == 0)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
        -:  396:    {
        3:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
        8:  401:  j = 0;
      208:  402:  for (i = 0; i < 25; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  403:    {
      200:  404:      if (state->supplyCount[i] == 0)
branch  0 taken 9% (fallthrough)
branch  1 taken 92%
        -:  405:	{
       17:  406:	  j++;
        -:  407:	}
        -:  408:    }
        8:  409:  if ( j >= 3)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  410:    {
        4:  411:      return 1;
        -:  412:    }
        -:  413:
        4:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 965 returned 100% blocks executed 85%
      965:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
      965:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
        1:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
        1:  538:    state->deckCount[player] = state->discardCount[player];
        1:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
        1:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
        1:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
        1:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
        1:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
        1:  559:    if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
      964:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
      964:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
      964:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      964:  576:    state->deckCount[player]--;
      964:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
      964:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 27 returned 100% blocks executed 97%
       27:  583:int getCost(int cardNumber)
        -:  584:{
       27:  585:  switch( cardNumber ) 
branch  0 taken 4%
branch  1 taken 4%
branch  2 taken 4%
branch  3 taken 4%
branch  4 taken 4%
branch  5 taken 4%
branch  6 taken 4%
branch  7 taken 4%
branch  8 taken 4%
branch  9 taken 4%
branch 10 taken 4%
branch 11 taken 4%
branch 12 taken 4%
branch 13 taken 4%
branch 14 taken 4%
branch 15 taken 4%
branch 16 taken 4%
branch 17 taken 4%
branch 18 taken 4%
branch 19 taken 4%
branch 20 taken 4%
branch 21 taken 4%
branch 22 taken 4%
branch 23 taken 4%
branch 24 taken 4%
branch 25 taken 4%
branch 26 taken 4%
branch 27 taken 0%
        -:  586:    {
        -:  587:    case curse:
        1:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        1:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        1:  608:      return 4;
        -:  609:    case mine:
        1:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        1:  614:      return 4;
        -:  615:    case village:
        1:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        1:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        1:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        1:  630:      return 4;
        -:  631:    case embargo: 
        1:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        1:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:// Assignment 2 - refactor card #1: Adventurer
function adventurer_func called 1 returned 100% blocks executed 100%
        1:  647:int adventurer_func(struct gameState *state)
        -:  648:{
        -:  649:	int cardDrawn;
        1:  650:	int currentPlayer = whoseTurn(state);	
call    0 returned 100%
        1:  651:	int drawntreasure = 0;
        -:  652:	int temphand[MAX_HAND];// moved above the if statement
        1:  653:	int z = 0;// this is the counter for the temp hand
        -:  654:    
        8:  655:	while(drawntreasure <= 2) // BUG added!! - Changed to < to <= that what it could end up drawing extra treasure.
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        -:  656:	{
        -:  657:		//if the deck is empty we need to shuffle discard and add to deck
        6:  658:		if (state->deckCount[currentPlayer] <1)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        1:  659:			shuffle(currentPlayer, state);
call    0 returned 100%
        -:  660:		
        6:  661:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  662:		
        -:  663:			//top card of hand is most recently drawn card.
        6:  664:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  665:	
        6:  666:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        3:  667:				drawntreasure++;
        -:  668:			else
        -:  669:			{
        3:  670:				temphand[z] = cardDrawn;
        -:  671:				
        -:  672:				//this should just remove the top card (the most recently drawn one).
        3:  673:				state->handCount[currentPlayer]--; 
        3:  674:				z++;
        -:  675:			}
        -:  676:		}
        -:  677:      
        5:  678:		while(z - 1 >= 0)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  679:		{
        -:  680:			// discard all cards in play that have been drawn
        3:  681:			state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; 
        3:  682:			z = z - 1;
        -:  683:		}
        -:  684:		
        1:  685:		return 0;
        -:  686:}
        -:  687:
        -:  688:// Assignment 2 - refactor card #2: Council Room
function council_room_func called 0 returned 0% blocks executed 0%
    #####:  689:int council_room_func(int handPos, struct gameState *state)
        -:  690:{
        -:  691:	int i;
    #####:  692:	int currentPlayer = whoseTurn(state);	
call    0 never executed
        -:  693:	
        -:  694:	//+4 Cards
    #####:  695:	for (i = 1; i < 4; i++) // BUG added!!! = changed i=0 to i=1, which will result in 1 less card drawn.
branch  0 never executed
branch  1 never executed
    #####:  696:		drawCard(currentPlayer, state);
call    0 never executed
        -:  697:
        -:  698:	//+1 Buy
    #####:  699:	state->numBuys++;
        -:  700:	
        -:  701:	//Each other player draws a card
    #####:  702:	for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
    #####:  703:		if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
    #####:  704:			drawCard(i, state);
call    0 never executed
        -:  705:
        -:  706:	//put played card in played card pile
    #####:  707:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  708:
    #####:  709:	return 0;
        -:  710:}
        -:  711:
        -:  712:
        -:  713:// Assignment 2 - refactor card #3: Remodel
function remodel_func called 0 returned 0% blocks executed 0%
    #####:  714:int remodel_func(int choice1, int choice2, int handPos, struct gameState *state)
        -:  715:{
        -:  716:	int i;
        -:  717:	int j;
    #####:  718:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  719:    
    #####:  720:	j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  721:
    #####:  722:	if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  723:		return -1;
        -:  724:
    #####:  725:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  726:
        -:  727:	//discard card from hand
    #####:  728:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  729:
        -:  730:	//discard trashed card
    #####:  731:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  732:	{
    #####:  733:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  734:	    {
    #####:  735:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  736:			break;
        -:  737:	    }
        -:  738:	}
        -:  739:	
    #####:  740:	return 0;
        -:  741:}
        -:  742:
        -:  743:// Assignment 2 - refactor card #4: Smithy
function smithy_func called 1 returned 100% blocks executed 100%
        1:  744:int smithy_func(int handPos, struct gameState *state)
        -:  745:{
        -:  746:	int i;
        1:  747:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  748:	
        -:  749:	//+3 Cards
        5:  750:	for (i = 0; i <= 3; i++) // BUG added!!! = changed < to <=, which will result in 1 more card drawn.
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        4:  751:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  752:
        -:  753:	//discard card from hand
        1:  754:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  755:	
        1:  756:	return 0;
        -:  757:}
        -:  758:
        -:  759:// Assignment 2 - refactor card #5: Village
function village_func called 0 returned 0% blocks executed 0%
    #####:  760:int village_func(int handPos, struct gameState *state)
        -:  761:{
    #####:  762:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  763:	
        -:  764:	//+1 Card
    #####:  765:	drawCard(currentPlayer, state);
call    0 never executed
        -:  766:			
        -:  767:	//+2 Actions
    #####:  768:	state->numActions = state->numActions + 22; // BUG added!!! = changed 2 to 22, which will result in +22 actions instead of just 2.
        -:  769:			
        -:  770:	//discard played card from hand
    #####:  771:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  772:
    #####:  773:	return 0;
        -:  774:}
        -:  775:
        -:  776:// cardEffect - for assignment 2 - I refactored 5 of these cards (adventurer, 
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  777:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  778:{
        -:  779:  int i;
        -:  780:  int j;
        -:  781:  int k;
        -:  782:  int x;
        -:  783:  int index;
    #####:  784:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  785:  int nextPlayer = currentPlayer + 1;
        -:  786:
    #####:  787:  int tributeRevealedCards[2] = {-1, -1};
        -:  788:  int temphand[MAX_HAND];// moved above the if statement
        -:  789:
    #####:  790:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  791:    nextPlayer = 0;
        -:  792:  }
        -:  793:  
        -:  794:  /* these variables are no longer needed after refactoring
        -:  795:  
        -:  796:    int drawntreasure=0;
        -:  797:	int cardDrawn;
        -:  798:	int z = 0;// this is the counter for the temp hand
        -:  799:	*/
        -:  800:	
        -:  801:  //uses switch to select card and perform actions
    #####:  802:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  803:    {
        -:  804:    case adventurer:
        -:  805:	
    #####:  806:		adventurer_func(state);
call    0 never executed
        -:  807:		
        -:  808:		/* commented out code that is no longer needed due to refactoring
        -:  809:		while(drawntreasure<2)
        -:  810:		{
        -:  811:			//if the deck is empty we need to shuffle discard and add to deck
        -:  812:			if (state->deckCount[currentPlayer] <1)
        -:  813:				shuffle(currentPlayer, state);
        -:  814:		
        -:  815:			drawCard(currentPlayer, state);
        -:  816:		
        -:  817:			//top card of hand is most recently drawn card.
        -:  818:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  819:	
        -:  820:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:  821:				drawntreasure++;
        -:  822:			else
        -:  823:			{
        -:  824:				temphand[z]=cardDrawn;
        -:  825:				
        -:  826:				//this should just remove the top card (the most recently drawn one).
        -:  827:				state->handCount[currentPlayer]--; 
        -:  828:				z++;
        -:  829:			}
        -:  830:		}
        -:  831:      
        -:  832:		while(z-1>=0)
        -:  833:		{
        -:  834:			// discard all cards in play that have been drawn
        -:  835:			state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; 
        -:  836:			z=z-1;
        -:  837:		}
        -:  838:		return 0;
        -:  839:		*/
        -:  840:	
        -:  841:    case council_room:
        -:  842:		
    #####:  843:		council_room_func(handPos, state);
call    0 never executed
        -:  844:		
        -:  845:		/* commented out code that is no longer needed due to refactoring
        -:  846:		
        -:  847:		//+4 Cards
        -:  848:		  for (i = 0; i < 4; i++)
        -:  849:		{
        -:  850:		  drawCard(currentPlayer, state);
        -:  851:		}
        -:  852:				
        -:  853:		  //+1 Buy
        -:  854:		  state->numBuys++;
        -:  855:				
        -:  856:		  //Each other player draws a card
        -:  857:		  for (i = 0; i < state->numPlayers; i++)
        -:  858:		{
        -:  859:		  if ( i != currentPlayer )
        -:  860:			{
        -:  861:			  drawCard(i, state);
        -:  862:			}
        -:  863:		}
        -:  864:				
        -:  865:		  //put played card in played card pile
        -:  866:		  discardCard(handPos, currentPlayer, state, 0);
        -:  867:				
        -:  868:		  return 0;
        -:  869:		*/
        -:  870:		
        -:  871:    case feast:
        -:  872:      //gain card with cost up to 5
        -:  873:      //Backup hand
    #####:  874:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  875:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  876:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  877:      }
        -:  878:      //Backup hand
        -:  879:
        -:  880:      //Update Coins for Buy
    #####:  881:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  882:      x = 1;//Condition to loop on
    #####:  883:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  884:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  885:	  if (DEBUG)
        -:  886:	    printf("None of that card left, sorry!\n");
        -:  887:
        -:  888:	  if (DEBUG){
        -:  889:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  890:	  }
        -:  891:	}
    #####:  892:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  893:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  894:
        -:  895:	  if (DEBUG){
        -:  896:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  897:	  }
        -:  898:	}
        -:  899:	else{
        -:  900:
        -:  901:	  if (DEBUG){
        -:  902:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  903:	  }
        -:  904:
    #####:  905:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  906:	  x = 0;//No more buying cards
        -:  907:
        -:  908:	  if (DEBUG){
        -:  909:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  910:	  }
        -:  911:
        -:  912:	}
        -:  913:      }     
        -:  914:
        -:  915:      //Reset Hand
    #####:  916:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  917:	state->hand[currentPlayer][i] = temphand[i];
    #####:  918:	temphand[i] = -1;
        -:  919:      }
        -:  920:      //Reset Hand
        -:  921:      			
    #####:  922:      return 0;
        -:  923:			
        -:  924:    case gardens:
    #####:  925:      return -1;
        -:  926:			
        -:  927:    case mine:
    #####:  928:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  929:
    #####:  930:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  931:	{
    #####:  932:	  return -1;
        -:  933:	}
        -:  934:		
    #####:  935:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  936:	{
    #####:  937:	  return -1;
        -:  938:	}
        -:  939:
    #####:  940:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  941:	{
    #####:  942:	  return -1;
        -:  943:	}
        -:  944:
    #####:  945:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  946:
        -:  947:      //discard card from hand
    #####:  948:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  949:
        -:  950:      //discard trashed card
    #####:  951:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  952:	{
    #####:  953:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  954:	    {
    #####:  955:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  956:	      break;
        -:  957:	    }
        -:  958:	}
        -:  959:			
    #####:  960:      return 0;
        -:  961:			
        -:  962:    case remodel:
        -:  963:	
    #####:  964:		remodel_func(choice1, choice2, handPos, state);
call    0 never executed
        -:  965:		
        -:  966:		/* commented out code that is no longer needed due to refactoring
        -:  967:			
        -:  968:		  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  969:
        -:  970:		  if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  971:		{
        -:  972:		  return -1;
        -:  973:		}
        -:  974:
        -:  975:		  gainCard(choice2, state, 0, currentPlayer);
        -:  976:
        -:  977:		  //discard card from hand
        -:  978:		  discardCard(handPos, currentPlayer, state, 0);
        -:  979:
        -:  980:		  //discard trashed card
        -:  981:		  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  982:		{
        -:  983:		  if (state->hand[currentPlayer][i] == j)
        -:  984:			{
        -:  985:			  discardCard(i, currentPlayer, state, 0);			
        -:  986:			  break;
        -:  987:			}
        -:  988:		}
        -:  989:
        -:  990:		  return 0;
        -:  991:		*/
        -:  992:		
        -:  993:    case smithy:
        -:  994:	
    #####:  995:		smithy_func(handPos, state);
call    0 never executed
        -:  996:		
        -:  997:		/* commented out code that is no longer needed due to refactoring
        -:  998:			
        -:  999:		  //+3 Cards
        -: 1000:		  for (i = 0; i < 3; i++)
        -: 1001:		{
        -: 1002:		  drawCard(currentPlayer, state);
        -: 1003:		}
        -: 1004:				
        -: 1005:		  //discard card from hand
        -: 1006:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1007:		  return 0;
        -: 1008:		*/
        -: 1009:			
        -: 1010:    case village:
        -: 1011:	
    #####: 1012:		village_func(handPos, state);
call    0 never executed
        -: 1013:		
        -: 1014:		/* commented out code that is no longer needed due to refactoring
        -: 1015:			
        -: 1016:		  //+1 Card
        -: 1017:		  drawCard(currentPlayer, state);
        -: 1018:				
        -: 1019:		  //+2 Actions
        -: 1020:		  state->numActions = state->numActions + 2;
        -: 1021:				
        -: 1022:		  //discard played card from hand
        -: 1023:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1024:		  return 0;
        -: 1025:		*/
        -: 1026:		
        -: 1027:    case baron:
    #####: 1028:      state->numBuys++;//Increase buys by 1!
    #####: 1029:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####: 1030:	int p = 0;//Iterator for hand!
    #####: 1031:	int card_not_discarded = 1;//Flag for discard set!
    #####: 1032:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####: 1033:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####: 1034:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####: 1035:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1036:	    state->discardCount[currentPlayer]++;
    #####: 1037:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####: 1038:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -: 1039:	    }
    #####: 1040:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1041:	    state->handCount[currentPlayer]--;
    #####: 1042:	    card_not_discarded = 0;//Exit the loop
        -: 1043:	  }
    #####: 1044:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -: 1045:	    if(DEBUG) {
        -: 1046:	      printf("No estate cards in your hand, invalid choice\n");
        -: 1047:	      printf("Must gain an estate if there are any\n");
        -: 1048:	    }
    #####: 1049:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1050:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####: 1051:	      state->supplyCount[estate]--;//Decrement estates
    #####: 1052:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1053:		isGameOver(state);
call    0 never executed
        -: 1054:	      }
        -: 1055:	    }
    #####: 1056:	    card_not_discarded = 0;//Exit the loop
        -: 1057:	  }
        -: 1058:			    
        -: 1059:	  else{
    #####: 1060:	    p++;//Next card
        -: 1061:	  }
        -: 1062:	}
        -: 1063:      }
        -: 1064:			    
        -: 1065:      else{
    #####: 1066:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1067:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####: 1068:	  state->supplyCount[estate]--;//Decrement Estates
    #####: 1069:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1070:	    isGameOver(state);
call    0 never executed
        -: 1071:	  }
        -: 1072:	}
        -: 1073:      }
        -: 1074:	    
        -: 1075:      
    #####: 1076:      return 0;
        -: 1077:		
        -: 1078:    case great_hall:
        -: 1079:      //+1 Card
    #####: 1080:      drawCard(currentPlayer, state);
call    0 never executed
        -: 1081:			
        -: 1082:      //+1 Actions
    #####: 1083:      state->numActions++;
        -: 1084:			
        -: 1085:      //discard card from hand
    #####: 1086:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1087:      return 0;
        -: 1088:		
        -: 1089:    case minion:
        -: 1090:      //+1 action
    #####: 1091:      state->numActions++;
        -: 1092:			
        -: 1093:      //discard card from hand
    #####: 1094:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1095:			
    #####: 1096:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -: 1097:	{
    #####: 1098:	  state->coins = state->coins + 2;
        -: 1099:	}
        -: 1100:			
    #####: 1101:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -: 1102:	{
        -: 1103:	  //discard hand
    #####: 1104:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1105:	    {
    #####: 1106:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1107:	    }
        -: 1108:				
        -: 1109:	  //draw 4
    #####: 1110:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1111:	    {
    #####: 1112:	      drawCard(currentPlayer, state);
call    0 never executed
        -: 1113:	    }
        -: 1114:				
        -: 1115:	  //other players discard hand and redraw if hand size > 4
    #####: 1116:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1117:	    {
    #####: 1118:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1119:		{
    #####: 1120:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1121:		    {
        -: 1122:		      //discard hand
    #####: 1123:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1124:			{
    #####: 1125:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1126:			}
        -: 1127:							
        -: 1128:		      //draw 4
    #####: 1129:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1130:			{
    #####: 1131:			  drawCard(i, state);
call    0 never executed
        -: 1132:			}
        -: 1133:		    }
        -: 1134:		}
        -: 1135:	    }
        -: 1136:				
        -: 1137:	}
    #####: 1138:      return 0;
        -: 1139:		
        -: 1140:    case steward:
    #####: 1141:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1142:	{
        -: 1143:	  //+2 cards
    #####: 1144:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1145:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1146:	}
    #####: 1147:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1148:	{
        -: 1149:	  //+2 coins
    #####: 1150:	  state->coins = state->coins + 2;
        -: 1151:	}
        -: 1152:      else
        -: 1153:	{
        -: 1154:	  //trash 2 cards in hand
    #####: 1155:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1156:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1157:	}
        -: 1158:			
        -: 1159:      //discard card from hand
    #####: 1160:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1161:      return 0;
        -: 1162:		
        -: 1163:    case tribute:
    #####: 1164:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1165:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1166:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1167:	  state->deckCount[nextPlayer]--;
        -: 1168:	}
    #####: 1169:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1170:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1171:	  state->discardCount[nextPlayer]--;
        -: 1172:	}
        -: 1173:	else{
        -: 1174:	  //No Card to Reveal
        -: 1175:	  if (DEBUG){
        -: 1176:	    printf("No cards to reveal\n");
        -: 1177:	  }
        -: 1178:	}
        -: 1179:      }
        -: 1180:	    
        -: 1181:      else{
    #####: 1182:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1183:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1184:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1185:	    state->deckCount[nextPlayer]++;
    #####: 1186:	    state->discard[nextPlayer][i] = -1;
    #####: 1187:	    state->discardCount[nextPlayer]--;
        -: 1188:	  }
        -: 1189:			    
    #####: 1190:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1191:	} 
    #####: 1192:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1193:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1194:	state->deckCount[nextPlayer]--;
    #####: 1195:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1196:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1197:	state->deckCount[nextPlayer]--;
        -: 1198:      }    
        -: 1199:		       
    #####: 1200:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1201:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1202:	state->playedCardCount++;
    #####: 1203:	tributeRevealedCards[1] = -1;
        -: 1204:      }
        -: 1205:
    #####: 1206:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1207:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1208:	  state->coins += 2;
        -: 1209:	}
        -: 1210:		    
    #####: 1211:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1212:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1213:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1214:	}
        -: 1215:	else{//Action Card
    #####: 1216:	  state->numActions = state->numActions + 2;
        -: 1217:	}
        -: 1218:      }
        -: 1219:	    
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case ambassador:
    #####: 1223:      j = 0;		//used to check if player has enough cards to discard
        -: 1224:
    #####: 1225:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1226:	{
    #####: 1227:	  return -1;				
        -: 1228:	}
        -: 1229:
    #####: 1230:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1231:	{
    #####: 1232:	  return -1;
        -: 1233:	}
        -: 1234:
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1238:	    {
    #####: 1239:	      j++;
        -: 1240:	    }
        -: 1241:	}
    #####: 1242:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1243:	{
    #####: 1244:	  return -1;				
        -: 1245:	}
        -: 1246:
        -: 1247:      if (DEBUG) 
        -: 1248:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1249:
        -: 1250:      //increase supply count for choosen card by amount being discarded
    #####: 1251:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1252:			
        -: 1253:      //each other player gains a copy of revealed card
    #####: 1254:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:	{
    #####: 1256:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1257:	    {
    #####: 1258:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1259:	    }
        -: 1260:	}
        -: 1261:
        -: 1262:      //discard played card from hand
    #####: 1263:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1264:
        -: 1265:      //trash copies of cards returned to supply
    #####: 1266:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1267:	{
    #####: 1268:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1269:	    {
    #####: 1270:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1271:		{
    #####: 1272:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1273:		  break;
        -: 1274:		}
        -: 1275:	    }
        -: 1276:	}			
        -: 1277:
    #####: 1278:      return 0;
        -: 1279:		
        -: 1280:    case cutpurse:
        -: 1281:
    #####: 1282:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1283:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1284:	{
    #####: 1285:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1286:	    {
    #####: 1287:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1288:		{
    #####: 1289:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1290:		    {
    #####: 1291:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1292:		      break;
        -: 1293:		    }
    #####: 1294:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1295:		    {
    #####: 1296:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1297:			{
        -: 1298:			  if (DEBUG)
        -: 1299:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1300:			}	
    #####: 1301:		      break;
        -: 1302:		    }		
        -: 1303:		}
        -: 1304:					
        -: 1305:	    }
        -: 1306:				
        -: 1307:	}				
        -: 1308:
        -: 1309:      //discard played card from hand
    #####: 1310:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1311:
    #####: 1312:      return 0;
        -: 1313:
        -: 1314:		
        -: 1315:    case embargo: 
        -: 1316:      //+2 Coins
    #####: 1317:      state->coins = state->coins + 2;
        -: 1318:			
        -: 1319:      //see if selected pile is in play
    #####: 1320:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1321:	{
    #####: 1322:	  return -1;
        -: 1323:	}
        -: 1324:			
        -: 1325:      //add embargo token to selected supply pile
    #####: 1326:      state->embargoTokens[choice1]++;
        -: 1327:			
        -: 1328:      //trash card
    #####: 1329:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1330:      return 0;
        -: 1331:		
        -: 1332:    case outpost:
        -: 1333:      //set outpost flag
    #####: 1334:      state->outpostPlayed++;
        -: 1335:			
        -: 1336:      //discard card
    #####: 1337:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1338:      return 0;
        -: 1339:		
        -: 1340:    case salvager:
        -: 1341:      //+1 buy
    #####: 1342:      state->numBuys++;
        -: 1343:			
    #####: 1344:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1345:	{
        -: 1346:	  //gain coins equal to trashed card
    #####: 1347:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1348:	  //trash card
    #####: 1349:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1350:	}
        -: 1351:			
        -: 1352:      //discard card
    #####: 1353:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1354:      return 0;
        -: 1355:		
        -: 1356:    case sea_hag:
    #####: 1357:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1358:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1359:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1360:	  state->discardCount[i]++;
    #####: 1361:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1362:	}
        -: 1363:      }
    #####: 1364:      return 0;
        -: 1365:		
        -: 1366:    case treasure_map:
        -: 1367:      //search hand for another treasure_map
    #####: 1368:      index = -1;
    #####: 1369:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1370:	{
    #####: 1371:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1372:	    {
    #####: 1373:	      index = i;
    #####: 1374:	      break;
        -: 1375:	    }
        -: 1376:	}
    #####: 1377:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1378:	{
        -: 1379:	  //trash both treasure cards
    #####: 1380:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1381:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1382:
        -: 1383:	  //gain 4 Gold cards
    #####: 1384:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1385:	    {
    #####: 1386:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1387:	    }
        -: 1388:				
        -: 1389:	  //return success
    #####: 1390:	  return 1;
        -: 1391:	}
        -: 1392:			
        -: 1393:      //no second treasure_map found in hand
    #####: 1394:      return -1;
        -: 1395:    }
        -: 1396:	
    #####: 1397:  return -1;
        -: 1398:}
        -: 1399:
function discardCard called 1 returned 100% blocks executed 78%
        1: 1400:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1401:{
        -: 1402:	
        -: 1403:  //if card is not trashed, added to Played pile 
        1: 1404:  if (trashFlag < 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1405:    {
        -: 1406:      //add card to played pile
        1: 1407:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
        1: 1408:      state->playedCardCount++;
        -: 1409:    }
        -: 1410:	
        -: 1411:  //set played card to -1
        1: 1412:  state->hand[currentPlayer][handPos] = -1;
        -: 1413:	
        -: 1414:  //remove card from player's hand
        1: 1415:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1416:    {
        -: 1417:      //reduce number of cards in hand
    #####: 1418:      state->handCount[currentPlayer]--;
        -: 1419:    }
        1: 1420:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1421:    {
        -: 1422:      //reduce number of cards in hand
    #####: 1423:      state->handCount[currentPlayer]--;
        -: 1424:    }
        -: 1425:  else 	
        -: 1426:    {
        -: 1427:      //replace discarded card with last card in hand
        1: 1428:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1429:      //set last card to -1
        1: 1430:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1431:      //reduce number of cards in hand
        1: 1432:      state->handCount[currentPlayer]--;
        -: 1433:    }
        -: 1434:	
        1: 1435:  return 0;
        -: 1436:}
        -: 1437:
function gainCard called 2 returned 100% blocks executed 70%
        2: 1438:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1439:{
        -: 1440:  //Note: supplyPos is enum of choosen card
        -: 1441:	
        -: 1442:  //check if supply pile is empty (0) or card is not used in game (-1)
        2: 1443:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1444:    {
    #####: 1445:      return -1;
        -: 1446:    }
        -: 1447:	
        -: 1448:  //added card for [whoseTurn] current player:
        -: 1449:  // toFlag = 0 : add to discard
        -: 1450:  // toFlag = 1 : add to deck
        -: 1451:  // toFlag = 2 : add to hand
        -: 1452:
        2: 1453:  if (toFlag == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1454:    {
    #####: 1455:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1456:      state->deckCount[player]++;
        -: 1457:    }
        2: 1458:  else if (toFlag == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1459:    {
        2: 1460:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
        2: 1461:      state->handCount[player]++;
        -: 1462:    }
        -: 1463:  else
        -: 1464:    {
    #####: 1465:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1466:      state->discardCount[player]++;
        -: 1467:    }
        -: 1468:	
        -: 1469:  //decrease number in supply pile
        2: 1470:  state->supplyCount[supplyPos]--;
        -: 1471:	 
        2: 1472:  return 0;
        -: 1473:}
        -: 1474:
function updateCoins called 587 returned 100% blocks executed 100%
      587: 1475:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1476:{
        -: 1477:  int i;
        -: 1478:	
        -: 1479:  //reset coin count
      587: 1480:  state->coins = 0;
        -: 1481:
        -: 1482:  //add coins for each Treasure card in player's hand
     2862: 1483:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 79%
branch  1 taken 21% (fallthrough)
        -: 1484:    {
     2275: 1485:      if (state->hand[player][i] == copper)
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
        -: 1486:	{
     1281: 1487:	  state->coins += 1;
        -: 1488:	}
      994: 1489:      else if (state->hand[player][i] == silver)
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
        -: 1490:	{
      418: 1491:	  state->coins += 2;
        -: 1492:	}
      576: 1493:      else if (state->hand[player][i] == gold)
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
        -: 1494:	{
      374: 1495:	  state->coins += 3;
        -: 1496:	}	
        -: 1497:    }	
        -: 1498:
        -: 1499:  //add bonus
      587: 1500:  state->coins += bonus;
        -: 1501:
      587: 1502:  return 0;
        -: 1503:}
        -: 1504:
        -: 1505:
        -: 1506://end of dominion.c
        -: 1507:
cardtest3.c:

Testing refactored Council Room card function
-----------------------------------------------

Checking hand count is correct after using refactored Council Room card.
Previous hand count: 6, After Council Room: 8
Expected hand count after Council Room: 9 (+3 = +4 drawn from Council Room and -1 from discarding Council Room.
Bug!!! Ended with the incorrect number of cards in hand after Council Room.

Checking if refactored Council Room card drew enough cards to hand.
Previous deck count: 5, After Council Room: 2
Council Room drew: 3 cards. Expected to draw 4 cards.
Bug!!! Council Room didn't draw correct nunmber of cards from the deck.

Checking if refactored Council Room card gave player another buy.
Previous buy count: 1, After Council Room: 2
Expected to get +1 buys.
Great! Council Room did add a buy for player.

Checking if refactored Council Room card altered other player's hand.
Great! Other player correctly drew a card.

Checking if refactored Council Room card altered the Victory and Kingdom piles.
Great! Council Room didn't alter the Victory and Kingdom piles.
---------------------------------------------------
Final Testing results of refactored Council Room card
---------------------------------------------------
Refactored Council Room card failed for 2 condition(s), check above for which ones.

File 'cardtest3.c'
Lines executed:77.05% of 61
Branches executed:100.00% of 20
Taken at least once:55.00% of 20
Calls executed:76.47% of 34
Creating 'cardtest3.c.gcov'

        -:    0:Source:cardtest3.c
        -:    0:Graph:cardtest3.gcno
        -:    0:Data:cardtest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:
        -:    2:/* -----------------------------------------------------------------------
        -:    3: * CS362-004 Summer 2017 Assignment 3
        -:    4: * cardtest3.c
        -:    5: * 
        -:    6: * Patrick Kwong
        -:    7: * kwongp@oregonstate.edu
        -:    8: *
        -:    9: * Unit test for my refactored council_room card function: council_room_func
        -:   10: * player that plays council_room draws 4 cards, other players draw 1 card
        -:   11: * player gets a extra buy
        -:   12: * Used provided cardtest4.c and testUpdateCoins.c examples
        -:   13: * -----------------------------------------------------------------------
        -:   14: * Include the following lines in the makefile:
        -:   15: *
        -:   16: * cardtest3: cardtest3.c dominion.o rngs.o
        -:   17: *      gcc -o cardtest3 -g cardtest3.c dominion.o rngs.o $(CFLAGS)
        -:   18: */
        -:   19:
        -:   20:#include "dominion.h"
        -:   21:#include "dominion_helpers.h"
        -:   22:#include <string.h>
        -:   23:#include <stdio.h>
        -:   24:#include <assert.h>
        -:   25:#include "rngs.h"
        -:   26:#include <stdlib.h>
        -:   27:#include <time.h>
        -:   28:#include <math.h>
        -:   29:
function main called 1 returned 100% blocks executed 75%
        1:   30:int main() {
        -:   31:    int i;
        -:   32:    int seed;
        1:   33:    int numPlayer = 2;
        1:   34:    int bugCount = 0;
        1:   35:    int flag = 0;
        1:   36:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   37:               , remodel, smithy, village, baron, great_hall};
        -:   38:    struct gameState G, prevG;
        1:   39:    seed = (rand() % 100);
call    0 returned 100%
        -:   40:
        1:   41:    printf("\nTesting refactored Council Room card function\n");
call    0 returned 100%
        1:   42:    printf("-----------------------------------------------\n");
call    0 returned 100%
        -:   43:    
        1:   44:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   45:    initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:   46:
        1:   47:    gainCard(council_room, &G, 2, 0); // add council_room card to player 1's hand
call    0 returned 100%
        1:   48:    memcpy(&prevG, &G, sizeof(struct gameState)); //create clone of game state to run tests on
        -:   49:
        1:   50:    council_room_func(G.handCount[0], &G);
call    0 returned 100%
        -:   51:
        -:   52:    // check if hand count correct after Council Room 
        1:   53:    printf("\nChecking hand count is correct after using refactored Council Room card.\n");
call    0 returned 100%
        1:   54:    printf("Previous hand count: %d, After Council Room: %d\n", prevG.handCount[0], G.handCount[0]);
call    0 returned 100%
        1:   55:    printf("Expected hand count after Council Room: 9 (+3 = +4 drawn from Council Room and -1 from discarding Council Room.\n");
call    0 returned 100%
        1:   56:    if(prevG.handCount[0]+3 != G.handCount[0]){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   57:        printf("Bug!!! Ended with the incorrect number of cards in hand after Council Room.\n");
call    0 returned 100%
        1:   58:        bugCount++;
        -:   59:    }
        -:   60:    else
    #####:   61:        printf("Great! Ended with the correct number of cards in hand after Council Room.\n");
call    0 never executed
        -:   62:
        -:   63:    // check if Council Room drew the correct cards from deck
        1:   64:    printf("\nChecking if refactored Council Room card drew enough cards to hand.\n");
call    0 returned 100%
        1:   65:    printf("Previous deck count: %d, After Council Room: %d\n", prevG.deckCount[0], G.deckCount[0]);
call    0 returned 100%
        1:   66:    printf("Council Room drew: %d cards. Expected to draw 4 cards.\n", prevG.deckCount[0] - G.deckCount[0]);
call    0 returned 100%
        1:   67:    if((prevG.deckCount[0] - G.deckCount[0]) != 4){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   68:        printf("Bug!!! Council Room didn't draw correct nunmber of cards from the deck.\n");
call    0 returned 100%
        1:   69:        bugCount++;
        -:   70:    }
        -:   71:    else
    #####:   72:        printf("Great! Council Room drew correct number of cards from deck.\n");
call    0 never executed
        -:   73:
        -:   74:    // check if Council Room gave player another buy
        1:   75:    printf("\nChecking if refactored Council Room card gave player another buy.\n");
call    0 returned 100%
        1:   76:    printf("Previous buy count: %d, After Council Room: %d\n", prevG.numBuys, G.numBuys);
call    0 returned 100%
        1:   77:    printf("Expected to get +1 buys.\n");
call    0 returned 100%
        1:   78:    if((G.numBuys - prevG.numBuys) != 1){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   79:        printf("Bug!!! Council Room didn't add a buy for player.\n");
call    0 never executed
    #####:   80:        bugCount++;
        -:   81:    }
        -:   82:    else
        1:   83:        printf("Great! Council Room did add a buy for player.\n");
call    0 returned 100%
        -:   84:
        -:   85:    // check if Council Room altered other player's correctly: +1 draw, -1 in deck, same discard 
        1:   86:    printf("\nChecking if refactored Council Room card altered other player's hand.\n");
call    0 returned 100%
        1:   87:    if(prevG.handCount[1] != G.handCount[1] - 1){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   88:        printf("Bug!!! Other player add card to hand.\n");
call    0 never executed
    #####:   89:        bugCount++;
        -:   90:    }
        1:   91:    else if(prevG.deckCount[1] != G.deckCount[1] + 1){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   92:        printf("Bug!!! Other player didn't draw a card.\n");
call    0 never executed
    #####:   93:        bugCount++;
        -:   94:    }
        1:   95:    else if(prevG.discardCount[1] != G.discardCount[1]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   96:        printf("Bug!!! Council Room altered other player's discard pile.\n");
call    0 never executed
    #####:   97:        bugCount++;
        -:   98:    }
        -:   99:    else
        1:  100:        printf("Great! Other player correctly drew a card.\n");
call    0 returned 100%
        -:  101:    
        -:  102:    // check if Council Room altered the victory and kingdom piles
        1:  103:    printf("\nChecking if refactored Council Room card altered the Victory and Kingdom piles.\n");
call    0 returned 100%
        1:  104:    int arraySize = sizeof(G.supplyCount) / sizeof(int);
       28:  105:    for(i = 0; i < arraySize; i++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       27:  106:        if(G.supplyCount[i] != prevG.supplyCount[i]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  107:            flag = 1;
        -:  108:        }
        -:  109:    }
        1:  110:    if(flag == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  111:        printf("Great! Council Room didn't alter the Victory and Kingdom piles.\n");
call    0 returned 100%
        -:  112:    else
        -:  113:    {
    #####:  114:        printf("Bug!!! Kingdom/Victory supplied have been altered!\n");
call    0 never executed
    #####:  115:        bugCount++;
        -:  116:    }
        -:  117:
        -:  118:    // output the test results overall
        1:  119:    printf("---------------------------------------------------\n");
call    0 returned 100%
        1:  120:    printf("Final Testing results of refactored Council Room card\n");
call    0 returned 100%
        1:  121:    printf("---------------------------------------------------\n");
call    0 returned 100%
        -:  122:
        1:  123:    if(bugCount == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  124:        printf("All tests passed for the refactored Council Room card!\n\n");
call    0 never executed
        -:  125:    else
        1:  126:        printf("Refactored Council Room card failed for %d condition(s), check above for which ones.\n\n", bugCount);
call    0 returned 100%
        -:  127:
        1:  128:    return 0;
        -:  129:}
File 'dominion.c'
Lines executed:36.41% of 563
Branches executed:33.57% of 417
Taken at least once:29.98% of 417
Calls executed:19.00% of 100
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:7
        -:    0:Programs:7
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 5805 returned 100% blocks executed 83%
     5805:    8:int compare(const void* a, const void* b) {
     5805:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:    return 1;
     5805:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
     1548:   12:    return -1;
     4257:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 194 returned 100% blocks executed 97%
      194:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      194:   44:  SelectStream(1);
call    0 returned 100%
      194:   45:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:  
        -:   47:  //check number of players
      194:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:    {
        2:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      192:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     2112:   57:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:    {
    21120:   59:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:        {
    19200:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      192:   73:  if (numPlayers == 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   74:    {
      190:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
        2:   77:  else if (numPlayers == 3)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:   78:    {
        1:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
        1:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      192:   87:  if (numPlayers == 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   88:    {
      190:   89:      state->supplyCount[estate] = 8;
      190:   90:      state->supplyCount[duchy] = 8;
      190:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
        2:   95:      state->supplyCount[estate] = 12;
        2:   96:      state->supplyCount[duchy] = 12;
        2:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      192:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      192:  102:  state->supplyCount[silver] = 40;
      192:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
     4032:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:    {
    31680:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:	{
    29760:  110:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     1920:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
        -:  114:		{
      768:  115:		  if (numPlayers == 2){ 
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      380:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
        4:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     1536:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     1920:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    27840:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
      579:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:    {
      387:  140:      state->deckCount[i] = 0;
     1548:  141:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:	{
     1161:  143:	  state->deck[i][j] = estate;
     1161:  144:	  state->deckCount[i]++;
        -:  145:	}
     3096:  146:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:	{
     2709:  148:	  state->deck[i][j] = copper;
     2709:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
      579:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:    {
      387:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
      579:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      387:  166:      state->handCount[i] = 0;
      387:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
     5376:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:    {
     5184:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      192:  182:  state->outpostPlayed = 0;
      192:  183:  state->phase = 0;
      192:  184:  state->numActions = 1;
      192:  185:  state->numBuys = 1;
      192:  186:  state->playedCardCount = 0;
      192:  187:  state->whoseTurn = 0;
      192:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     1152:  192:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      960:  193:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:  }
        -:  195:
      192:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
      192:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 389 returned 100% blocks executed 100%
      389:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
      389:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
      389:  209:  if (state->deckCount[player] < 1)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2:  210:    return -1;
      387:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     4644:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     3870:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     3870:  216:    newDeck[newDeckPos] = state->deck[player][card];
     3870:  217:    newDeckPos++;
    14462:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 73%
branch  1 taken 27% (fallthrough)
    10592:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
     3870:  221:    state->deckCount[player]--;
        -:  222:  }
     4257:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     3870:  224:    state->deck[player][i] = newDeck[i];
     3870:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
      387:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 63 returned 100% blocks executed 100%
       63:  320:int supplyCount(int card, struct gameState *state) {
       63:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 3 returned 100% blocks executed 100%
        3:  346:int whoseTurn(struct gameState *state) {
        3:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 11 returned 100% blocks executed 100%
       11:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
       11:  395:  if (state->supplyCount[province] == 0)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
        -:  396:    {
        3:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
        8:  401:  j = 0;
      208:  402:  for (i = 0; i < 25; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  403:    {
      200:  404:      if (state->supplyCount[i] == 0)
branch  0 taken 9% (fallthrough)
branch  1 taken 92%
        -:  405:	{
       17:  406:	  j++;
        -:  407:	}
        -:  408:    }
        8:  409:  if ( j >= 3)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  410:    {
        4:  411:      return 1;
        -:  412:    }
        -:  413:
        4:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 974 returned 100% blocks executed 85%
      974:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
      974:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
        1:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
        1:  538:    state->deckCount[player] = state->discardCount[player];
        1:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
        1:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
        1:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
        1:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
        1:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
        1:  559:    if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
      973:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
      973:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
      973:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      973:  576:    state->deckCount[player]--;
      973:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
      973:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 27 returned 100% blocks executed 97%
       27:  583:int getCost(int cardNumber)
        -:  584:{
       27:  585:  switch( cardNumber ) 
branch  0 taken 4%
branch  1 taken 4%
branch  2 taken 4%
branch  3 taken 4%
branch  4 taken 4%
branch  5 taken 4%
branch  6 taken 4%
branch  7 taken 4%
branch  8 taken 4%
branch  9 taken 4%
branch 10 taken 4%
branch 11 taken 4%
branch 12 taken 4%
branch 13 taken 4%
branch 14 taken 4%
branch 15 taken 4%
branch 16 taken 4%
branch 17 taken 4%
branch 18 taken 4%
branch 19 taken 4%
branch 20 taken 4%
branch 21 taken 4%
branch 22 taken 4%
branch 23 taken 4%
branch 24 taken 4%
branch 25 taken 4%
branch 26 taken 4%
branch 27 taken 0%
        -:  586:    {
        -:  587:    case curse:
        1:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        1:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        1:  608:      return 4;
        -:  609:    case mine:
        1:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        1:  614:      return 4;
        -:  615:    case village:
        1:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        1:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        1:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        1:  630:      return 4;
        -:  631:    case embargo: 
        1:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        1:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:// Assignment 2 - refactor card #1: Adventurer
function adventurer_func called 1 returned 100% blocks executed 100%
        1:  647:int adventurer_func(struct gameState *state)
        -:  648:{
        -:  649:	int cardDrawn;
        1:  650:	int currentPlayer = whoseTurn(state);	
call    0 returned 100%
        1:  651:	int drawntreasure = 0;
        -:  652:	int temphand[MAX_HAND];// moved above the if statement
        1:  653:	int z = 0;// this is the counter for the temp hand
        -:  654:    
        8:  655:	while(drawntreasure <= 2) // BUG added!! - Changed to < to <= that what it could end up drawing extra treasure.
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        -:  656:	{
        -:  657:		//if the deck is empty we need to shuffle discard and add to deck
        6:  658:		if (state->deckCount[currentPlayer] <1)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        1:  659:			shuffle(currentPlayer, state);
call    0 returned 100%
        -:  660:		
        6:  661:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  662:		
        -:  663:			//top card of hand is most recently drawn card.
        6:  664:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  665:	
        6:  666:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        3:  667:				drawntreasure++;
        -:  668:			else
        -:  669:			{
        3:  670:				temphand[z] = cardDrawn;
        -:  671:				
        -:  672:				//this should just remove the top card (the most recently drawn one).
        3:  673:				state->handCount[currentPlayer]--; 
        3:  674:				z++;
        -:  675:			}
        -:  676:		}
        -:  677:      
        5:  678:		while(z - 1 >= 0)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  679:		{
        -:  680:			// discard all cards in play that have been drawn
        3:  681:			state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; 
        3:  682:			z = z - 1;
        -:  683:		}
        -:  684:		
        1:  685:		return 0;
        -:  686:}
        -:  687:
        -:  688:// Assignment 2 - refactor card #2: Council Room
function council_room_func called 1 returned 100% blocks executed 100%
        1:  689:int council_room_func(int handPos, struct gameState *state)
        -:  690:{
        -:  691:	int i;
        1:  692:	int currentPlayer = whoseTurn(state);	
call    0 returned 100%
        -:  693:	
        -:  694:	//+4 Cards
        4:  695:	for (i = 1; i < 4; i++) // BUG added!!! = changed i=0 to i=1, which will result in 1 less card drawn.
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        3:  696:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  697:
        -:  698:	//+1 Buy
        1:  699:	state->numBuys++;
        -:  700:	
        -:  701:	//Each other player draws a card
        3:  702:	for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        2:  703:		if ( i != currentPlayer )
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  704:			drawCard(i, state);
call    0 returned 100%
        -:  705:
        -:  706:	//put played card in played card pile
        1:  707:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  708:
        1:  709:	return 0;
        -:  710:}
        -:  711:
        -:  712:
        -:  713:// Assignment 2 - refactor card #3: Remodel
function remodel_func called 0 returned 0% blocks executed 0%
    #####:  714:int remodel_func(int choice1, int choice2, int handPos, struct gameState *state)
        -:  715:{
        -:  716:	int i;
        -:  717:	int j;
    #####:  718:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  719:    
    #####:  720:	j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  721:
    #####:  722:	if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  723:		return -1;
        -:  724:
    #####:  725:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  726:
        -:  727:	//discard card from hand
    #####:  728:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  729:
        -:  730:	//discard trashed card
    #####:  731:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  732:	{
    #####:  733:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  734:	    {
    #####:  735:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  736:			break;
        -:  737:	    }
        -:  738:	}
        -:  739:	
    #####:  740:	return 0;
        -:  741:}
        -:  742:
        -:  743:// Assignment 2 - refactor card #4: Smithy
function smithy_func called 1 returned 100% blocks executed 100%
        1:  744:int smithy_func(int handPos, struct gameState *state)
        -:  745:{
        -:  746:	int i;
        1:  747:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  748:	
        -:  749:	//+3 Cards
        5:  750:	for (i = 0; i <= 3; i++) // BUG added!!! = changed < to <=, which will result in 1 more card drawn.
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        4:  751:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  752:
        -:  753:	//discard card from hand
        1:  754:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  755:	
        1:  756:	return 0;
        -:  757:}
        -:  758:
        -:  759:// Assignment 2 - refactor card #5: Village
function village_func called 0 returned 0% blocks executed 0%
    #####:  760:int village_func(int handPos, struct gameState *state)
        -:  761:{
    #####:  762:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  763:	
        -:  764:	//+1 Card
    #####:  765:	drawCard(currentPlayer, state);
call    0 never executed
        -:  766:			
        -:  767:	//+2 Actions
    #####:  768:	state->numActions = state->numActions + 22; // BUG added!!! = changed 2 to 22, which will result in +22 actions instead of just 2.
        -:  769:			
        -:  770:	//discard played card from hand
    #####:  771:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  772:
    #####:  773:	return 0;
        -:  774:}
        -:  775:
        -:  776:// cardEffect - for assignment 2 - I refactored 5 of these cards (adventurer, 
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  777:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  778:{
        -:  779:  int i;
        -:  780:  int j;
        -:  781:  int k;
        -:  782:  int x;
        -:  783:  int index;
    #####:  784:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  785:  int nextPlayer = currentPlayer + 1;
        -:  786:
    #####:  787:  int tributeRevealedCards[2] = {-1, -1};
        -:  788:  int temphand[MAX_HAND];// moved above the if statement
        -:  789:
    #####:  790:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  791:    nextPlayer = 0;
        -:  792:  }
        -:  793:  
        -:  794:  /* these variables are no longer needed after refactoring
        -:  795:  
        -:  796:    int drawntreasure=0;
        -:  797:	int cardDrawn;
        -:  798:	int z = 0;// this is the counter for the temp hand
        -:  799:	*/
        -:  800:	
        -:  801:  //uses switch to select card and perform actions
    #####:  802:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  803:    {
        -:  804:    case adventurer:
        -:  805:	
    #####:  806:		adventurer_func(state);
call    0 never executed
        -:  807:		
        -:  808:		/* commented out code that is no longer needed due to refactoring
        -:  809:		while(drawntreasure<2)
        -:  810:		{
        -:  811:			//if the deck is empty we need to shuffle discard and add to deck
        -:  812:			if (state->deckCount[currentPlayer] <1)
        -:  813:				shuffle(currentPlayer, state);
        -:  814:		
        -:  815:			drawCard(currentPlayer, state);
        -:  816:		
        -:  817:			//top card of hand is most recently drawn card.
        -:  818:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  819:	
        -:  820:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:  821:				drawntreasure++;
        -:  822:			else
        -:  823:			{
        -:  824:				temphand[z]=cardDrawn;
        -:  825:				
        -:  826:				//this should just remove the top card (the most recently drawn one).
        -:  827:				state->handCount[currentPlayer]--; 
        -:  828:				z++;
        -:  829:			}
        -:  830:		}
        -:  831:      
        -:  832:		while(z-1>=0)
        -:  833:		{
        -:  834:			// discard all cards in play that have been drawn
        -:  835:			state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; 
        -:  836:			z=z-1;
        -:  837:		}
        -:  838:		return 0;
        -:  839:		*/
        -:  840:	
        -:  841:    case council_room:
        -:  842:		
    #####:  843:		council_room_func(handPos, state);
call    0 never executed
        -:  844:		
        -:  845:		/* commented out code that is no longer needed due to refactoring
        -:  846:		
        -:  847:		//+4 Cards
        -:  848:		  for (i = 0; i < 4; i++)
        -:  849:		{
        -:  850:		  drawCard(currentPlayer, state);
        -:  851:		}
        -:  852:				
        -:  853:		  //+1 Buy
        -:  854:		  state->numBuys++;
        -:  855:				
        -:  856:		  //Each other player draws a card
        -:  857:		  for (i = 0; i < state->numPlayers; i++)
        -:  858:		{
        -:  859:		  if ( i != currentPlayer )
        -:  860:			{
        -:  861:			  drawCard(i, state);
        -:  862:			}
        -:  863:		}
        -:  864:				
        -:  865:		  //put played card in played card pile
        -:  866:		  discardCard(handPos, currentPlayer, state, 0);
        -:  867:				
        -:  868:		  return 0;
        -:  869:		*/
        -:  870:		
        -:  871:    case feast:
        -:  872:      //gain card with cost up to 5
        -:  873:      //Backup hand
    #####:  874:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  875:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  876:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  877:      }
        -:  878:      //Backup hand
        -:  879:
        -:  880:      //Update Coins for Buy
    #####:  881:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  882:      x = 1;//Condition to loop on
    #####:  883:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  884:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  885:	  if (DEBUG)
        -:  886:	    printf("None of that card left, sorry!\n");
        -:  887:
        -:  888:	  if (DEBUG){
        -:  889:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  890:	  }
        -:  891:	}
    #####:  892:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  893:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  894:
        -:  895:	  if (DEBUG){
        -:  896:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  897:	  }
        -:  898:	}
        -:  899:	else{
        -:  900:
        -:  901:	  if (DEBUG){
        -:  902:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  903:	  }
        -:  904:
    #####:  905:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  906:	  x = 0;//No more buying cards
        -:  907:
        -:  908:	  if (DEBUG){
        -:  909:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  910:	  }
        -:  911:
        -:  912:	}
        -:  913:      }     
        -:  914:
        -:  915:      //Reset Hand
    #####:  916:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  917:	state->hand[currentPlayer][i] = temphand[i];
    #####:  918:	temphand[i] = -1;
        -:  919:      }
        -:  920:      //Reset Hand
        -:  921:      			
    #####:  922:      return 0;
        -:  923:			
        -:  924:    case gardens:
    #####:  925:      return -1;
        -:  926:			
        -:  927:    case mine:
    #####:  928:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  929:
    #####:  930:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  931:	{
    #####:  932:	  return -1;
        -:  933:	}
        -:  934:		
    #####:  935:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  936:	{
    #####:  937:	  return -1;
        -:  938:	}
        -:  939:
    #####:  940:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  941:	{
    #####:  942:	  return -1;
        -:  943:	}
        -:  944:
    #####:  945:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  946:
        -:  947:      //discard card from hand
    #####:  948:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  949:
        -:  950:      //discard trashed card
    #####:  951:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  952:	{
    #####:  953:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  954:	    {
    #####:  955:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  956:	      break;
        -:  957:	    }
        -:  958:	}
        -:  959:			
    #####:  960:      return 0;
        -:  961:			
        -:  962:    case remodel:
        -:  963:	
    #####:  964:		remodel_func(choice1, choice2, handPos, state);
call    0 never executed
        -:  965:		
        -:  966:		/* commented out code that is no longer needed due to refactoring
        -:  967:			
        -:  968:		  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  969:
        -:  970:		  if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  971:		{
        -:  972:		  return -1;
        -:  973:		}
        -:  974:
        -:  975:		  gainCard(choice2, state, 0, currentPlayer);
        -:  976:
        -:  977:		  //discard card from hand
        -:  978:		  discardCard(handPos, currentPlayer, state, 0);
        -:  979:
        -:  980:		  //discard trashed card
        -:  981:		  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  982:		{
        -:  983:		  if (state->hand[currentPlayer][i] == j)
        -:  984:			{
        -:  985:			  discardCard(i, currentPlayer, state, 0);			
        -:  986:			  break;
        -:  987:			}
        -:  988:		}
        -:  989:
        -:  990:		  return 0;
        -:  991:		*/
        -:  992:		
        -:  993:    case smithy:
        -:  994:	
    #####:  995:		smithy_func(handPos, state);
call    0 never executed
        -:  996:		
        -:  997:		/* commented out code that is no longer needed due to refactoring
        -:  998:			
        -:  999:		  //+3 Cards
        -: 1000:		  for (i = 0; i < 3; i++)
        -: 1001:		{
        -: 1002:		  drawCard(currentPlayer, state);
        -: 1003:		}
        -: 1004:				
        -: 1005:		  //discard card from hand
        -: 1006:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1007:		  return 0;
        -: 1008:		*/
        -: 1009:			
        -: 1010:    case village:
        -: 1011:	
    #####: 1012:		village_func(handPos, state);
call    0 never executed
        -: 1013:		
        -: 1014:		/* commented out code that is no longer needed due to refactoring
        -: 1015:			
        -: 1016:		  //+1 Card
        -: 1017:		  drawCard(currentPlayer, state);
        -: 1018:				
        -: 1019:		  //+2 Actions
        -: 1020:		  state->numActions = state->numActions + 2;
        -: 1021:				
        -: 1022:		  //discard played card from hand
        -: 1023:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1024:		  return 0;
        -: 1025:		*/
        -: 1026:		
        -: 1027:    case baron:
    #####: 1028:      state->numBuys++;//Increase buys by 1!
    #####: 1029:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####: 1030:	int p = 0;//Iterator for hand!
    #####: 1031:	int card_not_discarded = 1;//Flag for discard set!
    #####: 1032:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####: 1033:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####: 1034:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####: 1035:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1036:	    state->discardCount[currentPlayer]++;
    #####: 1037:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####: 1038:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -: 1039:	    }
    #####: 1040:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1041:	    state->handCount[currentPlayer]--;
    #####: 1042:	    card_not_discarded = 0;//Exit the loop
        -: 1043:	  }
    #####: 1044:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -: 1045:	    if(DEBUG) {
        -: 1046:	      printf("No estate cards in your hand, invalid choice\n");
        -: 1047:	      printf("Must gain an estate if there are any\n");
        -: 1048:	    }
    #####: 1049:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1050:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####: 1051:	      state->supplyCount[estate]--;//Decrement estates
    #####: 1052:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1053:		isGameOver(state);
call    0 never executed
        -: 1054:	      }
        -: 1055:	    }
    #####: 1056:	    card_not_discarded = 0;//Exit the loop
        -: 1057:	  }
        -: 1058:			    
        -: 1059:	  else{
    #####: 1060:	    p++;//Next card
        -: 1061:	  }
        -: 1062:	}
        -: 1063:      }
        -: 1064:			    
        -: 1065:      else{
    #####: 1066:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1067:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####: 1068:	  state->supplyCount[estate]--;//Decrement Estates
    #####: 1069:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1070:	    isGameOver(state);
call    0 never executed
        -: 1071:	  }
        -: 1072:	}
        -: 1073:      }
        -: 1074:	    
        -: 1075:      
    #####: 1076:      return 0;
        -: 1077:		
        -: 1078:    case great_hall:
        -: 1079:      //+1 Card
    #####: 1080:      drawCard(currentPlayer, state);
call    0 never executed
        -: 1081:			
        -: 1082:      //+1 Actions
    #####: 1083:      state->numActions++;
        -: 1084:			
        -: 1085:      //discard card from hand
    #####: 1086:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1087:      return 0;
        -: 1088:		
        -: 1089:    case minion:
        -: 1090:      //+1 action
    #####: 1091:      state->numActions++;
        -: 1092:			
        -: 1093:      //discard card from hand
    #####: 1094:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1095:			
    #####: 1096:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -: 1097:	{
    #####: 1098:	  state->coins = state->coins + 2;
        -: 1099:	}
        -: 1100:			
    #####: 1101:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -: 1102:	{
        -: 1103:	  //discard hand
    #####: 1104:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1105:	    {
    #####: 1106:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1107:	    }
        -: 1108:				
        -: 1109:	  //draw 4
    #####: 1110:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1111:	    {
    #####: 1112:	      drawCard(currentPlayer, state);
call    0 never executed
        -: 1113:	    }
        -: 1114:				
        -: 1115:	  //other players discard hand and redraw if hand size > 4
    #####: 1116:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1117:	    {
    #####: 1118:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1119:		{
    #####: 1120:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1121:		    {
        -: 1122:		      //discard hand
    #####: 1123:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1124:			{
    #####: 1125:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1126:			}
        -: 1127:							
        -: 1128:		      //draw 4
    #####: 1129:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1130:			{
    #####: 1131:			  drawCard(i, state);
call    0 never executed
        -: 1132:			}
        -: 1133:		    }
        -: 1134:		}
        -: 1135:	    }
        -: 1136:				
        -: 1137:	}
    #####: 1138:      return 0;
        -: 1139:		
        -: 1140:    case steward:
    #####: 1141:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1142:	{
        -: 1143:	  //+2 cards
    #####: 1144:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1145:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1146:	}
    #####: 1147:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1148:	{
        -: 1149:	  //+2 coins
    #####: 1150:	  state->coins = state->coins + 2;
        -: 1151:	}
        -: 1152:      else
        -: 1153:	{
        -: 1154:	  //trash 2 cards in hand
    #####: 1155:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1156:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1157:	}
        -: 1158:			
        -: 1159:      //discard card from hand
    #####: 1160:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1161:      return 0;
        -: 1162:		
        -: 1163:    case tribute:
    #####: 1164:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1165:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1166:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1167:	  state->deckCount[nextPlayer]--;
        -: 1168:	}
    #####: 1169:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1170:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1171:	  state->discardCount[nextPlayer]--;
        -: 1172:	}
        -: 1173:	else{
        -: 1174:	  //No Card to Reveal
        -: 1175:	  if (DEBUG){
        -: 1176:	    printf("No cards to reveal\n");
        -: 1177:	  }
        -: 1178:	}
        -: 1179:      }
        -: 1180:	    
        -: 1181:      else{
    #####: 1182:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1183:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1184:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1185:	    state->deckCount[nextPlayer]++;
    #####: 1186:	    state->discard[nextPlayer][i] = -1;
    #####: 1187:	    state->discardCount[nextPlayer]--;
        -: 1188:	  }
        -: 1189:			    
    #####: 1190:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1191:	} 
    #####: 1192:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1193:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1194:	state->deckCount[nextPlayer]--;
    #####: 1195:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1196:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1197:	state->deckCount[nextPlayer]--;
        -: 1198:      }    
        -: 1199:		       
    #####: 1200:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1201:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1202:	state->playedCardCount++;
    #####: 1203:	tributeRevealedCards[1] = -1;
        -: 1204:      }
        -: 1205:
    #####: 1206:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1207:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1208:	  state->coins += 2;
        -: 1209:	}
        -: 1210:		    
    #####: 1211:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1212:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1213:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1214:	}
        -: 1215:	else{//Action Card
    #####: 1216:	  state->numActions = state->numActions + 2;
        -: 1217:	}
        -: 1218:      }
        -: 1219:	    
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case ambassador:
    #####: 1223:      j = 0;		//used to check if player has enough cards to discard
        -: 1224:
    #####: 1225:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1226:	{
    #####: 1227:	  return -1;				
        -: 1228:	}
        -: 1229:
    #####: 1230:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1231:	{
    #####: 1232:	  return -1;
        -: 1233:	}
        -: 1234:
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1238:	    {
    #####: 1239:	      j++;
        -: 1240:	    }
        -: 1241:	}
    #####: 1242:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1243:	{
    #####: 1244:	  return -1;				
        -: 1245:	}
        -: 1246:
        -: 1247:      if (DEBUG) 
        -: 1248:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1249:
        -: 1250:      //increase supply count for choosen card by amount being discarded
    #####: 1251:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1252:			
        -: 1253:      //each other player gains a copy of revealed card
    #####: 1254:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:	{
    #####: 1256:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1257:	    {
    #####: 1258:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1259:	    }
        -: 1260:	}
        -: 1261:
        -: 1262:      //discard played card from hand
    #####: 1263:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1264:
        -: 1265:      //trash copies of cards returned to supply
    #####: 1266:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1267:	{
    #####: 1268:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1269:	    {
    #####: 1270:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1271:		{
    #####: 1272:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1273:		  break;
        -: 1274:		}
        -: 1275:	    }
        -: 1276:	}			
        -: 1277:
    #####: 1278:      return 0;
        -: 1279:		
        -: 1280:    case cutpurse:
        -: 1281:
    #####: 1282:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1283:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1284:	{
    #####: 1285:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1286:	    {
    #####: 1287:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1288:		{
    #####: 1289:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1290:		    {
    #####: 1291:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1292:		      break;
        -: 1293:		    }
    #####: 1294:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1295:		    {
    #####: 1296:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1297:			{
        -: 1298:			  if (DEBUG)
        -: 1299:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1300:			}	
    #####: 1301:		      break;
        -: 1302:		    }		
        -: 1303:		}
        -: 1304:					
        -: 1305:	    }
        -: 1306:				
        -: 1307:	}				
        -: 1308:
        -: 1309:      //discard played card from hand
    #####: 1310:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1311:
    #####: 1312:      return 0;
        -: 1313:
        -: 1314:		
        -: 1315:    case embargo: 
        -: 1316:      //+2 Coins
    #####: 1317:      state->coins = state->coins + 2;
        -: 1318:			
        -: 1319:      //see if selected pile is in play
    #####: 1320:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1321:	{
    #####: 1322:	  return -1;
        -: 1323:	}
        -: 1324:			
        -: 1325:      //add embargo token to selected supply pile
    #####: 1326:      state->embargoTokens[choice1]++;
        -: 1327:			
        -: 1328:      //trash card
    #####: 1329:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1330:      return 0;
        -: 1331:		
        -: 1332:    case outpost:
        -: 1333:      //set outpost flag
    #####: 1334:      state->outpostPlayed++;
        -: 1335:			
        -: 1336:      //discard card
    #####: 1337:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1338:      return 0;
        -: 1339:		
        -: 1340:    case salvager:
        -: 1341:      //+1 buy
    #####: 1342:      state->numBuys++;
        -: 1343:			
    #####: 1344:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1345:	{
        -: 1346:	  //gain coins equal to trashed card
    #####: 1347:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1348:	  //trash card
    #####: 1349:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1350:	}
        -: 1351:			
        -: 1352:      //discard card
    #####: 1353:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1354:      return 0;
        -: 1355:		
        -: 1356:    case sea_hag:
    #####: 1357:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1358:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1359:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1360:	  state->discardCount[i]++;
    #####: 1361:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1362:	}
        -: 1363:      }
    #####: 1364:      return 0;
        -: 1365:		
        -: 1366:    case treasure_map:
        -: 1367:      //search hand for another treasure_map
    #####: 1368:      index = -1;
    #####: 1369:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1370:	{
    #####: 1371:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1372:	    {
    #####: 1373:	      index = i;
    #####: 1374:	      break;
        -: 1375:	    }
        -: 1376:	}
    #####: 1377:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1378:	{
        -: 1379:	  //trash both treasure cards
    #####: 1380:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1381:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1382:
        -: 1383:	  //gain 4 Gold cards
    #####: 1384:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1385:	    {
    #####: 1386:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1387:	    }
        -: 1388:				
        -: 1389:	  //return success
    #####: 1390:	  return 1;
        -: 1391:	}
        -: 1392:			
        -: 1393:      //no second treasure_map found in hand
    #####: 1394:      return -1;
        -: 1395:    }
        -: 1396:	
    #####: 1397:  return -1;
        -: 1398:}
        -: 1399:
function discardCard called 2 returned 100% blocks executed 78%
        2: 1400:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1401:{
        -: 1402:	
        -: 1403:  //if card is not trashed, added to Played pile 
        2: 1404:  if (trashFlag < 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1405:    {
        -: 1406:      //add card to played pile
        2: 1407:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
        2: 1408:      state->playedCardCount++;
        -: 1409:    }
        -: 1410:	
        -: 1411:  //set played card to -1
        2: 1412:  state->hand[currentPlayer][handPos] = -1;
        -: 1413:	
        -: 1414:  //remove card from player's hand
        2: 1415:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1416:    {
        -: 1417:      //reduce number of cards in hand
    #####: 1418:      state->handCount[currentPlayer]--;
        -: 1419:    }
        2: 1420:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1421:    {
        -: 1422:      //reduce number of cards in hand
    #####: 1423:      state->handCount[currentPlayer]--;
        -: 1424:    }
        -: 1425:  else 	
        -: 1426:    {
        -: 1427:      //replace discarded card with last card in hand
        2: 1428:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1429:      //set last card to -1
        2: 1430:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1431:      //reduce number of cards in hand
        2: 1432:      state->handCount[currentPlayer]--;
        -: 1433:    }
        -: 1434:	
        2: 1435:  return 0;
        -: 1436:}
        -: 1437:
function gainCard called 3 returned 100% blocks executed 70%
        3: 1438:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1439:{
        -: 1440:  //Note: supplyPos is enum of choosen card
        -: 1441:	
        -: 1442:  //check if supply pile is empty (0) or card is not used in game (-1)
        3: 1443:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1444:    {
    #####: 1445:      return -1;
        -: 1446:    }
        -: 1447:	
        -: 1448:  //added card for [whoseTurn] current player:
        -: 1449:  // toFlag = 0 : add to discard
        -: 1450:  // toFlag = 1 : add to deck
        -: 1451:  // toFlag = 2 : add to hand
        -: 1452:
        3: 1453:  if (toFlag == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1454:    {
    #####: 1455:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1456:      state->deckCount[player]++;
        -: 1457:    }
        3: 1458:  else if (toFlag == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1459:    {
        3: 1460:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
        3: 1461:      state->handCount[player]++;
        -: 1462:    }
        -: 1463:  else
        -: 1464:    {
    #####: 1465:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1466:      state->discardCount[player]++;
        -: 1467:    }
        -: 1468:	
        -: 1469:  //decrease number in supply pile
        3: 1470:  state->supplyCount[supplyPos]--;
        -: 1471:	 
        3: 1472:  return 0;
        -: 1473:}
        -: 1474:
function updateCoins called 588 returned 100% blocks executed 100%
      588: 1475:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1476:{
        -: 1477:  int i;
        -: 1478:	
        -: 1479:  //reset coin count
      588: 1480:  state->coins = 0;
        -: 1481:
        -: 1482:  //add coins for each Treasure card in player's hand
     2868: 1483:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 79%
branch  1 taken 21% (fallthrough)
        -: 1484:    {
     2280: 1485:      if (state->hand[player][i] == copper)
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
        -: 1486:	{
     1286: 1487:	  state->coins += 1;
        -: 1488:	}
      994: 1489:      else if (state->hand[player][i] == silver)
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
        -: 1490:	{
      418: 1491:	  state->coins += 2;
        -: 1492:	}
      576: 1493:      else if (state->hand[player][i] == gold)
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
        -: 1494:	{
      374: 1495:	  state->coins += 3;
        -: 1496:	}	
        -: 1497:    }	
        -: 1498:
        -: 1499:  //add bonus
      588: 1500:  state->coins += bonus;
        -: 1501:
      588: 1502:  return 0;
        -: 1503:}
        -: 1504:
        -: 1505:
        -: 1506://end of dominion.c
        -: 1507:
cardtest4.c:

Testing refactored Village card function
-----------------------------------------------

Checking hand count is correct after using refactored Village card.
Previous hand count: 6 cards, After Village: 6 cards
Expected hand count be same after using Village. (0 = +1 drawn from Village and -1 from discarding Village.
Great! Ended with the correct number of cards in hand after Village.

Checking if refactored Village card drew enough cards to hand.
Previous deck count: 5 cards, After Village: 4 cards
Village drew: 1 card. Expected to draw 1 card
Great! Village drew correct number of cards from deck.

Checking if refactored Village card gave player +2 actions.
Previous actions count: 1, After Village: 23
Expected to get +2 actions.
Bug!!! Village didn't add +2 actions for player.

Checking if refactored Village card altered other player's hand.
Great! Village didn't altered other player's piles.

Checking if refactored Village card altered the Victory and Kingdom piles.
Great! Village didn't alter the Victory and Kingdom piles.
---------------------------------------------------
Final Testing results of refactored Village card
---------------------------------------------------
Refactored Village card failed for 1 condition(s), check above for which ones.

File 'cardtest4.c'
Lines executed:75.41% of 61
Branches executed:100.00% of 20
Taken at least once:55.00% of 20
Calls executed:76.47% of 34
Creating 'cardtest4.c.gcov'

        -:    0:Source:cardtest4.c
        -:    0:Graph:cardtest4.gcno
        -:    0:Data:cardtest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:
        -:    2:/* -----------------------------------------------------------------------
        -:    3: * CS362-004 Summer 2017 Assignment 3
        -:    4: * cardtest4.c
        -:    5: * 
        -:    6: * Patrick Kwong
        -:    7: * kwongp@oregonstate.edu
        -:    8: *
        -:    9: * Unit test for my refactored Village card function: council_room_func
        -:   10: * player that plays Village draws 1 card
        -:   11: * player gets two extra actions
        -:   12: * Used provided cardtest4.c and testUpdateCoins.c examples
        -:   13: * -----------------------------------------------------------------------
        -:   14: * Include the following lines in the makefile:
        -:   15: *
        -:   16: * cardtest4: cardtest4.c dominion.o rngs.o
        -:   17: *      gcc -o cardtest4 -g cardtest4.c dominion.o rngs.o $(CFLAGS)
        -:   18: */
        -:   19:
        -:   20:#include "dominion.h"
        -:   21:#include "dominion_helpers.h"
        -:   22:#include <string.h>
        -:   23:#include <stdio.h>
        -:   24:#include <assert.h>
        -:   25:#include "rngs.h"
        -:   26:#include <stdlib.h>
        -:   27:#include <time.h>
        -:   28:#include <math.h>
        -:   29:
function main called 1 returned 100% blocks executed 73%
        1:   30:int main() {
        -:   31:    int i;
        -:   32:    int seed;
        1:   33:    int numPlayer = 2;
        1:   34:    int bugCount = 0;
        1:   35:    int flag = 0;
        1:   36:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   37:               , remodel, smithy, village, baron, great_hall};
        -:   38:    struct gameState G, prevG;
        1:   39:    seed = (rand() % 100);
call    0 returned 100%
        -:   40:
        1:   41:    printf("\nTesting refactored Village card function\n");
call    0 returned 100%
        1:   42:    printf("-----------------------------------------------\n");
call    0 returned 100%
        -:   43:    
        1:   44:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   45:    initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        -:   46:
        1:   47:    gainCard(village, &G, 2, 0); // add Village card to player 1's hand
call    0 returned 100%
        1:   48:    memcpy(&prevG, &G, sizeof(struct gameState)); //create clone of game state to run tests on
        -:   49:
        1:   50:    village_func(G.handCount[0], &G);
call    0 returned 100%
        -:   51:
        -:   52:    // check if hand count correct after Village
        1:   53:    printf("\nChecking hand count is correct after using refactored Village card.\n");
call    0 returned 100%
        1:   54:    printf("Previous hand count: %d cards, After Village: %d cards\n", prevG.handCount[0], G.handCount[0]);
call    0 returned 100%
        1:   55:    printf("Expected hand count be same after using Village. (0 = +1 drawn from Village and -1 from discarding Village.\n");
call    0 returned 100%
        1:   56:    if(prevG.handCount[0] != G.handCount[0]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   57:        printf("Bug!!! Ended with the incorrect number of cards in hand after Village.\n");
call    0 never executed
    #####:   58:        bugCount++;
        -:   59:    }
        -:   60:    else
        1:   61:        printf("Great! Ended with the correct number of cards in hand after Village.\n");
call    0 returned 100%
        -:   62:
        -:   63:    // check if Village drew the correct cards from deck
        1:   64:    printf("\nChecking if refactored Village card drew enough cards to hand.\n");
call    0 returned 100%
        1:   65:    printf("Previous deck count: %d cards, After Village: %d cards\n", prevG.deckCount[0], G.deckCount[0]);
call    0 returned 100%
        1:   66:    printf("Village drew: %d card. Expected to draw 1 card\n", prevG.deckCount[0] - G.deckCount[0]);
call    0 returned 100%
        1:   67:    if((prevG.deckCount[0] - G.deckCount[0]) != 1){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   68:        printf("Bug!!! Village didn't draw correct nunmber of cards from the deck.\n");
call    0 never executed
    #####:   69:        bugCount++;
        -:   70:    }
        -:   71:    else
        1:   72:        printf("Great! Village drew correct number of cards from deck.\n");
call    0 returned 100%
        -:   73:
        -:   74:    // check if Village gave player +2 actions
        1:   75:    printf("\nChecking if refactored Village card gave player +2 actions.\n");
call    0 returned 100%
        1:   76:    printf("Previous actions count: %d, After Village: %d\n", prevG.numActions, G.numActions);
call    0 returned 100%
        1:   77:    printf("Expected to get +2 actions.\n");
call    0 returned 100%
        1:   78:    if((G.numActions - prevG.numActions) != 2){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   79:        printf("Bug!!! Village didn't add +2 actions for player.\n");
call    0 returned 100%
        1:   80:        bugCount++;
        -:   81:    }
        -:   82:    else
    #####:   83:        printf("Great! Village did add +2 actions for player.\n");
call    0 never executed
        -:   84:
        -:   85:    // check if Village altered other player's piles 
        1:   86:    printf("\nChecking if refactored Village card altered other player's hand.\n");
call    0 returned 100%
        1:   87:    if(prevG.handCount[1] != G.handCount[1]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   88:        printf("Bug!!! Village altered other player's hand pile.\n");
call    0 never executed
    #####:   89:        bugCount++;
        -:   90:    }
        1:   91:    else if(prevG.deckCount[1] != G.deckCount[1]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   92:        printf("Bug!!! Village altered other player's deck pile.\n");
call    0 never executed
    #####:   93:        bugCount++;
        -:   94:    }
        1:   95:    else if(prevG.discardCount[1] != G.discardCount[1]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   96:        printf("Bug!!! Village altered other player's discard pile.\n");
call    0 never executed
    #####:   97:        bugCount++;
        -:   98:    }
        -:   99:    else
        1:  100:        printf("Great! Village didn't altered other player's piles.\n");
call    0 returned 100%
        -:  101:    
        -:  102:    // check if Village altered the victory and kingdom piles
        1:  103:    printf("\nChecking if refactored Village card altered the Victory and Kingdom piles.\n");
call    0 returned 100%
        1:  104:    int arraySize = sizeof(G.supplyCount) / sizeof(int);
       28:  105:    for(i = 0; i < arraySize; i++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       27:  106:        if(G.supplyCount[i] != prevG.supplyCount[i]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  107:            flag = 1;
        -:  108:        }
        -:  109:    }
        1:  110:    if(flag == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  111:        printf("Great! Village didn't alter the Victory and Kingdom piles.\n");
call    0 returned 100%
        -:  112:    else
        -:  113:    {
    #####:  114:        printf("Bug!!! Kingdom/Victory supplied have been altered!\n");
call    0 never executed
    #####:  115:        bugCount++;
        -:  116:    }
        -:  117:
        -:  118:    // output the test results overall
        1:  119:    printf("---------------------------------------------------\n");
call    0 returned 100%
        1:  120:    printf("Final Testing results of refactored Village card\n");
call    0 returned 100%
        1:  121:    printf("---------------------------------------------------\n");
call    0 returned 100%
        -:  122:
        1:  123:    if(bugCount == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  124:        printf("All tests passed for the refactored Village card!\n\n");
call    0 never executed
        -:  125:    else
        1:  126:        printf("Refactored Village card failed for %d condition(s), check above for which ones.\n\n", bugCount);
call    0 returned 100%
        -:  127:
        1:  128:    return 0;
        -:  129:}
File 'dominion.c'
Lines executed:37.66% of 563
Branches executed:33.57% of 417
Taken at least once:30.22% of 417
Calls executed:22.00% of 100
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:8
        -:    0:Programs:8
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 5835 returned 100% blocks executed 83%
     5835:    8:int compare(const void* a, const void* b) {
     5835:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:    return 1;
     5835:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
     1556:   12:    return -1;
     4279:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 195 returned 100% blocks executed 97%
      195:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      195:   44:  SelectStream(1);
call    0 returned 100%
      195:   45:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:  
        -:   47:  //check number of players
      195:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:    {
        2:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      193:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     2123:   57:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:    {
    21230:   59:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:        {
    19300:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      193:   73:  if (numPlayers == 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   74:    {
      191:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
        2:   77:  else if (numPlayers == 3)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:   78:    {
        1:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
        1:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      193:   87:  if (numPlayers == 2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   88:    {
      191:   89:      state->supplyCount[estate] = 8;
      191:   90:      state->supplyCount[duchy] = 8;
      191:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
        2:   95:      state->supplyCount[estate] = 12;
        2:   96:      state->supplyCount[duchy] = 12;
        2:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      193:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      193:  102:  state->supplyCount[silver] = 40;
      193:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
     4053:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:    {
    31845:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:	{
    29915:  110:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     1930:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
        -:  114:		{
      772:  115:		  if (numPlayers == 2){ 
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      382:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
        4:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     1544:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     1930:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    27985:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
      582:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:    {
      389:  140:      state->deckCount[i] = 0;
     1556:  141:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:	{
     1167:  143:	  state->deck[i][j] = estate;
     1167:  144:	  state->deckCount[i]++;
        -:  145:	}
     3112:  146:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:	{
     2723:  148:	  state->deck[i][j] = copper;
     2723:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
      582:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:    {
      389:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
      582:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
      389:  166:      state->handCount[i] = 0;
      389:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
     5404:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:    {
     5211:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      193:  182:  state->outpostPlayed = 0;
      193:  183:  state->phase = 0;
      193:  184:  state->numActions = 1;
      193:  185:  state->numBuys = 1;
      193:  186:  state->playedCardCount = 0;
      193:  187:  state->whoseTurn = 0;
      193:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     1158:  192:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      965:  193:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:  }
        -:  195:
      193:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
      193:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 391 returned 100% blocks executed 100%
      391:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
      391:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
      391:  209:  if (state->deckCount[player] < 1)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2:  210:    return -1;
      389:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     4668:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     3890:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     3890:  216:    newDeck[newDeckPos] = state->deck[player][card];
     3890:  217:    newDeckPos++;
    14540:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 73%
branch  1 taken 27% (fallthrough)
    10650:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
     3890:  221:    state->deckCount[player]--;
        -:  222:  }
     4279:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     3890:  224:    state->deck[player][i] = newDeck[i];
     3890:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
      389:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 64 returned 100% blocks executed 100%
       64:  320:int supplyCount(int card, struct gameState *state) {
       64:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 4 returned 100% blocks executed 100%
        4:  346:int whoseTurn(struct gameState *state) {
        4:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 11 returned 100% blocks executed 100%
       11:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
       11:  395:  if (state->supplyCount[province] == 0)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
        -:  396:    {
        3:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
        8:  401:  j = 0;
      208:  402:  for (i = 0; i < 25; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  403:    {
      200:  404:      if (state->supplyCount[i] == 0)
branch  0 taken 9% (fallthrough)
branch  1 taken 92%
        -:  405:	{
       17:  406:	  j++;
        -:  407:	}
        -:  408:    }
        8:  409:  if ( j >= 3)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  410:    {
        4:  411:      return 1;
        -:  412:    }
        -:  413:
        4:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 980 returned 100% blocks executed 85%
      980:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
      980:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
        1:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
        1:  538:    state->deckCount[player] = state->discardCount[player];
        1:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
        1:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
        1:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
        1:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
        1:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
        1:  559:    if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
      979:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
      979:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
      979:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      979:  576:    state->deckCount[player]--;
      979:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
      979:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 27 returned 100% blocks executed 97%
       27:  583:int getCost(int cardNumber)
        -:  584:{
       27:  585:  switch( cardNumber ) 
branch  0 taken 4%
branch  1 taken 4%
branch  2 taken 4%
branch  3 taken 4%
branch  4 taken 4%
branch  5 taken 4%
branch  6 taken 4%
branch  7 taken 4%
branch  8 taken 4%
branch  9 taken 4%
branch 10 taken 4%
branch 11 taken 4%
branch 12 taken 4%
branch 13 taken 4%
branch 14 taken 4%
branch 15 taken 4%
branch 16 taken 4%
branch 17 taken 4%
branch 18 taken 4%
branch 19 taken 4%
branch 20 taken 4%
branch 21 taken 4%
branch 22 taken 4%
branch 23 taken 4%
branch 24 taken 4%
branch 25 taken 4%
branch 26 taken 4%
branch 27 taken 0%
        -:  586:    {
        -:  587:    case curse:
        1:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        1:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        1:  608:      return 4;
        -:  609:    case mine:
        1:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        1:  614:      return 4;
        -:  615:    case village:
        1:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        1:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        1:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        1:  630:      return 4;
        -:  631:    case embargo: 
        1:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        1:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
        -:  646:// Assignment 2 - refactor card #1: Adventurer
function adventurer_func called 1 returned 100% blocks executed 100%
        1:  647:int adventurer_func(struct gameState *state)
        -:  648:{
        -:  649:	int cardDrawn;
        1:  650:	int currentPlayer = whoseTurn(state);	
call    0 returned 100%
        1:  651:	int drawntreasure = 0;
        -:  652:	int temphand[MAX_HAND];// moved above the if statement
        1:  653:	int z = 0;// this is the counter for the temp hand
        -:  654:    
        8:  655:	while(drawntreasure <= 2) // BUG added!! - Changed to < to <= that what it could end up drawing extra treasure.
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        -:  656:	{
        -:  657:		//if the deck is empty we need to shuffle discard and add to deck
        6:  658:		if (state->deckCount[currentPlayer] <1)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        1:  659:			shuffle(currentPlayer, state);
call    0 returned 100%
        -:  660:		
        6:  661:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  662:		
        -:  663:			//top card of hand is most recently drawn card.
        6:  664:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  665:	
        6:  666:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        3:  667:				drawntreasure++;
        -:  668:			else
        -:  669:			{
        3:  670:				temphand[z] = cardDrawn;
        -:  671:				
        -:  672:				//this should just remove the top card (the most recently drawn one).
        3:  673:				state->handCount[currentPlayer]--; 
        3:  674:				z++;
        -:  675:			}
        -:  676:		}
        -:  677:      
        5:  678:		while(z - 1 >= 0)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  679:		{
        -:  680:			// discard all cards in play that have been drawn
        3:  681:			state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; 
        3:  682:			z = z - 1;
        -:  683:		}
        -:  684:		
        1:  685:		return 0;
        -:  686:}
        -:  687:
        -:  688:// Assignment 2 - refactor card #2: Council Room
function council_room_func called 1 returned 100% blocks executed 100%
        1:  689:int council_room_func(int handPos, struct gameState *state)
        -:  690:{
        -:  691:	int i;
        1:  692:	int currentPlayer = whoseTurn(state);	
call    0 returned 100%
        -:  693:	
        -:  694:	//+4 Cards
        4:  695:	for (i = 1; i < 4; i++) // BUG added!!! = changed i=0 to i=1, which will result in 1 less card drawn.
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        3:  696:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  697:
        -:  698:	//+1 Buy
        1:  699:	state->numBuys++;
        -:  700:	
        -:  701:	//Each other player draws a card
        3:  702:	for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        2:  703:		if ( i != currentPlayer )
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  704:			drawCard(i, state);
call    0 returned 100%
        -:  705:
        -:  706:	//put played card in played card pile
        1:  707:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  708:
        1:  709:	return 0;
        -:  710:}
        -:  711:
        -:  712:
        -:  713:// Assignment 2 - refactor card #3: Remodel
function remodel_func called 0 returned 0% blocks executed 0%
    #####:  714:int remodel_func(int choice1, int choice2, int handPos, struct gameState *state)
        -:  715:{
        -:  716:	int i;
        -:  717:	int j;
    #####:  718:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  719:    
    #####:  720:	j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  721:
    #####:  722:	if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  723:		return -1;
        -:  724:
    #####:  725:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  726:
        -:  727:	//discard card from hand
    #####:  728:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  729:
        -:  730:	//discard trashed card
    #####:  731:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  732:	{
    #####:  733:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  734:	    {
    #####:  735:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  736:			break;
        -:  737:	    }
        -:  738:	}
        -:  739:	
    #####:  740:	return 0;
        -:  741:}
        -:  742:
        -:  743:// Assignment 2 - refactor card #4: Smithy
function smithy_func called 1 returned 100% blocks executed 100%
        1:  744:int smithy_func(int handPos, struct gameState *state)
        -:  745:{
        -:  746:	int i;
        1:  747:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  748:	
        -:  749:	//+3 Cards
        5:  750:	for (i = 0; i <= 3; i++) // BUG added!!! = changed < to <=, which will result in 1 more card drawn.
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        4:  751:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  752:
        -:  753:	//discard card from hand
        1:  754:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  755:	
        1:  756:	return 0;
        -:  757:}
        -:  758:
        -:  759:// Assignment 2 - refactor card #5: Village
function village_func called 1 returned 100% blocks executed 100%
        1:  760:int village_func(int handPos, struct gameState *state)
        -:  761:{
        1:  762:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  763:	
        -:  764:	//+1 Card
        1:  765:	drawCard(currentPlayer, state);
call    0 returned 100%
        -:  766:			
        -:  767:	//+2 Actions
        1:  768:	state->numActions = state->numActions + 22; // BUG added!!! = changed 2 to 22, which will result in +22 actions instead of just 2.
        -:  769:			
        -:  770:	//discard played card from hand
        1:  771:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  772:
        1:  773:	return 0;
        -:  774:}
        -:  775:
        -:  776:// cardEffect - for assignment 2 - I refactored 5 of these cards (adventurer, 
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  777:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  778:{
        -:  779:  int i;
        -:  780:  int j;
        -:  781:  int k;
        -:  782:  int x;
        -:  783:  int index;
    #####:  784:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  785:  int nextPlayer = currentPlayer + 1;
        -:  786:
    #####:  787:  int tributeRevealedCards[2] = {-1, -1};
        -:  788:  int temphand[MAX_HAND];// moved above the if statement
        -:  789:
    #####:  790:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  791:    nextPlayer = 0;
        -:  792:  }
        -:  793:  
        -:  794:  /* these variables are no longer needed after refactoring
        -:  795:  
        -:  796:    int drawntreasure=0;
        -:  797:	int cardDrawn;
        -:  798:	int z = 0;// this is the counter for the temp hand
        -:  799:	*/
        -:  800:	
        -:  801:  //uses switch to select card and perform actions
    #####:  802:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  803:    {
        -:  804:    case adventurer:
        -:  805:	
    #####:  806:		adventurer_func(state);
call    0 never executed
        -:  807:		
        -:  808:		/* commented out code that is no longer needed due to refactoring
        -:  809:		while(drawntreasure<2)
        -:  810:		{
        -:  811:			//if the deck is empty we need to shuffle discard and add to deck
        -:  812:			if (state->deckCount[currentPlayer] <1)
        -:  813:				shuffle(currentPlayer, state);
        -:  814:		
        -:  815:			drawCard(currentPlayer, state);
        -:  816:		
        -:  817:			//top card of hand is most recently drawn card.
        -:  818:			cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  819:	
        -:  820:			if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:  821:				drawntreasure++;
        -:  822:			else
        -:  823:			{
        -:  824:				temphand[z]=cardDrawn;
        -:  825:				
        -:  826:				//this should just remove the top card (the most recently drawn one).
        -:  827:				state->handCount[currentPlayer]--; 
        -:  828:				z++;
        -:  829:			}
        -:  830:		}
        -:  831:      
        -:  832:		while(z-1>=0)
        -:  833:		{
        -:  834:			// discard all cards in play that have been drawn
        -:  835:			state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; 
        -:  836:			z=z-1;
        -:  837:		}
        -:  838:		return 0;
        -:  839:		*/
        -:  840:	
        -:  841:    case council_room:
        -:  842:		
    #####:  843:		council_room_func(handPos, state);
call    0 never executed
        -:  844:		
        -:  845:		/* commented out code that is no longer needed due to refactoring
        -:  846:		
        -:  847:		//+4 Cards
        -:  848:		  for (i = 0; i < 4; i++)
        -:  849:		{
        -:  850:		  drawCard(currentPlayer, state);
        -:  851:		}
        -:  852:				
        -:  853:		  //+1 Buy
        -:  854:		  state->numBuys++;
        -:  855:				
        -:  856:		  //Each other player draws a card
        -:  857:		  for (i = 0; i < state->numPlayers; i++)
        -:  858:		{
        -:  859:		  if ( i != currentPlayer )
        -:  860:			{
        -:  861:			  drawCard(i, state);
        -:  862:			}
        -:  863:		}
        -:  864:				
        -:  865:		  //put played card in played card pile
        -:  866:		  discardCard(handPos, currentPlayer, state, 0);
        -:  867:				
        -:  868:		  return 0;
        -:  869:		*/
        -:  870:		
        -:  871:    case feast:
        -:  872:      //gain card with cost up to 5
        -:  873:      //Backup hand
    #####:  874:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  875:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  876:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  877:      }
        -:  878:      //Backup hand
        -:  879:
        -:  880:      //Update Coins for Buy
    #####:  881:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  882:      x = 1;//Condition to loop on
    #####:  883:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  884:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  885:	  if (DEBUG)
        -:  886:	    printf("None of that card left, sorry!\n");
        -:  887:
        -:  888:	  if (DEBUG){
        -:  889:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  890:	  }
        -:  891:	}
    #####:  892:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  893:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  894:
        -:  895:	  if (DEBUG){
        -:  896:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  897:	  }
        -:  898:	}
        -:  899:	else{
        -:  900:
        -:  901:	  if (DEBUG){
        -:  902:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  903:	  }
        -:  904:
    #####:  905:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  906:	  x = 0;//No more buying cards
        -:  907:
        -:  908:	  if (DEBUG){
        -:  909:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  910:	  }
        -:  911:
        -:  912:	}
        -:  913:      }     
        -:  914:
        -:  915:      //Reset Hand
    #####:  916:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  917:	state->hand[currentPlayer][i] = temphand[i];
    #####:  918:	temphand[i] = -1;
        -:  919:      }
        -:  920:      //Reset Hand
        -:  921:      			
    #####:  922:      return 0;
        -:  923:			
        -:  924:    case gardens:
    #####:  925:      return -1;
        -:  926:			
        -:  927:    case mine:
    #####:  928:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  929:
    #####:  930:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  931:	{
    #####:  932:	  return -1;
        -:  933:	}
        -:  934:		
    #####:  935:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  936:	{
    #####:  937:	  return -1;
        -:  938:	}
        -:  939:
    #####:  940:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  941:	{
    #####:  942:	  return -1;
        -:  943:	}
        -:  944:
    #####:  945:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  946:
        -:  947:      //discard card from hand
    #####:  948:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  949:
        -:  950:      //discard trashed card
    #####:  951:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  952:	{
    #####:  953:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  954:	    {
    #####:  955:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  956:	      break;
        -:  957:	    }
        -:  958:	}
        -:  959:			
    #####:  960:      return 0;
        -:  961:			
        -:  962:    case remodel:
        -:  963:	
    #####:  964:		remodel_func(choice1, choice2, handPos, state);
call    0 never executed
        -:  965:		
        -:  966:		/* commented out code that is no longer needed due to refactoring
        -:  967:			
        -:  968:		  j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  969:
        -:  970:		  if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  971:		{
        -:  972:		  return -1;
        -:  973:		}
        -:  974:
        -:  975:		  gainCard(choice2, state, 0, currentPlayer);
        -:  976:
        -:  977:		  //discard card from hand
        -:  978:		  discardCard(handPos, currentPlayer, state, 0);
        -:  979:
        -:  980:		  //discard trashed card
        -:  981:		  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  982:		{
        -:  983:		  if (state->hand[currentPlayer][i] == j)
        -:  984:			{
        -:  985:			  discardCard(i, currentPlayer, state, 0);			
        -:  986:			  break;
        -:  987:			}
        -:  988:		}
        -:  989:
        -:  990:		  return 0;
        -:  991:		*/
        -:  992:		
        -:  993:    case smithy:
        -:  994:	
    #####:  995:		smithy_func(handPos, state);
call    0 never executed
        -:  996:		
        -:  997:		/* commented out code that is no longer needed due to refactoring
        -:  998:			
        -:  999:		  //+3 Cards
        -: 1000:		  for (i = 0; i < 3; i++)
        -: 1001:		{
        -: 1002:		  drawCard(currentPlayer, state);
        -: 1003:		}
        -: 1004:				
        -: 1005:		  //discard card from hand
        -: 1006:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1007:		  return 0;
        -: 1008:		*/
        -: 1009:			
        -: 1010:    case village:
        -: 1011:	
    #####: 1012:		village_func(handPos, state);
call    0 never executed
        -: 1013:		
        -: 1014:		/* commented out code that is no longer needed due to refactoring
        -: 1015:			
        -: 1016:		  //+1 Card
        -: 1017:		  drawCard(currentPlayer, state);
        -: 1018:				
        -: 1019:		  //+2 Actions
        -: 1020:		  state->numActions = state->numActions + 2;
        -: 1021:				
        -: 1022:		  //discard played card from hand
        -: 1023:		  discardCard(handPos, currentPlayer, state, 0);
        -: 1024:		  return 0;
        -: 1025:		*/
        -: 1026:		
        -: 1027:    case baron:
    #####: 1028:      state->numBuys++;//Increase buys by 1!
    #####: 1029:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####: 1030:	int p = 0;//Iterator for hand!
    #####: 1031:	int card_not_discarded = 1;//Flag for discard set!
    #####: 1032:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####: 1033:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####: 1034:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####: 1035:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1036:	    state->discardCount[currentPlayer]++;
    #####: 1037:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####: 1038:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -: 1039:	    }
    #####: 1040:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1041:	    state->handCount[currentPlayer]--;
    #####: 1042:	    card_not_discarded = 0;//Exit the loop
        -: 1043:	  }
    #####: 1044:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -: 1045:	    if(DEBUG) {
        -: 1046:	      printf("No estate cards in your hand, invalid choice\n");
        -: 1047:	      printf("Must gain an estate if there are any\n");
        -: 1048:	    }
    #####: 1049:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1050:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####: 1051:	      state->supplyCount[estate]--;//Decrement estates
    #####: 1052:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1053:		isGameOver(state);
call    0 never executed
        -: 1054:	      }
        -: 1055:	    }
    #####: 1056:	    card_not_discarded = 0;//Exit the loop
        -: 1057:	  }
        -: 1058:			    
        -: 1059:	  else{
    #####: 1060:	    p++;//Next card
        -: 1061:	  }
        -: 1062:	}
        -: 1063:      }
        -: 1064:			    
        -: 1065:      else{
    #####: 1066:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1067:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####: 1068:	  state->supplyCount[estate]--;//Decrement Estates
    #####: 1069:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1070:	    isGameOver(state);
call    0 never executed
        -: 1071:	  }
        -: 1072:	}
        -: 1073:      }
        -: 1074:	    
        -: 1075:      
    #####: 1076:      return 0;
        -: 1077:		
        -: 1078:    case great_hall:
        -: 1079:      //+1 Card
    #####: 1080:      drawCard(currentPlayer, state);
call    0 never executed
        -: 1081:			
        -: 1082:      //+1 Actions
    #####: 1083:      state->numActions++;
        -: 1084:			
        -: 1085:      //discard card from hand
    #####: 1086:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1087:      return 0;
        -: 1088:		
        -: 1089:    case minion:
        -: 1090:      //+1 action
    #####: 1091:      state->numActions++;
        -: 1092:			
        -: 1093:      //discard card from hand
    #####: 1094:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1095:			
    #####: 1096:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -: 1097:	{
    #####: 1098:	  state->coins = state->coins + 2;
        -: 1099:	}
        -: 1100:			
    #####: 1101:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -: 1102:	{
        -: 1103:	  //discard hand
    #####: 1104:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1105:	    {
    #####: 1106:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1107:	    }
        -: 1108:				
        -: 1109:	  //draw 4
    #####: 1110:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1111:	    {
    #####: 1112:	      drawCard(currentPlayer, state);
call    0 never executed
        -: 1113:	    }
        -: 1114:				
        -: 1115:	  //other players discard hand and redraw if hand size > 4
    #####: 1116:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1117:	    {
    #####: 1118:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1119:		{
    #####: 1120:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1121:		    {
        -: 1122:		      //discard hand
    #####: 1123:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1124:			{
    #####: 1125:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1126:			}
        -: 1127:							
        -: 1128:		      //draw 4
    #####: 1129:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1130:			{
    #####: 1131:			  drawCard(i, state);
call    0 never executed
        -: 1132:			}
        -: 1133:		    }
        -: 1134:		}
        -: 1135:	    }
        -: 1136:				
        -: 1137:	}
    #####: 1138:      return 0;
        -: 1139:		
        -: 1140:    case steward:
    #####: 1141:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1142:	{
        -: 1143:	  //+2 cards
    #####: 1144:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1145:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1146:	}
    #####: 1147:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1148:	{
        -: 1149:	  //+2 coins
    #####: 1150:	  state->coins = state->coins + 2;
        -: 1151:	}
        -: 1152:      else
        -: 1153:	{
        -: 1154:	  //trash 2 cards in hand
    #####: 1155:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1156:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1157:	}
        -: 1158:			
        -: 1159:      //discard card from hand
    #####: 1160:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1161:      return 0;
        -: 1162:		
        -: 1163:    case tribute:
    #####: 1164:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1165:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1166:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1167:	  state->deckCount[nextPlayer]--;
        -: 1168:	}
    #####: 1169:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1170:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1171:	  state->discardCount[nextPlayer]--;
        -: 1172:	}
        -: 1173:	else{
        -: 1174:	  //No Card to Reveal
        -: 1175:	  if (DEBUG){
        -: 1176:	    printf("No cards to reveal\n");
        -: 1177:	  }
        -: 1178:	}
        -: 1179:      }
        -: 1180:	    
        -: 1181:      else{
    #####: 1182:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1183:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1184:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1185:	    state->deckCount[nextPlayer]++;
    #####: 1186:	    state->discard[nextPlayer][i] = -1;
    #####: 1187:	    state->discardCount[nextPlayer]--;
        -: 1188:	  }
        -: 1189:			    
    #####: 1190:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1191:	} 
    #####: 1192:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1193:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1194:	state->deckCount[nextPlayer]--;
    #####: 1195:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1196:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1197:	state->deckCount[nextPlayer]--;
        -: 1198:      }    
        -: 1199:		       
    #####: 1200:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1201:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1202:	state->playedCardCount++;
    #####: 1203:	tributeRevealedCards[1] = -1;
        -: 1204:      }
        -: 1205:
    #####: 1206:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1207:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1208:	  state->coins += 2;
        -: 1209:	}
        -: 1210:		    
    #####: 1211:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1212:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1213:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1214:	}
        -: 1215:	else{//Action Card
    #####: 1216:	  state->numActions = state->numActions + 2;
        -: 1217:	}
        -: 1218:      }
        -: 1219:	    
    #####: 1220:      return 0;
        -: 1221:		
        -: 1222:    case ambassador:
    #####: 1223:      j = 0;		//used to check if player has enough cards to discard
        -: 1224:
    #####: 1225:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1226:	{
    #####: 1227:	  return -1;				
        -: 1228:	}
        -: 1229:
    #####: 1230:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1231:	{
    #####: 1232:	  return -1;
        -: 1233:	}
        -: 1234:
    #####: 1235:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
    #####: 1237:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1238:	    {
    #####: 1239:	      j++;
        -: 1240:	    }
        -: 1241:	}
    #####: 1242:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1243:	{
    #####: 1244:	  return -1;				
        -: 1245:	}
        -: 1246:
        -: 1247:      if (DEBUG) 
        -: 1248:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1249:
        -: 1250:      //increase supply count for choosen card by amount being discarded
    #####: 1251:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1252:			
        -: 1253:      //each other player gains a copy of revealed card
    #####: 1254:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:	{
    #####: 1256:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1257:	    {
    #####: 1258:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1259:	    }
        -: 1260:	}
        -: 1261:
        -: 1262:      //discard played card from hand
    #####: 1263:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1264:
        -: 1265:      //trash copies of cards returned to supply
    #####: 1266:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1267:	{
    #####: 1268:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1269:	    {
    #####: 1270:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1271:		{
    #####: 1272:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1273:		  break;
        -: 1274:		}
        -: 1275:	    }
        -: 1276:	}			
        -: 1277:
    #####: 1278:      return 0;
        -: 1279:		
        -: 1280:    case cutpurse:
        -: 1281:
    #####: 1282:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1283:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1284:	{
    #####: 1285:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1286:	    {
    #####: 1287:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1288:		{
    #####: 1289:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1290:		    {
    #####: 1291:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1292:		      break;
        -: 1293:		    }
    #####: 1294:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1295:		    {
    #####: 1296:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1297:			{
        -: 1298:			  if (DEBUG)
        -: 1299:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1300:			}	
    #####: 1301:		      break;
        -: 1302:		    }		
        -: 1303:		}
        -: 1304:					
        -: 1305:	    }
        -: 1306:				
        -: 1307:	}				
        -: 1308:
        -: 1309:      //discard played card from hand
    #####: 1310:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1311:
    #####: 1312:      return 0;
        -: 1313:
        -: 1314:		
        -: 1315:    case embargo: 
        -: 1316:      //+2 Coins
    #####: 1317:      state->coins = state->coins + 2;
        -: 1318:			
        -: 1319:      //see if selected pile is in play
    #####: 1320:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1321:	{
    #####: 1322:	  return -1;
        -: 1323:	}
        -: 1324:			
        -: 1325:      //add embargo token to selected supply pile
    #####: 1326:      state->embargoTokens[choice1]++;
        -: 1327:			
        -: 1328:      //trash card
    #####: 1329:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1330:      return 0;
        -: 1331:		
        -: 1332:    case outpost:
        -: 1333:      //set outpost flag
    #####: 1334:      state->outpostPlayed++;
        -: 1335:			
        -: 1336:      //discard card
    #####: 1337:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1338:      return 0;
        -: 1339:		
        -: 1340:    case salvager:
        -: 1341:      //+1 buy
    #####: 1342:      state->numBuys++;
        -: 1343:			
    #####: 1344:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1345:	{
        -: 1346:	  //gain coins equal to trashed card
    #####: 1347:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1348:	  //trash card
    #####: 1349:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1350:	}
        -: 1351:			
        -: 1352:      //discard card
    #####: 1353:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1354:      return 0;
        -: 1355:		
        -: 1356:    case sea_hag:
    #####: 1357:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1358:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1359:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1360:	  state->discardCount[i]++;
    #####: 1361:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1362:	}
        -: 1363:      }
    #####: 1364:      return 0;
        -: 1365:		
        -: 1366:    case treasure_map:
        -: 1367:      //search hand for another treasure_map
    #####: 1368:      index = -1;
    #####: 1369:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1370:	{
    #####: 1371:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1372:	    {
    #####: 1373:	      index = i;
    #####: 1374:	      break;
        -: 1375:	    }
        -: 1376:	}
    #####: 1377:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1378:	{
        -: 1379:	  //trash both treasure cards
    #####: 1380:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1381:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1382:
        -: 1383:	  //gain 4 Gold cards
    #####: 1384:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1385:	    {
    #####: 1386:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1387:	    }
        -: 1388:				
        -: 1389:	  //return success
    #####: 1390:	  return 1;
        -: 1391:	}
        -: 1392:			
        -: 1393:      //no second treasure_map found in hand
    #####: 1394:      return -1;
        -: 1395:    }
        -: 1396:	
    #####: 1397:  return -1;
        -: 1398:}
        -: 1399:
function discardCard called 3 returned 100% blocks executed 89%
        3: 1400:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1401:{
        -: 1402:	
        -: 1403:  //if card is not trashed, added to Played pile 
        3: 1404:  if (trashFlag < 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1405:    {
        -: 1406:      //add card to played pile
        3: 1407:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
        3: 1408:      state->playedCardCount++;
        -: 1409:    }
        -: 1410:	
        -: 1411:  //set played card to -1
        3: 1412:  state->hand[currentPlayer][handPos] = -1;
        -: 1413:	
        -: 1414:  //remove card from player's hand
        3: 1415:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -: 1416:    {
        -: 1417:      //reduce number of cards in hand
        1: 1418:      state->handCount[currentPlayer]--;
        -: 1419:    }
        2: 1420:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1421:    {
        -: 1422:      //reduce number of cards in hand
    #####: 1423:      state->handCount[currentPlayer]--;
        -: 1424:    }
        -: 1425:  else 	
        -: 1426:    {
        -: 1427:      //replace discarded card with last card in hand
        2: 1428:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1429:      //set last card to -1
        2: 1430:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1431:      //reduce number of cards in hand
        2: 1432:      state->handCount[currentPlayer]--;
        -: 1433:    }
        -: 1434:	
        3: 1435:  return 0;
        -: 1436:}
        -: 1437:
function gainCard called 4 returned 100% blocks executed 70%
        4: 1438:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1439:{
        -: 1440:  //Note: supplyPos is enum of choosen card
        -: 1441:	
        -: 1442:  //check if supply pile is empty (0) or card is not used in game (-1)
        4: 1443:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1444:    {
    #####: 1445:      return -1;
        -: 1446:    }
        -: 1447:	
        -: 1448:  //added card for [whoseTurn] current player:
        -: 1449:  // toFlag = 0 : add to discard
        -: 1450:  // toFlag = 1 : add to deck
        -: 1451:  // toFlag = 2 : add to hand
        -: 1452:
        4: 1453:  if (toFlag == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1454:    {
    #####: 1455:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1456:      state->deckCount[player]++;
        -: 1457:    }
        4: 1458:  else if (toFlag == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1459:    {
        4: 1460:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
        4: 1461:      state->handCount[player]++;
        -: 1462:    }
        -: 1463:  else
        -: 1464:    {
    #####: 1465:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1466:      state->discardCount[player]++;
        -: 1467:    }
        -: 1468:	
        -: 1469:  //decrease number in supply pile
        4: 1470:  state->supplyCount[supplyPos]--;
        -: 1471:	 
        4: 1472:  return 0;
        -: 1473:}
        -: 1474:
function updateCoins called 589 returned 100% blocks executed 100%
      589: 1475:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1476:{
        -: 1477:  int i;
        -: 1478:	
        -: 1479:  //reset coin count
      589: 1480:  state->coins = 0;
        -: 1481:
        -: 1482:  //add coins for each Treasure card in player's hand
     2874: 1483:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -: 1484:    {
     2285: 1485:      if (state->hand[player][i] == copper)
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
        -: 1486:	{
     1291: 1487:	  state->coins += 1;
        -: 1488:	}
      994: 1489:      else if (state->hand[player][i] == silver)
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
        -: 1490:	{
      418: 1491:	  state->coins += 2;
        -: 1492:	}
      576: 1493:      else if (state->hand[player][i] == gold)
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
        -: 1494:	{
      374: 1495:	  state->coins += 3;
        -: 1496:	}	
        -: 1497:    }	
        -: 1498:
        -: 1499:  //add bonus
      589: 1500:  state->coins += bonus;
        -: 1501:
      589: 1502:  return 0;
        -: 1503:}
        -: 1504:
        -: 1505:
        -: 1506://end of dominion.c
        -: 1507:
